/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function checkPathExt(path8, options3) {
      var pathext = options3.pathExt !== void 0 ? options3.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i4 = 0; i4 < pathext.length; i4++) {
        var p5 = pathext[i4].toLowerCase();
        if (p5 && path8.substr(-p5.length).toLowerCase() === p5) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path8, options3) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path8, options3);
    }
    function isexe(path8, options3, cb) {
      fs2.stat(path8, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path8, options3));
      });
    }
    function sync(path8, options3) {
      return checkStat(fs2.statSync(path8), path8, options3);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function isexe(path8, options3, cb) {
      fs2.stat(path8, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options3));
      });
    }
    function sync(path8, options3) {
      return checkStat(fs2.statSync(path8), options3);
    }
    function checkStat(stat, options3) {
      return stat.isFile() && checkMode(stat, options3);
    }
    function checkMode(stat, options3) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options3.uid !== void 0 ? options3.uid : process.getuid && process.getuid();
      var myGid = options3.gid !== void 0 ? options3.gid : process.getgid && process.getgid();
      var u3 = parseInt("100", 8);
      var g5 = parseInt("010", 8);
      var o4 = parseInt("001", 8);
      var ug = u3 | g5;
      var ret = mod & o4 || mod & g5 && gid === myGid || mod & u3 && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports2, module2) {
    var fs2 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path8, options3, cb) {
      if (typeof options3 === "function") {
        cb = options3;
        options3 = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject2) {
          isexe(path8, options3 || {}, function(er, is) {
            if (er) {
              reject2(er);
            } else {
              resolve2(is);
            }
          });
        });
      }
      core(path8, options3 || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options3 && options3.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path8, options3) {
      try {
        return core.sync(path8, options3 || {});
      } catch (er) {
        if (options3 && options3.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/cross-spawn/node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/cross-spawn/node_modules/which/which.js"(exports2, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path8 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which2 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i4) => new Promise((resolve2, reject2) => {
        if (i4 === pathEnv.length)
          return opt.all && found.length ? resolve2(found) : reject2(getNotFoundError(cmd));
        const ppRaw = pathEnv[i4];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path8.join(pathPart, cmd);
        const p5 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve2(subStep(p5, i4, 0));
      });
      const subStep = (p5, i4, ii) => new Promise((resolve2, reject2) => {
        if (ii === pathExt.length)
          return resolve2(step(i4 + 1));
        const ext = pathExt[ii];
        isexe(p5 + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p5 + ext);
            else
              return resolve2(p5 + ext);
          }
          return resolve2(subStep(p5, i4, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i4 = 0; i4 < pathEnv.length; i4++) {
        const ppRaw = pathEnv[i4];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path8.join(pathPart, cmd);
        const p5 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j4 = 0; j4 < pathExt.length; j4++) {
          const cur = p5 + pathExt[j4];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// node_modules/cross-spawn/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "node_modules/cross-spawn/node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    var pathKey2 = (options3 = {}) => {
      const environment = options3.env || process.env;
      const platform = options3.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey2;
    module2.exports.default = pathKey2;
  }
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path8 = require("path");
    var which2 = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env2 = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which2.sync(parsed.command, {
          path: env2[getPathKey({ env: env2 })],
          pathExt: withoutPathExt ? path8.delimiter : void 0
        });
      } catch (e3) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path8.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match2 = string.match(shebangRegex);
      if (!match2) {
        return null;
      }
      const [path8, argument] = match2[0].replace(/#! ?/, "").split(" ");
      const binary = path8.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs2.openSync(command, "r");
        fs2.readSync(fd, buffer, 0, size, 0);
        fs2.closeSync(fd);
      } catch (e3) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var path8 = require("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path8.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse3(command, args2, options3) {
      if (args2 && !Array.isArray(args2)) {
        options3 = args2;
        args2 = null;
      }
      args2 = args2 ? args2.slice(0) : [];
      options3 = Object.assign({}, options3);
      const parsed = {
        command,
        args: args2,
        options: options3,
        file: void 0,
        original: {
          command,
          args: args2
        }
      };
      return options3.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse3;
  }
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = require("child_process");
    var parse3 = require_parse();
    var enoent = require_enoent();
    function spawn(command, args2, options3) {
      const parsed = parse3(command, args2, options3);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args2, options3) {
      const parsed = parse3(command, args2, options3);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse3;
    module2.exports._enoent = enoent;
  }
});

// node_modules/shell-env/node_modules/strip-final-newline/index.js
var require_strip_final_newline = __commonJS({
  "node_modules/shell-env/node_modules/strip-final-newline/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (input) => {
      const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
      const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
      if (input[input.length - 1] === LF) {
        input = input.slice(0, input.length - 1);
      }
      if (input[input.length - 1] === CR) {
        input = input.slice(0, input.length - 1);
      }
      return input;
    };
  }
});

// node_modules/shell-env/node_modules/path-key/index.js
var require_path_key2 = __commonJS({
  "node_modules/shell-env/node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    var pathKey2 = (options3 = {}) => {
      const environment = options3.env || process.env;
      const platform = options3.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey2;
    module2.exports.default = pathKey2;
  }
});

// node_modules/shell-env/node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS({
  "node_modules/shell-env/node_modules/npm-run-path/index.js"(exports2, module2) {
    "use strict";
    var path8 = require("path");
    var pathKey2 = require_path_key2();
    var npmRunPath2 = (options3) => {
      options3 = {
        cwd: process.cwd(),
        path: process.env[pathKey2()],
        execPath: process.execPath,
        ...options3
      };
      let previous;
      let cwdPath = path8.resolve(options3.cwd);
      const result = [];
      while (previous !== cwdPath) {
        result.push(path8.join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = path8.resolve(cwdPath, "..");
      }
      const execPathDir = path8.resolve(options3.cwd, options3.execPath, "..");
      result.push(execPathDir);
      return result.concat(options3.path).join(path8.delimiter);
    };
    module2.exports = npmRunPath2;
    module2.exports.default = npmRunPath2;
    module2.exports.env = (options3) => {
      options3 = {
        env: process.env,
        ...options3
      };
      const env2 = { ...options3.env };
      const path9 = pathKey2({ env: env2 });
      options3.path = env2[path9];
      env2[path9] = module2.exports(options3);
      return env2;
    };
  }
});

// node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "node_modules/mimic-fn/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = (to, from2) => {
      for (const prop of Reflect.ownKeys(from2)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from2, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// node_modules/shell-env/node_modules/onetime/index.js
var require_onetime = __commonJS({
  "node_modules/shell-env/node_modules/onetime/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    var calledFunctions2 = /* @__PURE__ */ new WeakMap();
    var onetime2 = (function_, options3 = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime3 = function(...arguments_) {
        calledFunctions2.set(onetime3, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options3.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime3, function_);
      calledFunctions2.set(onetime3, callCount);
      return onetime3;
    };
    module2.exports = onetime2;
    module2.exports.default = onetime2;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions2.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions2.get(function_);
    };
  }
});

// node_modules/shell-env/node_modules/human-signals/build/src/core.js
var require_core = __commonJS({
  "node_modules/shell-env/node_modules/human-signals/build/src/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SIGNALS = void 0;
    var SIGNALS2 = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
    exports2.SIGNALS = SIGNALS2;
  }
});

// node_modules/shell-env/node_modules/human-signals/build/src/realtime.js
var require_realtime = __commonJS({
  "node_modules/shell-env/node_modules/human-signals/build/src/realtime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
    var getRealtimeSignals2 = function() {
      const length2 = SIGRTMAX2 - SIGRTMIN2 + 1;
      return Array.from({ length: length2 }, getRealtimeSignal2);
    };
    exports2.getRealtimeSignals = getRealtimeSignals2;
    var getRealtimeSignal2 = function(value, index2) {
      return {
        name: `SIGRT${index2 + 1}`,
        number: SIGRTMIN2 + index2,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
      };
    };
    var SIGRTMIN2 = 34;
    var SIGRTMAX2 = 64;
    exports2.SIGRTMAX = SIGRTMAX2;
  }
});

// node_modules/shell-env/node_modules/human-signals/build/src/signals.js
var require_signals = __commonJS({
  "node_modules/shell-env/node_modules/human-signals/build/src/signals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSignals = void 0;
    var _os = require("os");
    var _core = require_core();
    var _realtime = require_realtime();
    var getSignals2 = function() {
      const realtimeSignals = (0, _realtime.getRealtimeSignals)();
      const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal2);
      return signals;
    };
    exports2.getSignals = getSignals2;
    var normalizeSignal2 = function({
      name,
      number: defaultNumber,
      description,
      action,
      forced = false,
      standard
    }) {
      const {
        signals: { [name]: constantSignal }
      } = _os.constants;
      const supported = constantSignal !== void 0;
      const number = supported ? constantSignal : defaultNumber;
      return { name, number, description, supported, action, forced, standard };
    };
  }
});

// node_modules/shell-env/node_modules/human-signals/build/src/main.js
var require_main = __commonJS({
  "node_modules/shell-env/node_modules/human-signals/build/src/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalsByNumber = exports2.signalsByName = void 0;
    var _os = require("os");
    var _signals = require_signals();
    var _realtime = require_realtime();
    var getSignalsByName2 = function() {
      const signals = (0, _signals.getSignals)();
      return signals.reduce(getSignalByName2, {});
    };
    var getSignalByName2 = function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
      return {
        ...signalByNameMemo,
        [name]: { name, number, description, supported, action, forced, standard }
      };
    };
    var signalsByName2 = getSignalsByName2();
    exports2.signalsByName = signalsByName2;
    var getSignalsByNumber2 = function() {
      const signals = (0, _signals.getSignals)();
      const length2 = _realtime.SIGRTMAX + 1;
      const signalsA = Array.from({ length: length2 }, (value, number) => getSignalByNumber2(number, signals));
      return Object.assign({}, ...signalsA);
    };
    var getSignalByNumber2 = function(number, signals) {
      const signal = findSignalByNumber2(number, signals);
      if (signal === void 0) {
        return {};
      }
      const { name, description, supported, action, forced, standard } = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard
        }
      };
    };
    var findSignalByNumber2 = function(number, signals) {
      const signal = signals.find(({ name }) => _os.constants.signals[name] === number);
      if (signal !== void 0) {
        return signal;
      }
      return signals.find((signalA) => signalA.number === number);
    };
    var signalsByNumber2 = getSignalsByNumber2();
    exports2.signalsByNumber = signalsByNumber2;
  }
});

// node_modules/shell-env/node_modules/execa/lib/error.js
var require_error = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/error.js"(exports2, module2) {
    "use strict";
    var { signalsByName: signalsByName2 } = require_main();
    var getErrorPrefix2 = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
      if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
      }
      if (isCanceled) {
        return "was canceled";
      }
      if (errorCode !== void 0) {
        return `failed with ${errorCode}`;
      }
      if (signal !== void 0) {
        return `was killed with ${signal} (${signalDescription})`;
      }
      if (exitCode !== void 0) {
        return `failed with exit code ${exitCode}`;
      }
      return "failed";
    };
    var makeError2 = ({
      stdout,
      stderr,
      all,
      error,
      signal,
      exitCode,
      command,
      escapedCommand,
      timedOut,
      isCanceled,
      killed,
      parsed: { options: { timeout } }
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode;
      signal = signal === null ? void 0 : signal;
      const signalDescription = signal === void 0 ? void 0 : signalsByName2[signal].description;
      const errorCode = error && error.code;
      const prefix2 = getErrorPrefix2({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
      const execaMessage = `Command ${prefix2}: ${command}`;
      const isError = Object.prototype.toString.call(error) === "[object Error]";
      const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
      const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
      if (isError) {
        error.originalMessage = error.message;
        error.message = message;
      } else {
        error = new Error(message);
      }
      error.shortMessage = shortMessage;
      error.command = command;
      error.escapedCommand = escapedCommand;
      error.exitCode = exitCode;
      error.signal = signal;
      error.signalDescription = signalDescription;
      error.stdout = stdout;
      error.stderr = stderr;
      if (all !== void 0) {
        error.all = all;
      }
      if ("bufferedData" in error) {
        delete error.bufferedData;
      }
      error.failed = true;
      error.timedOut = Boolean(timedOut);
      error.isCanceled = isCanceled;
      error.killed = killed && !timedOut;
      return error;
    };
    module2.exports = makeError2;
  }
});

// node_modules/shell-env/node_modules/execa/lib/stdio.js
var require_stdio = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/stdio.js"(exports2, module2) {
    "use strict";
    var aliases2 = ["stdin", "stdout", "stderr"];
    var hasAlias2 = (options3) => aliases2.some((alias) => options3[alias] !== void 0);
    var normalizeStdio2 = (options3) => {
      if (!options3) {
        return;
      }
      const { stdio } = options3;
      if (stdio === void 0) {
        return aliases2.map((alias) => options3[alias]);
      }
      if (hasAlias2(options3)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases2.map((alias) => `\`${alias}\``).join(", ")}`);
      }
      if (typeof stdio === "string") {
        return stdio;
      }
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const length2 = Math.max(stdio.length, aliases2.length);
      return Array.from({ length: length2 }, (value, index2) => stdio[index2]);
    };
    module2.exports = normalizeStdio2;
    module2.exports.node = (options3) => {
      const stdio = normalizeStdio2(options3);
      if (stdio === "ipc") {
        return "ipc";
      }
      if (stdio === void 0 || typeof stdio === "string") {
        return [stdio, stdio, stdio, "ipc"];
      }
      if (stdio.includes("ipc")) {
        return stdio;
      }
      return [...stdio, "ipc"];
    };
  }
});

// node_modules/signal-exit/signals.js
var require_signals2 = __commonJS({
  "node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports2, module2) {
    var process7 = global.process;
    var processOk = function(process8) {
      return process8 && typeof process8 === "object" && typeof process8.removeListener === "function" && typeof process8.emit === "function" && typeof process8.reallyExit === "function" && typeof process8.listeners === "function" && typeof process8.kill === "function" && typeof process8.pid === "number" && typeof process8.on === "function";
    };
    if (!processOk(process7)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert = require("assert");
      signals = require_signals2();
      isWin = /^win/i.test(process7.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process7.__signal_exit_emitter__) {
        emitter = process7.__signal_exit_emitter__;
      } else {
        emitter = process7.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process7.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process7.emit = originalProcessEmit;
        process7.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process7.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process7.kill(process7.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process7.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process7.emit = processEmit;
        process7.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process7.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process7.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process7.exitCode, null);
        emit("afterexit", process7.exitCode, null);
        originalProcessReallyExit.call(process7, process7.exitCode);
      };
      originalProcessEmit = process7.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process7.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process7.exitCode, null);
          emit("afterexit", process7.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/shell-env/node_modules/execa/lib/kill.js
var require_kill = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/kill.js"(exports2, module2) {
    "use strict";
    var os4 = require("os");
    var onExit2 = require_signal_exit();
    var DEFAULT_FORCE_KILL_TIMEOUT2 = 1e3 * 5;
    var spawnedKill2 = (kill, signal = "SIGTERM", options3 = {}) => {
      const killResult = kill(signal);
      setKillTimeout2(kill, signal, options3, killResult);
      return killResult;
    };
    var setKillTimeout2 = (kill, signal, options3, killResult) => {
      if (!shouldForceKill2(signal, options3, killResult)) {
        return;
      }
      const timeout = getForceKillAfterTimeout2(options3);
      const t3 = setTimeout(() => {
        kill("SIGKILL");
      }, timeout);
      if (t3.unref) {
        t3.unref();
      }
    };
    var shouldForceKill2 = (signal, { forceKillAfterTimeout }, killResult) => {
      return isSigterm2(signal) && forceKillAfterTimeout !== false && killResult;
    };
    var isSigterm2 = (signal) => {
      return signal === os4.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
    };
    var getForceKillAfterTimeout2 = ({ forceKillAfterTimeout = true }) => {
      if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT2;
      }
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      }
      return forceKillAfterTimeout;
    };
    var spawnedCancel2 = (spawned, context) => {
      const killResult = spawned.kill();
      if (killResult) {
        context.isCanceled = true;
      }
    };
    var timeoutKill2 = (spawned, signal, reject2) => {
      spawned.kill(signal);
      reject2(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
    };
    var setupTimeout2 = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0) {
        return spawnedPromise;
      }
      let timeoutId;
      const timeoutPromise = new Promise((resolve2, reject2) => {
        timeoutId = setTimeout(() => {
          timeoutKill2(spawned, killSignal, reject2);
        }, timeout);
      });
      const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    };
    var validateTimeout2 = ({ timeout }) => {
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
      }
    };
    var setExitHandler2 = async (spawned, { cleanup, detached }, timedPromise) => {
      if (!cleanup || detached) {
        return timedPromise;
      }
      const removeExitHandler = onExit2(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    };
    module2.exports = {
      spawnedKill: spawnedKill2,
      spawnedCancel: spawnedCancel2,
      setupTimeout: setupTimeout2,
      validateTimeout: validateTimeout2,
      setExitHandler: setExitHandler2
    };
  }
});

// node_modules/shell-env/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/shell-env/node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream2 = (stream2) => stream2 !== null && typeof stream2 === "object" && typeof stream2.pipe === "function";
    isStream2.writable = (stream2) => isStream2(stream2) && stream2.writable !== false && typeof stream2._write === "function" && typeof stream2._writableState === "object";
    isStream2.readable = (stream2) => isStream2(stream2) && stream2.readable !== false && typeof stream2._read === "function" && typeof stream2._readableState === "object";
    isStream2.duplex = (stream2) => isStream2.writable(stream2) && isStream2.readable(stream2);
    isStream2.transform = (stream2) => isStream2.duplex(stream2) && typeof stream2._transform === "function";
    module2.exports = isStream2;
  }
});

// node_modules/shell-env/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/shell-env/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options3) => {
      options3 = { ...options3 };
      const { array } = options3;
      let { encoding } = options3;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream2 = new PassThroughStream({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      let length2 = 0;
      const chunks = [];
      stream2.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length2 = chunks.length;
        } else {
          length2 += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length2) : chunks.join("");
      };
      stream2.getBufferedLength = () => length2;
      return stream2;
    };
  }
});

// node_modules/shell-env/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/shell-env/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var stream2 = require("stream");
    var { promisify } = require("util");
    var bufferStream = require_buffer_stream();
    var streamPipelinePromisified = promisify(stream2.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream2(inputStream, options3) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options3 = {
        maxBuffer: Infinity,
        ...options3
      };
      const { maxBuffer } = options3;
      const stream3 = bufferStream(options3);
      await new Promise((resolve2, reject2) => {
        const rejectPromise = (error) => {
          if (error && stream3.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream3.getBufferedValue();
          }
          reject2(error);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream3);
            resolve2();
          } catch (error) {
            rejectPromise(error);
          }
        })();
        stream3.on("data", () => {
          if (stream3.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream3.getBufferedValue();
    }
    module2.exports = getStream2;
    module2.exports.buffer = (stream3, options3) => getStream2(stream3, { ...options3, encoding: "buffer" });
    module2.exports.array = (stream3, options3) => getStream2(stream3, { ...options3, array: true });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/merge-stream/index.js
var require_merge_stream = __commonJS({
  "node_modules/merge-stream/index.js"(exports2, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    module2.exports = function() {
      var sources = [];
      var output = new PassThrough({ objectMode: true });
      output.setMaxListeners(0);
      output.add = add;
      output.isEmpty = isEmpty;
      output.on("unpipe", remove);
      Array.prototype.slice.call(arguments).forEach(add);
      return output;
      function add(source) {
        if (Array.isArray(source)) {
          source.forEach(add);
          return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, { end: false });
        return this;
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        });
        if (!sources.length && output.readable) {
          output.end();
        }
      }
    };
  }
});

// node_modules/shell-env/node_modules/execa/lib/stream.js
var require_stream = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/stream.js"(exports2, module2) {
    "use strict";
    var isStream2 = require_is_stream();
    var getStream2 = require_get_stream();
    var mergeStream2 = require_merge_stream();
    var handleInput2 = (spawned, input) => {
      if (input === void 0 || spawned.stdin === void 0) {
        return;
      }
      if (isStream2(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    };
    var makeAllStream2 = (spawned, { all }) => {
      if (!all || !spawned.stdout && !spawned.stderr) {
        return;
      }
      const mixed = mergeStream2();
      if (spawned.stdout) {
        mixed.add(spawned.stdout);
      }
      if (spawned.stderr) {
        mixed.add(spawned.stderr);
      }
      return mixed;
    };
    var getBufferedData2 = async (stream2, streamPromise) => {
      if (!stream2) {
        return;
      }
      stream2.destroy();
      try {
        return await streamPromise;
      } catch (error) {
        return error.bufferedData;
      }
    };
    var getStreamPromise2 = (stream2, { encoding, buffer, maxBuffer }) => {
      if (!stream2 || !buffer) {
        return;
      }
      if (encoding) {
        return getStream2(stream2, { encoding, maxBuffer });
      }
      return getStream2.buffer(stream2, { maxBuffer });
    };
    var getSpawnedResult2 = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
      const stdoutPromise = getStreamPromise2(stdout, { encoding, buffer, maxBuffer });
      const stderrPromise = getStreamPromise2(stderr, { encoding, buffer, maxBuffer });
      const allPromise = getStreamPromise2(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error) {
        return Promise.all([
          { error, signal: error.signal, timedOut: error.timedOut },
          getBufferedData2(stdout, stdoutPromise),
          getBufferedData2(stderr, stderrPromise),
          getBufferedData2(all, allPromise)
        ]);
      }
    };
    var validateInputSync = ({ input }) => {
      if (isStream2(input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
    };
    module2.exports = {
      handleInput: handleInput2,
      makeAllStream: makeAllStream2,
      getSpawnedResult: getSpawnedResult2,
      validateInputSync
    };
  }
});

// node_modules/shell-env/node_modules/execa/lib/promise.js
var require_promise = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/promise.js"(exports2, module2) {
    "use strict";
    var nativePromisePrototype2 = (/* @__PURE__ */ (async () => {
    })()).constructor.prototype;
    var descriptors2 = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype2, property)
    ]);
    var mergePromise2 = (spawned, promise) => {
      for (const [property, descriptor] of descriptors2) {
        const value = typeof promise === "function" ? (...args2) => Reflect.apply(descriptor.value, promise(), args2) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, { ...descriptor, value });
      }
      return spawned;
    };
    var getSpawnedPromise2 = (spawned) => {
      return new Promise((resolve2, reject2) => {
        spawned.on("exit", (exitCode, signal) => {
          resolve2({ exitCode, signal });
        });
        spawned.on("error", (error) => {
          reject2(error);
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (error) => {
            reject2(error);
          });
        }
      });
    };
    module2.exports = {
      mergePromise: mergePromise2,
      getSpawnedPromise: getSpawnedPromise2
    };
  }
});

// node_modules/shell-env/node_modules/execa/lib/command.js
var require_command = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/command.js"(exports2, module2) {
    "use strict";
    var normalizeArgs2 = (file, args2 = []) => {
      if (!Array.isArray(args2)) {
        return [file];
      }
      return [file, ...args2];
    };
    var NO_ESCAPE_REGEXP2 = /^[\w.-]+$/;
    var DOUBLE_QUOTES_REGEXP2 = /"/g;
    var escapeArg2 = (arg) => {
      if (typeof arg !== "string" || NO_ESCAPE_REGEXP2.test(arg)) {
        return arg;
      }
      return `"${arg.replace(DOUBLE_QUOTES_REGEXP2, '\\"')}"`;
    };
    var joinCommand2 = (file, args2) => {
      return normalizeArgs2(file, args2).join(" ");
    };
    var getEscapedCommand2 = (file, args2) => {
      return normalizeArgs2(file, args2).map((arg) => escapeArg2(arg)).join(" ");
    };
    var SPACES_REGEXP2 = / +/g;
    var parseCommand2 = (command) => {
      const tokens = [];
      for (const token2 of command.trim().split(SPACES_REGEXP2)) {
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) {
          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token2}`;
        } else {
          tokens.push(token2);
        }
      }
      return tokens;
    };
    module2.exports = {
      joinCommand: joinCommand2,
      getEscapedCommand: getEscapedCommand2,
      parseCommand: parseCommand2
    };
  }
});

// node_modules/shell-env/node_modules/execa/index.js
var require_execa = __commonJS({
  "node_modules/shell-env/node_modules/execa/index.js"(exports2, module2) {
    "use strict";
    var path8 = require("path");
    var childProcess2 = require("child_process");
    var crossSpawn2 = require_cross_spawn();
    var stripFinalNewline2 = require_strip_final_newline();
    var npmRunPath2 = require_npm_run_path();
    var onetime2 = require_onetime();
    var makeError2 = require_error();
    var normalizeStdio2 = require_stdio();
    var { spawnedKill: spawnedKill2, spawnedCancel: spawnedCancel2, setupTimeout: setupTimeout2, validateTimeout: validateTimeout2, setExitHandler: setExitHandler2 } = require_kill();
    var { handleInput: handleInput2, getSpawnedResult: getSpawnedResult2, makeAllStream: makeAllStream2, validateInputSync } = require_stream();
    var { mergePromise: mergePromise2, getSpawnedPromise: getSpawnedPromise2 } = require_promise();
    var { joinCommand: joinCommand2, parseCommand: parseCommand2, getEscapedCommand: getEscapedCommand2 } = require_command();
    var DEFAULT_MAX_BUFFER2 = 1e3 * 1e3 * 100;
    var getEnv2 = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
      const env2 = extendEnv ? { ...process.env, ...envOption } : envOption;
      if (preferLocal) {
        return npmRunPath2.env({ env: env2, cwd: localDir, execPath });
      }
      return env2;
    };
    var handleArguments2 = (file, args2, options3 = {}) => {
      const parsed = crossSpawn2._parse(file, args2, options3);
      file = parsed.command;
      args2 = parsed.args;
      options3 = parsed.options;
      options3 = {
        maxBuffer: DEFAULT_MAX_BUFFER2,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options3.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        ...options3
      };
      options3.env = getEnv2(options3);
      options3.stdio = normalizeStdio2(options3);
      if (process.platform === "win32" && path8.basename(file, ".exe") === "cmd") {
        args2.unshift("/q");
      }
      return { file, args: args2, options: options3, parsed };
    };
    var handleOutput2 = (options3, value, error) => {
      if (typeof value !== "string" && !Buffer.isBuffer(value)) {
        return error === void 0 ? void 0 : "";
      }
      if (options3.stripFinalNewline) {
        return stripFinalNewline2(value);
      }
      return value;
    };
    var execa3 = (file, args2, options3) => {
      const parsed = handleArguments2(file, args2, options3);
      const command = joinCommand2(file, args2);
      const escapedCommand = getEscapedCommand2(file, args2);
      validateTimeout2(parsed.options);
      let spawned;
      try {
        spawned = childProcess2.spawn(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        const dummySpawned = new childProcess2.ChildProcess();
        const errorPromise = Promise.reject(makeError2({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        }));
        return mergePromise2(dummySpawned, errorPromise);
      }
      const spawnedPromise = getSpawnedPromise2(spawned);
      const timedPromise = setupTimeout2(spawned, parsed.options, spawnedPromise);
      const processDone = setExitHandler2(spawned, parsed.options, timedPromise);
      const context = { isCanceled: false };
      spawned.kill = spawnedKill2.bind(null, spawned.kill.bind(spawned));
      spawned.cancel = spawnedCancel2.bind(null, spawned, context);
      const handlePromise = async () => {
        const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult2(spawned, parsed.options, processDone);
        const stdout = handleOutput2(parsed.options, stdoutResult);
        const stderr = handleOutput2(parsed.options, stderrResult);
        const all = handleOutput2(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
          const returnedError = makeError2({
            error,
            exitCode,
            signal,
            stdout,
            stderr,
            all,
            command,
            escapedCommand,
            parsed,
            timedOut,
            isCanceled: context.isCanceled,
            killed: spawned.killed
          });
          if (!parsed.options.reject) {
            return returnedError;
          }
          throw returnedError;
        }
        return {
          command,
          escapedCommand,
          exitCode: 0,
          stdout,
          stderr,
          all,
          failed: false,
          timedOut: false,
          isCanceled: false,
          killed: false
        };
      };
      const handlePromiseOnce = onetime2(handlePromise);
      handleInput2(spawned, parsed.options.input);
      spawned.all = makeAllStream2(spawned, parsed.options);
      return mergePromise2(spawned, handlePromiseOnce);
    };
    module2.exports = execa3;
    module2.exports.sync = (file, args2, options3) => {
      const parsed = handleArguments2(file, args2, options3);
      const command = joinCommand2(file, args2);
      const escapedCommand = getEscapedCommand2(file, args2);
      validateInputSync(parsed.options);
      let result;
      try {
        result = childProcess2.spawnSync(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        throw makeError2({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        });
      }
      const stdout = handleOutput2(parsed.options, result.stdout, result.error);
      const stderr = handleOutput2(parsed.options, result.stderr, result.error);
      if (result.error || result.status !== 0 || result.signal !== null) {
        const error = makeError2({
          stdout,
          stderr,
          error: result.error,
          signal: result.signal,
          exitCode: result.status,
          command,
          escapedCommand,
          parsed,
          timedOut: result.error && result.error.code === "ETIMEDOUT",
          isCanceled: false,
          killed: result.signal !== null
        });
        if (!parsed.options.reject) {
          return error;
        }
        throw error;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    module2.exports.command = (command, options3) => {
      const [file, ...args2] = parseCommand2(command);
      return execa3(file, args2, options3);
    };
    module2.exports.commandSync = (command, options3) => {
      const [file, ...args2] = parseCommand2(command);
      return execa3.sync(file, args2, options3);
    };
    module2.exports.node = (scriptPath, args2, options3 = {}) => {
      if (args2 && !Array.isArray(args2) && typeof args2 === "object") {
        options3 = args2;
        args2 = [];
      }
      const stdio = normalizeStdio2.node(options3);
      const defaultExecArgv = process.execArgv.filter((arg) => !arg.startsWith("--inspect"));
      const {
        nodePath = process.execPath,
        nodeOptions = defaultExecArgv
      } = options3;
      return execa3(
        nodePath,
        [
          ...nodeOptions,
          scriptPath,
          ...Array.isArray(args2) ? args2 : []
        ],
        {
          ...options3,
          stdin: void 0,
          stdout: void 0,
          stderr: void 0,
          stdio,
          shell: false
        }
      );
    };
  }
});

// node_modules/base16/lib/threezerotwofour.js
var require_threezerotwofour = __commonJS({
  "node_modules/base16/lib/threezerotwofour.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "threezerotwofour",
      author: "jan t. sott (http://github.com/idleberg)",
      base00: "#090300",
      base01: "#3a3432",
      base02: "#4a4543",
      base03: "#5c5855",
      base04: "#807d7c",
      base05: "#a5a2a2",
      base06: "#d6d5d4",
      base07: "#f7f7f7",
      base08: "#db2d20",
      base09: "#e8bbd0",
      base0A: "#fded02",
      base0B: "#01a252",
      base0C: "#b5e4f4",
      base0D: "#01a0e4",
      base0E: "#a16a94",
      base0F: "#cdab53"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/apathy.js
var require_apathy = __commonJS({
  "node_modules/base16/lib/apathy.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "apathy",
      author: "jannik siebert (https://github.com/janniks)",
      base00: "#031A16",
      base01: "#0B342D",
      base02: "#184E45",
      base03: "#2B685E",
      base04: "#5F9C92",
      base05: "#81B5AC",
      base06: "#A7CEC8",
      base07: "#D2E7E4",
      base08: "#3E9688",
      base09: "#3E7996",
      base0A: "#3E4C96",
      base0B: "#883E96",
      base0C: "#963E4C",
      base0D: "#96883E",
      base0E: "#4C963E",
      base0F: "#3E965B"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/ashes.js
var require_ashes = __commonJS({
  "node_modules/base16/lib/ashes.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "ashes",
      author: "jannik siebert (https://github.com/janniks)",
      base00: "#1C2023",
      base01: "#393F45",
      base02: "#565E65",
      base03: "#747C84",
      base04: "#ADB3BA",
      base05: "#C7CCD1",
      base06: "#DFE2E5",
      base07: "#F3F4F5",
      base08: "#C7AE95",
      base09: "#C7C795",
      base0A: "#AEC795",
      base0B: "#95C7AE",
      base0C: "#95AEC7",
      base0D: "#AE95C7",
      base0E: "#C795AE",
      base0F: "#C79595"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/atelier-dune.js
var require_atelier_dune = __commonJS({
  "node_modules/base16/lib/atelier-dune.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "atelier dune",
      author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/dune)",
      base00: "#20201d",
      base01: "#292824",
      base02: "#6e6b5e",
      base03: "#7d7a68",
      base04: "#999580",
      base05: "#a6a28c",
      base06: "#e8e4cf",
      base07: "#fefbec",
      base08: "#d73737",
      base09: "#b65611",
      base0A: "#cfb017",
      base0B: "#60ac39",
      base0C: "#1fad83",
      base0D: "#6684e1",
      base0E: "#b854d4",
      base0F: "#d43552"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/atelier-forest.js
var require_atelier_forest = __commonJS({
  "node_modules/base16/lib/atelier-forest.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "atelier forest",
      author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/forest)",
      base00: "#1b1918",
      base01: "#2c2421",
      base02: "#68615e",
      base03: "#766e6b",
      base04: "#9c9491",
      base05: "#a8a19f",
      base06: "#e6e2e0",
      base07: "#f1efee",
      base08: "#f22c40",
      base09: "#df5320",
      base0A: "#d5911a",
      base0B: "#5ab738",
      base0C: "#00ad9c",
      base0D: "#407ee7",
      base0E: "#6666ea",
      base0F: "#c33ff3"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/atelier-heath.js
var require_atelier_heath = __commonJS({
  "node_modules/base16/lib/atelier-heath.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "atelier heath",
      author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/heath)",
      base00: "#1b181b",
      base01: "#292329",
      base02: "#695d69",
      base03: "#776977",
      base04: "#9e8f9e",
      base05: "#ab9bab",
      base06: "#d8cad8",
      base07: "#f7f3f7",
      base08: "#ca402b",
      base09: "#a65926",
      base0A: "#bb8a35",
      base0B: "#379a37",
      base0C: "#159393",
      base0D: "#516aec",
      base0E: "#7b59c0",
      base0F: "#cc33cc"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/atelier-lakeside.js
var require_atelier_lakeside = __commonJS({
  "node_modules/base16/lib/atelier-lakeside.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "atelier lakeside",
      author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/lakeside/)",
      base00: "#161b1d",
      base01: "#1f292e",
      base02: "#516d7b",
      base03: "#5a7b8c",
      base04: "#7195a8",
      base05: "#7ea2b4",
      base06: "#c1e4f6",
      base07: "#ebf8ff",
      base08: "#d22d72",
      base09: "#935c25",
      base0A: "#8a8a0f",
      base0B: "#568c3b",
      base0C: "#2d8f6f",
      base0D: "#257fad",
      base0E: "#5d5db1",
      base0F: "#b72dd2"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/atelier-seaside.js
var require_atelier_seaside = __commonJS({
  "node_modules/base16/lib/atelier-seaside.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "atelier seaside",
      author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/seaside/)",
      base00: "#131513",
      base01: "#242924",
      base02: "#5e6e5e",
      base03: "#687d68",
      base04: "#809980",
      base05: "#8ca68c",
      base06: "#cfe8cf",
      base07: "#f0fff0",
      base08: "#e6193c",
      base09: "#87711d",
      base0A: "#c3c322",
      base0B: "#29a329",
      base0C: "#1999b3",
      base0D: "#3d62f5",
      base0E: "#ad2bee",
      base0F: "#e619c3"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/bespin.js
var require_bespin = __commonJS({
  "node_modules/base16/lib/bespin.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "bespin",
      author: "jan t. sott",
      base00: "#28211c",
      base01: "#36312e",
      base02: "#5e5d5c",
      base03: "#666666",
      base04: "#797977",
      base05: "#8a8986",
      base06: "#9d9b97",
      base07: "#baae9e",
      base08: "#cf6a4c",
      base09: "#cf7d34",
      base0A: "#f9ee98",
      base0B: "#54be0d",
      base0C: "#afc4db",
      base0D: "#5ea6ea",
      base0E: "#9b859d",
      base0F: "#937121"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/brewer.js
var require_brewer = __commonJS({
  "node_modules/base16/lib/brewer.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "brewer",
      author: "timoth\xE9e poisot (http://github.com/tpoisot)",
      base00: "#0c0d0e",
      base01: "#2e2f30",
      base02: "#515253",
      base03: "#737475",
      base04: "#959697",
      base05: "#b7b8b9",
      base06: "#dadbdc",
      base07: "#fcfdfe",
      base08: "#e31a1c",
      base09: "#e6550d",
      base0A: "#dca060",
      base0B: "#31a354",
      base0C: "#80b1d3",
      base0D: "#3182bd",
      base0E: "#756bb1",
      base0F: "#b15928"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/bright.js
var require_bright = __commonJS({
  "node_modules/base16/lib/bright.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "bright",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#000000",
      base01: "#303030",
      base02: "#505050",
      base03: "#b0b0b0",
      base04: "#d0d0d0",
      base05: "#e0e0e0",
      base06: "#f5f5f5",
      base07: "#ffffff",
      base08: "#fb0120",
      base09: "#fc6d24",
      base0A: "#fda331",
      base0B: "#a1c659",
      base0C: "#76c7b7",
      base0D: "#6fb3d2",
      base0E: "#d381c3",
      base0F: "#be643c"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/chalk.js
var require_chalk = __commonJS({
  "node_modules/base16/lib/chalk.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "chalk",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#151515",
      base01: "#202020",
      base02: "#303030",
      base03: "#505050",
      base04: "#b0b0b0",
      base05: "#d0d0d0",
      base06: "#e0e0e0",
      base07: "#f5f5f5",
      base08: "#fb9fb1",
      base09: "#eda987",
      base0A: "#ddb26f",
      base0B: "#acc267",
      base0C: "#12cfc0",
      base0D: "#6fc2ef",
      base0E: "#e1a3ee",
      base0F: "#deaf8f"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/codeschool.js
var require_codeschool = __commonJS({
  "node_modules/base16/lib/codeschool.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "codeschool",
      author: "brettof86",
      base00: "#232c31",
      base01: "#1c3657",
      base02: "#2a343a",
      base03: "#3f4944",
      base04: "#84898c",
      base05: "#9ea7a6",
      base06: "#a7cfa3",
      base07: "#b5d8f6",
      base08: "#2a5491",
      base09: "#43820d",
      base0A: "#a03b1e",
      base0B: "#237986",
      base0C: "#b02f30",
      base0D: "#484d79",
      base0E: "#c59820",
      base0F: "#c98344"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/colors.js
var require_colors = __commonJS({
  "node_modules/base16/lib/colors.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "colors",
      author: "mrmrs (http://clrs.cc)",
      base00: "#111111",
      base01: "#333333",
      base02: "#555555",
      base03: "#777777",
      base04: "#999999",
      base05: "#bbbbbb",
      base06: "#dddddd",
      base07: "#ffffff",
      base08: "#ff4136",
      base09: "#ff851b",
      base0A: "#ffdc00",
      base0B: "#2ecc40",
      base0C: "#7fdbff",
      base0D: "#0074d9",
      base0E: "#b10dc9",
      base0F: "#85144b"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/default.js
var require_default = __commonJS({
  "node_modules/base16/lib/default.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "default",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#181818",
      base01: "#282828",
      base02: "#383838",
      base03: "#585858",
      base04: "#b8b8b8",
      base05: "#d8d8d8",
      base06: "#e8e8e8",
      base07: "#f8f8f8",
      base08: "#ab4642",
      base09: "#dc9656",
      base0A: "#f7ca88",
      base0B: "#a1b56c",
      base0C: "#86c1b9",
      base0D: "#7cafc2",
      base0E: "#ba8baf",
      base0F: "#a16946"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/eighties.js
var require_eighties = __commonJS({
  "node_modules/base16/lib/eighties.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "eighties",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#2d2d2d",
      base01: "#393939",
      base02: "#515151",
      base03: "#747369",
      base04: "#a09f93",
      base05: "#d3d0c8",
      base06: "#e8e6df",
      base07: "#f2f0ec",
      base08: "#f2777a",
      base09: "#f99157",
      base0A: "#ffcc66",
      base0B: "#99cc99",
      base0C: "#66cccc",
      base0D: "#6699cc",
      base0E: "#cc99cc",
      base0F: "#d27b53"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/embers.js
var require_embers = __commonJS({
  "node_modules/base16/lib/embers.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "embers",
      author: "jannik siebert (https://github.com/janniks)",
      base00: "#16130F",
      base01: "#2C2620",
      base02: "#433B32",
      base03: "#5A5047",
      base04: "#8A8075",
      base05: "#A39A90",
      base06: "#BEB6AE",
      base07: "#DBD6D1",
      base08: "#826D57",
      base09: "#828257",
      base0A: "#6D8257",
      base0B: "#57826D",
      base0C: "#576D82",
      base0D: "#6D5782",
      base0E: "#82576D",
      base0F: "#825757"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/flat.js
var require_flat = __commonJS({
  "node_modules/base16/lib/flat.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "flat",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#2C3E50",
      base01: "#34495E",
      base02: "#7F8C8D",
      base03: "#95A5A6",
      base04: "#BDC3C7",
      base05: "#e0e0e0",
      base06: "#f5f5f5",
      base07: "#ECF0F1",
      base08: "#E74C3C",
      base09: "#E67E22",
      base0A: "#F1C40F",
      base0B: "#2ECC71",
      base0C: "#1ABC9C",
      base0D: "#3498DB",
      base0E: "#9B59B6",
      base0F: "#be643c"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/google.js
var require_google = __commonJS({
  "node_modules/base16/lib/google.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "google",
      author: "seth wright (http://sethawright.com)",
      base00: "#1d1f21",
      base01: "#282a2e",
      base02: "#373b41",
      base03: "#969896",
      base04: "#b4b7b4",
      base05: "#c5c8c6",
      base06: "#e0e0e0",
      base07: "#ffffff",
      base08: "#CC342B",
      base09: "#F96A38",
      base0A: "#FBA922",
      base0B: "#198844",
      base0C: "#3971ED",
      base0D: "#3971ED",
      base0E: "#A36AC7",
      base0F: "#3971ED"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/grayscale.js
var require_grayscale = __commonJS({
  "node_modules/base16/lib/grayscale.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "grayscale",
      author: "alexandre gavioli (https://github.com/alexx2/)",
      base00: "#101010",
      base01: "#252525",
      base02: "#464646",
      base03: "#525252",
      base04: "#ababab",
      base05: "#b9b9b9",
      base06: "#e3e3e3",
      base07: "#f7f7f7",
      base08: "#7c7c7c",
      base09: "#999999",
      base0A: "#a0a0a0",
      base0B: "#8e8e8e",
      base0C: "#868686",
      base0D: "#686868",
      base0E: "#747474",
      base0F: "#5e5e5e"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/greenscreen.js
var require_greenscreen = __commonJS({
  "node_modules/base16/lib/greenscreen.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "green screen",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#001100",
      base01: "#003300",
      base02: "#005500",
      base03: "#007700",
      base04: "#009900",
      base05: "#00bb00",
      base06: "#00dd00",
      base07: "#00ff00",
      base08: "#007700",
      base09: "#009900",
      base0A: "#007700",
      base0B: "#00bb00",
      base0C: "#005500",
      base0D: "#009900",
      base0E: "#00bb00",
      base0F: "#005500"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/harmonic.js
var require_harmonic = __commonJS({
  "node_modules/base16/lib/harmonic.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "harmonic16",
      author: "jannik siebert (https://github.com/janniks)",
      base00: "#0b1c2c",
      base01: "#223b54",
      base02: "#405c79",
      base03: "#627e99",
      base04: "#aabcce",
      base05: "#cbd6e2",
      base06: "#e5ebf1",
      base07: "#f7f9fb",
      base08: "#bf8b56",
      base09: "#bfbf56",
      base0A: "#8bbf56",
      base0B: "#56bf8b",
      base0C: "#568bbf",
      base0D: "#8b56bf",
      base0E: "#bf568b",
      base0F: "#bf5656"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/hopscotch.js
var require_hopscotch = __commonJS({
  "node_modules/base16/lib/hopscotch.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "hopscotch",
      author: "jan t. sott",
      base00: "#322931",
      base01: "#433b42",
      base02: "#5c545b",
      base03: "#797379",
      base04: "#989498",
      base05: "#b9b5b8",
      base06: "#d5d3d5",
      base07: "#ffffff",
      base08: "#dd464c",
      base09: "#fd8b19",
      base0A: "#fdcc59",
      base0B: "#8fc13e",
      base0C: "#149b93",
      base0D: "#1290bf",
      base0E: "#c85e7c",
      base0F: "#b33508"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/isotope.js
var require_isotope = __commonJS({
  "node_modules/base16/lib/isotope.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "isotope",
      author: "jan t. sott",
      base00: "#000000",
      base01: "#404040",
      base02: "#606060",
      base03: "#808080",
      base04: "#c0c0c0",
      base05: "#d0d0d0",
      base06: "#e0e0e0",
      base07: "#ffffff",
      base08: "#ff0000",
      base09: "#ff9900",
      base0A: "#ff0099",
      base0B: "#33ff00",
      base0C: "#00ffff",
      base0D: "#0066ff",
      base0E: "#cc00ff",
      base0F: "#3300ff"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/marrakesh.js
var require_marrakesh = __commonJS({
  "node_modules/base16/lib/marrakesh.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "marrakesh",
      author: "alexandre gavioli (http://github.com/alexx2/)",
      base00: "#201602",
      base01: "#302e00",
      base02: "#5f5b17",
      base03: "#6c6823",
      base04: "#86813b",
      base05: "#948e48",
      base06: "#ccc37a",
      base07: "#faf0a5",
      base08: "#c35359",
      base09: "#b36144",
      base0A: "#a88339",
      base0B: "#18974e",
      base0C: "#75a738",
      base0D: "#477ca1",
      base0E: "#8868b3",
      base0F: "#b3588e"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/mocha.js
var require_mocha = __commonJS({
  "node_modules/base16/lib/mocha.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "mocha",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#3B3228",
      base01: "#534636",
      base02: "#645240",
      base03: "#7e705a",
      base04: "#b8afad",
      base05: "#d0c8c6",
      base06: "#e9e1dd",
      base07: "#f5eeeb",
      base08: "#cb6077",
      base09: "#d28b71",
      base0A: "#f4bc87",
      base0B: "#beb55b",
      base0C: "#7bbda4",
      base0D: "#8ab3b5",
      base0E: "#a89bb9",
      base0F: "#bb9584"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/monokai.js
var require_monokai = __commonJS({
  "node_modules/base16/lib/monokai.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "monokai",
      author: "wimer hazenberg (http://www.monokai.nl)",
      base00: "#272822",
      base01: "#383830",
      base02: "#49483e",
      base03: "#75715e",
      base04: "#a59f85",
      base05: "#f8f8f2",
      base06: "#f5f4f1",
      base07: "#f9f8f5",
      base08: "#f92672",
      base09: "#fd971f",
      base0A: "#f4bf75",
      base0B: "#a6e22e",
      base0C: "#a1efe4",
      base0D: "#66d9ef",
      base0E: "#ae81ff",
      base0F: "#cc6633"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/ocean.js
var require_ocean = __commonJS({
  "node_modules/base16/lib/ocean.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "ocean",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#2b303b",
      base01: "#343d46",
      base02: "#4f5b66",
      base03: "#65737e",
      base04: "#a7adba",
      base05: "#c0c5ce",
      base06: "#dfe1e8",
      base07: "#eff1f5",
      base08: "#bf616a",
      base09: "#d08770",
      base0A: "#ebcb8b",
      base0B: "#a3be8c",
      base0C: "#96b5b4",
      base0D: "#8fa1b3",
      base0E: "#b48ead",
      base0F: "#ab7967"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/paraiso.js
var require_paraiso = __commonJS({
  "node_modules/base16/lib/paraiso.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "paraiso",
      author: "jan t. sott",
      base00: "#2f1e2e",
      base01: "#41323f",
      base02: "#4f424c",
      base03: "#776e71",
      base04: "#8d8687",
      base05: "#a39e9b",
      base06: "#b9b6b0",
      base07: "#e7e9db",
      base08: "#ef6155",
      base09: "#f99b15",
      base0A: "#fec418",
      base0B: "#48b685",
      base0C: "#5bc4bf",
      base0D: "#06b6ef",
      base0E: "#815ba4",
      base0F: "#e96ba8"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/pop.js
var require_pop = __commonJS({
  "node_modules/base16/lib/pop.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "pop",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#000000",
      base01: "#202020",
      base02: "#303030",
      base03: "#505050",
      base04: "#b0b0b0",
      base05: "#d0d0d0",
      base06: "#e0e0e0",
      base07: "#ffffff",
      base08: "#eb008a",
      base09: "#f29333",
      base0A: "#f8ca12",
      base0B: "#37b349",
      base0C: "#00aabb",
      base0D: "#0e5a94",
      base0E: "#b31e8d",
      base0F: "#7a2d00"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/railscasts.js
var require_railscasts = __commonJS({
  "node_modules/base16/lib/railscasts.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "railscasts",
      author: "ryan bates (http://railscasts.com)",
      base00: "#2b2b2b",
      base01: "#272935",
      base02: "#3a4055",
      base03: "#5a647e",
      base04: "#d4cfc9",
      base05: "#e6e1dc",
      base06: "#f4f1ed",
      base07: "#f9f7f3",
      base08: "#da4939",
      base09: "#cc7833",
      base0A: "#ffc66d",
      base0B: "#a5c261",
      base0C: "#519f50",
      base0D: "#6d9cbe",
      base0E: "#b6b3eb",
      base0F: "#bc9458"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/shapeshifter.js
var require_shapeshifter = __commonJS({
  "node_modules/base16/lib/shapeshifter.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "shapeshifter",
      author: "tyler benziger (http://tybenz.com)",
      base00: "#000000",
      base01: "#040404",
      base02: "#102015",
      base03: "#343434",
      base04: "#555555",
      base05: "#ababab",
      base06: "#e0e0e0",
      base07: "#f9f9f9",
      base08: "#e92f2f",
      base09: "#e09448",
      base0A: "#dddd13",
      base0B: "#0ed839",
      base0C: "#23edda",
      base0D: "#3b48e3",
      base0E: "#f996e2",
      base0F: "#69542d"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/solarized.js
var require_solarized = __commonJS({
  "node_modules/base16/lib/solarized.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "solarized",
      author: "ethan schoonover (http://ethanschoonover.com/solarized)",
      base00: "#002b36",
      base01: "#073642",
      base02: "#586e75",
      base03: "#657b83",
      base04: "#839496",
      base05: "#93a1a1",
      base06: "#eee8d5",
      base07: "#fdf6e3",
      base08: "#dc322f",
      base09: "#cb4b16",
      base0A: "#b58900",
      base0B: "#859900",
      base0C: "#2aa198",
      base0D: "#268bd2",
      base0E: "#6c71c4",
      base0F: "#d33682"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/summerfruit.js
var require_summerfruit = __commonJS({
  "node_modules/base16/lib/summerfruit.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "summerfruit",
      author: "christopher corley (http://cscorley.github.io/)",
      base00: "#151515",
      base01: "#202020",
      base02: "#303030",
      base03: "#505050",
      base04: "#B0B0B0",
      base05: "#D0D0D0",
      base06: "#E0E0E0",
      base07: "#FFFFFF",
      base08: "#FF0086",
      base09: "#FD8900",
      base0A: "#ABA800",
      base0B: "#00C918",
      base0C: "#1faaaa",
      base0D: "#3777E6",
      base0E: "#AD00A1",
      base0F: "#cc6633"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/tomorrow.js
var require_tomorrow = __commonJS({
  "node_modules/base16/lib/tomorrow.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "tomorrow",
      author: "chris kempson (http://chriskempson.com)",
      base00: "#1d1f21",
      base01: "#282a2e",
      base02: "#373b41",
      base03: "#969896",
      base04: "#b4b7b4",
      base05: "#c5c8c6",
      base06: "#e0e0e0",
      base07: "#ffffff",
      base08: "#cc6666",
      base09: "#de935f",
      base0A: "#f0c674",
      base0B: "#b5bd68",
      base0C: "#8abeb7",
      base0D: "#81a2be",
      base0E: "#b294bb",
      base0F: "#a3685a"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/tube.js
var require_tube = __commonJS({
  "node_modules/base16/lib/tube.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "london tube",
      author: "jan t. sott",
      base00: "#231f20",
      base01: "#1c3f95",
      base02: "#5a5758",
      base03: "#737171",
      base04: "#959ca1",
      base05: "#d9d8d8",
      base06: "#e7e7e8",
      base07: "#ffffff",
      base08: "#ee2e24",
      base09: "#f386a1",
      base0A: "#ffd204",
      base0B: "#00853e",
      base0C: "#85cebc",
      base0D: "#009ddc",
      base0E: "#98005d",
      base0F: "#b06110"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/twilight.js
var require_twilight = __commonJS({
  "node_modules/base16/lib/twilight.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = {
      scheme: "twilight",
      author: "david hart (http://hart-dev.com)",
      base00: "#1e1e1e",
      base01: "#323537",
      base02: "#464b50",
      base03: "#5f5a60",
      base04: "#838184",
      base05: "#a7a7a7",
      base06: "#c3c3c3",
      base07: "#ffffff",
      base08: "#cf6a4c",
      base09: "#cda869",
      base0A: "#f9ee98",
      base0B: "#8f9d6a",
      base0C: "#afc4db",
      base0D: "#7587a6",
      base0E: "#9b859d",
      base0F: "#9b703f"
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/base16/lib/index.js
var require_lib = __commonJS({
  "node_modules/base16/lib/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    function _interopRequire(obj) {
      return obj && obj.__esModule ? obj["default"] : obj;
    }
    var _threezerotwofour = require_threezerotwofour();
    exports2.threezerotwofour = _interopRequire(_threezerotwofour);
    var _apathy = require_apathy();
    exports2.apathy = _interopRequire(_apathy);
    var _ashes = require_ashes();
    exports2.ashes = _interopRequire(_ashes);
    var _atelierDune = require_atelier_dune();
    exports2.atelierDune = _interopRequire(_atelierDune);
    var _atelierForest = require_atelier_forest();
    exports2.atelierForest = _interopRequire(_atelierForest);
    var _atelierHeath = require_atelier_heath();
    exports2.atelierHeath = _interopRequire(_atelierHeath);
    var _atelierLakeside = require_atelier_lakeside();
    exports2.atelierLakeside = _interopRequire(_atelierLakeside);
    var _atelierSeaside = require_atelier_seaside();
    exports2.atelierSeaside = _interopRequire(_atelierSeaside);
    var _bespin = require_bespin();
    exports2.bespin = _interopRequire(_bespin);
    var _brewer = require_brewer();
    exports2.brewer = _interopRequire(_brewer);
    var _bright = require_bright();
    exports2.bright = _interopRequire(_bright);
    var _chalk = require_chalk();
    exports2.chalk = _interopRequire(_chalk);
    var _codeschool = require_codeschool();
    exports2.codeschool = _interopRequire(_codeschool);
    var _colors = require_colors();
    exports2.colors = _interopRequire(_colors);
    var _default = require_default();
    exports2["default"] = _interopRequire(_default);
    var _eighties = require_eighties();
    exports2.eighties = _interopRequire(_eighties);
    var _embers = require_embers();
    exports2.embers = _interopRequire(_embers);
    var _flat = require_flat();
    exports2.flat = _interopRequire(_flat);
    var _google = require_google();
    exports2.google = _interopRequire(_google);
    var _grayscale = require_grayscale();
    exports2.grayscale = _interopRequire(_grayscale);
    var _greenscreen = require_greenscreen();
    exports2.greenscreen = _interopRequire(_greenscreen);
    var _harmonic = require_harmonic();
    exports2.harmonic = _interopRequire(_harmonic);
    var _hopscotch = require_hopscotch();
    exports2.hopscotch = _interopRequire(_hopscotch);
    var _isotope = require_isotope();
    exports2.isotope = _interopRequire(_isotope);
    var _marrakesh = require_marrakesh();
    exports2.marrakesh = _interopRequire(_marrakesh);
    var _mocha = require_mocha();
    exports2.mocha = _interopRequire(_mocha);
    var _monokai = require_monokai();
    exports2.monokai = _interopRequire(_monokai);
    var _ocean = require_ocean();
    exports2.ocean = _interopRequire(_ocean);
    var _paraiso = require_paraiso();
    exports2.paraiso = _interopRequire(_paraiso);
    var _pop = require_pop();
    exports2.pop = _interopRequire(_pop);
    var _railscasts = require_railscasts();
    exports2.railscasts = _interopRequire(_railscasts);
    var _shapeshifter = require_shapeshifter();
    exports2.shapeshifter = _interopRequire(_shapeshifter);
    var _solarized = require_solarized();
    exports2.solarized = _interopRequire(_solarized);
    var _summerfruit = require_summerfruit();
    exports2.summerfruit = _interopRequire(_summerfruit);
    var _tomorrow = require_tomorrow();
    exports2.tomorrow = _interopRequire(_tomorrow);
    var _tube = require_tube();
    exports2.tube = _interopRequire(_tube);
    var _twilight = require_twilight();
    exports2.twilight = _interopRequire(_twilight);
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/simple-swizzle/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/simple-swizzle/node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice2 = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args2) {
      var results = [];
      for (var i4 = 0, len = args2.length; i4 < len; i4++) {
        var arg = args2[i4];
        if (isArrayish(arg)) {
          results = concat.call(results, slice2.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn2) {
      return function() {
        return fn2(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty2 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty2.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix2 = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix2) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match2;
      var i4;
      var hexAlpha;
      if (match2 = string.match(hex)) {
        hexAlpha = match2[2];
        match2 = match2[1];
        for (i4 = 0; i4 < 3; i4++) {
          var i22 = i4 * 2;
          rgb[i4] = parseInt(match2.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(abbr)) {
        match2 = match2[1];
        hexAlpha = match2[3];
        for (i4 = 0; i4 < 3; i4++) {
          rgb[i4] = parseInt(match2[i4] + match2[i4], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(rgba)) {
        for (i4 = 0; i4 < 3; i4++) {
          rgb[i4] = parseInt(match2[i4 + 1], 0);
        }
        if (match2[4]) {
          if (match2[5]) {
            rgb[3] = parseFloat(match2[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match2[4]);
          }
        }
      } else if (match2 = string.match(per)) {
        for (i4 = 0; i4 < 3; i4++) {
          rgb[i4] = Math.round(parseFloat(match2[i4 + 1]) * 2.55);
        }
        if (match2[4]) {
          if (match2[5]) {
            rgb[3] = parseFloat(match2[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match2[4]);
          }
        }
      } else if (match2 = string.match(keyword)) {
        if (match2[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty2.call(colorNames, match2[1])) {
          return null;
        }
        rgb = colorNames[match2[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i4 = 0; i4 < 3; i4++) {
        rgb[i4] = clamp(rgb[i4], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match2 = string.match(hsl);
      if (match2) {
        var alpha = parseFloat(match2[4]);
        var h4 = (parseFloat(match2[1]) % 360 + 360) % 360;
        var s5 = clamp(parseFloat(match2[2]), 0, 100);
        var l4 = clamp(parseFloat(match2[3]), 0, 100);
        var a3 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h4, s5, l4, a3];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match2 = string.match(hwb);
      if (match2) {
        var alpha = parseFloat(match2[4]);
        var h4 = (parseFloat(match2[1]) % 360 + 360) % 360;
        var w6 = clamp(parseFloat(match2[2]), 0, 100);
        var b4 = clamp(parseFloat(match2[3]), 0, 100);
        var a3 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h4, w6, b4, a3];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r5 = Math.round(rgba[0] / 255 * 100);
      var g5 = Math.round(rgba[1] / 255 * 100);
      var b4 = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r5 + "%, " + g5 + "%, " + b4 + "%)" : "rgba(" + r5 + "%, " + g5 + "%, " + b4 + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a3 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a3 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a3 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color-convert/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color-convert/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r5 = rgb[0] / 255;
      var g5 = rgb[1] / 255;
      var b4 = rgb[2] / 255;
      var min = Math.min(r5, g5, b4);
      var max = Math.max(r5, g5, b4);
      var delta = max - min;
      var h4;
      var s5;
      var l4;
      if (max === min) {
        h4 = 0;
      } else if (r5 === max) {
        h4 = (g5 - b4) / delta;
      } else if (g5 === max) {
        h4 = 2 + (b4 - r5) / delta;
      } else if (b4 === max) {
        h4 = 4 + (r5 - g5) / delta;
      }
      h4 = Math.min(h4 * 60, 360);
      if (h4 < 0) {
        h4 += 360;
      }
      l4 = (min + max) / 2;
      if (max === min) {
        s5 = 0;
      } else if (l4 <= 0.5) {
        s5 = delta / (max + min);
      } else {
        s5 = delta / (2 - max - min);
      }
      return [h4, s5 * 100, l4 * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h4;
      var s5;
      var r5 = rgb[0] / 255;
      var g5 = rgb[1] / 255;
      var b4 = rgb[2] / 255;
      var v4 = Math.max(r5, g5, b4);
      var diff = v4 - Math.min(r5, g5, b4);
      var diffc = function(c4) {
        return (v4 - c4) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h4 = s5 = 0;
      } else {
        s5 = diff / v4;
        rdif = diffc(r5);
        gdif = diffc(g5);
        bdif = diffc(b4);
        if (r5 === v4) {
          h4 = bdif - gdif;
        } else if (g5 === v4) {
          h4 = 1 / 3 + rdif - bdif;
        } else if (b4 === v4) {
          h4 = 2 / 3 + gdif - rdif;
        }
        if (h4 < 0) {
          h4 += 1;
        } else if (h4 > 1) {
          h4 -= 1;
        }
      }
      return [
        h4 * 360,
        s5 * 100,
        v4 * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r5 = rgb[0];
      var g5 = rgb[1];
      var b4 = rgb[2];
      var h4 = convert.rgb.hsl(rgb)[0];
      var w6 = 1 / 255 * Math.min(r5, Math.min(g5, b4));
      b4 = 1 - 1 / 255 * Math.max(r5, Math.max(g5, b4));
      return [h4, w6 * 100, b4 * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r5 = rgb[0] / 255;
      var g5 = rgb[1] / 255;
      var b4 = rgb[2] / 255;
      var c4;
      var m4;
      var y4;
      var k4;
      k4 = Math.min(1 - r5, 1 - g5, 1 - b4);
      c4 = (1 - r5 - k4) / (1 - k4) || 0;
      m4 = (1 - g5 - k4) / (1 - k4) || 0;
      y4 = (1 - b4 - k4) / (1 - k4) || 0;
      return [c4 * 100, m4 * 100, y4 * 100, k4 * 100];
    };
    function comparativeDistance(x5, y4) {
      return Math.pow(x5[0] - y4[0], 2) + Math.pow(x5[1] - y4[1], 2) + Math.pow(x5[2] - y4[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r5 = rgb[0] / 255;
      var g5 = rgb[1] / 255;
      var b4 = rgb[2] / 255;
      r5 = r5 > 0.04045 ? Math.pow((r5 + 0.055) / 1.055, 2.4) : r5 / 12.92;
      g5 = g5 > 0.04045 ? Math.pow((g5 + 0.055) / 1.055, 2.4) : g5 / 12.92;
      b4 = b4 > 0.04045 ? Math.pow((b4 + 0.055) / 1.055, 2.4) : b4 / 12.92;
      var x5 = r5 * 0.4124 + g5 * 0.3576 + b4 * 0.1805;
      var y4 = r5 * 0.2126 + g5 * 0.7152 + b4 * 0.0722;
      var z4 = r5 * 0.0193 + g5 * 0.1192 + b4 * 0.9505;
      return [x5 * 100, y4 * 100, z4 * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x5 = xyz[0];
      var y4 = xyz[1];
      var z4 = xyz[2];
      var l4;
      var a3;
      var b4;
      x5 /= 95.047;
      y4 /= 100;
      z4 /= 108.883;
      x5 = x5 > 8856e-6 ? Math.pow(x5, 1 / 3) : 7.787 * x5 + 16 / 116;
      y4 = y4 > 8856e-6 ? Math.pow(y4, 1 / 3) : 7.787 * y4 + 16 / 116;
      z4 = z4 > 8856e-6 ? Math.pow(z4, 1 / 3) : 7.787 * z4 + 16 / 116;
      l4 = 116 * y4 - 16;
      a3 = 500 * (x5 - y4);
      b4 = 200 * (y4 - z4);
      return [l4, a3, b4];
    };
    convert.hsl.rgb = function(hsl) {
      var h4 = hsl[0] / 360;
      var s5 = hsl[1] / 100;
      var l4 = hsl[2] / 100;
      var t1;
      var t22;
      var t3;
      var rgb;
      var val;
      if (s5 === 0) {
        val = l4 * 255;
        return [val, val, val];
      }
      if (l4 < 0.5) {
        t22 = l4 * (1 + s5);
      } else {
        t22 = l4 + s5 - l4 * s5;
      }
      t1 = 2 * l4 - t22;
      rgb = [0, 0, 0];
      for (var i4 = 0; i4 < 3; i4++) {
        t3 = h4 + 1 / 3 * -(i4 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t22 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t22;
        } else if (3 * t3 < 2) {
          val = t1 + (t22 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i4] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h4 = hsl[0];
      var s5 = hsl[1] / 100;
      var l4 = hsl[2] / 100;
      var smin = s5;
      var lmin = Math.max(l4, 0.01);
      var sv;
      var v4;
      l4 *= 2;
      s5 *= l4 <= 1 ? l4 : 2 - l4;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v4 = (l4 + s5) / 2;
      sv = l4 === 0 ? 2 * smin / (lmin + smin) : 2 * s5 / (l4 + s5);
      return [h4, sv * 100, v4 * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h4 = hsv[0] / 60;
      var s5 = hsv[1] / 100;
      var v4 = hsv[2] / 100;
      var hi = Math.floor(h4) % 6;
      var f4 = h4 - Math.floor(h4);
      var p5 = 255 * v4 * (1 - s5);
      var q4 = 255 * v4 * (1 - s5 * f4);
      var t3 = 255 * v4 * (1 - s5 * (1 - f4));
      v4 *= 255;
      switch (hi) {
        case 0:
          return [v4, t3, p5];
        case 1:
          return [q4, v4, p5];
        case 2:
          return [p5, v4, t3];
        case 3:
          return [p5, q4, v4];
        case 4:
          return [t3, p5, v4];
        case 5:
          return [v4, p5, q4];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h4 = hsv[0];
      var s5 = hsv[1] / 100;
      var v4 = hsv[2] / 100;
      var vmin = Math.max(v4, 0.01);
      var lmin;
      var sl;
      var l4;
      l4 = (2 - s5) * v4;
      lmin = (2 - s5) * vmin;
      sl = s5 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l4 /= 2;
      return [h4, sl * 100, l4 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h4 = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i4;
      var v4;
      var f4;
      var n3;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i4 = Math.floor(6 * h4);
      v4 = 1 - bl;
      f4 = 6 * h4 - i4;
      if ((i4 & 1) !== 0) {
        f4 = 1 - f4;
      }
      n3 = wh + f4 * (v4 - wh);
      var r5;
      var g5;
      var b4;
      switch (i4) {
        default:
        case 6:
        case 0:
          r5 = v4;
          g5 = n3;
          b4 = wh;
          break;
        case 1:
          r5 = n3;
          g5 = v4;
          b4 = wh;
          break;
        case 2:
          r5 = wh;
          g5 = v4;
          b4 = n3;
          break;
        case 3:
          r5 = wh;
          g5 = n3;
          b4 = v4;
          break;
        case 4:
          r5 = n3;
          g5 = wh;
          b4 = v4;
          break;
        case 5:
          r5 = v4;
          g5 = wh;
          b4 = n3;
          break;
      }
      return [r5 * 255, g5 * 255, b4 * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c4 = cmyk[0] / 100;
      var m4 = cmyk[1] / 100;
      var y4 = cmyk[2] / 100;
      var k4 = cmyk[3] / 100;
      var r5;
      var g5;
      var b4;
      r5 = 1 - Math.min(1, c4 * (1 - k4) + k4);
      g5 = 1 - Math.min(1, m4 * (1 - k4) + k4);
      b4 = 1 - Math.min(1, y4 * (1 - k4) + k4);
      return [r5 * 255, g5 * 255, b4 * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x5 = xyz[0] / 100;
      var y4 = xyz[1] / 100;
      var z4 = xyz[2] / 100;
      var r5;
      var g5;
      var b4;
      r5 = x5 * 3.2406 + y4 * -1.5372 + z4 * -0.4986;
      g5 = x5 * -0.9689 + y4 * 1.8758 + z4 * 0.0415;
      b4 = x5 * 0.0557 + y4 * -0.204 + z4 * 1.057;
      r5 = r5 > 31308e-7 ? 1.055 * Math.pow(r5, 1 / 2.4) - 0.055 : r5 * 12.92;
      g5 = g5 > 31308e-7 ? 1.055 * Math.pow(g5, 1 / 2.4) - 0.055 : g5 * 12.92;
      b4 = b4 > 31308e-7 ? 1.055 * Math.pow(b4, 1 / 2.4) - 0.055 : b4 * 12.92;
      r5 = Math.min(Math.max(0, r5), 1);
      g5 = Math.min(Math.max(0, g5), 1);
      b4 = Math.min(Math.max(0, b4), 1);
      return [r5 * 255, g5 * 255, b4 * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x5 = xyz[0];
      var y4 = xyz[1];
      var z4 = xyz[2];
      var l4;
      var a3;
      var b4;
      x5 /= 95.047;
      y4 /= 100;
      z4 /= 108.883;
      x5 = x5 > 8856e-6 ? Math.pow(x5, 1 / 3) : 7.787 * x5 + 16 / 116;
      y4 = y4 > 8856e-6 ? Math.pow(y4, 1 / 3) : 7.787 * y4 + 16 / 116;
      z4 = z4 > 8856e-6 ? Math.pow(z4, 1 / 3) : 7.787 * z4 + 16 / 116;
      l4 = 116 * y4 - 16;
      a3 = 500 * (x5 - y4);
      b4 = 200 * (y4 - z4);
      return [l4, a3, b4];
    };
    convert.lab.xyz = function(lab) {
      var l4 = lab[0];
      var a3 = lab[1];
      var b4 = lab[2];
      var x5;
      var y4;
      var z4;
      y4 = (l4 + 16) / 116;
      x5 = a3 / 500 + y4;
      z4 = y4 - b4 / 200;
      var y22 = Math.pow(y4, 3);
      var x22 = Math.pow(x5, 3);
      var z22 = Math.pow(z4, 3);
      y4 = y22 > 8856e-6 ? y22 : (y4 - 16 / 116) / 7.787;
      x5 = x22 > 8856e-6 ? x22 : (x5 - 16 / 116) / 7.787;
      z4 = z22 > 8856e-6 ? z22 : (z4 - 16 / 116) / 7.787;
      x5 *= 95.047;
      y4 *= 100;
      z4 *= 108.883;
      return [x5, y4, z4];
    };
    convert.lab.lch = function(lab) {
      var l4 = lab[0];
      var a3 = lab[1];
      var b4 = lab[2];
      var hr;
      var h4;
      var c4;
      hr = Math.atan2(b4, a3);
      h4 = hr * 360 / 2 / Math.PI;
      if (h4 < 0) {
        h4 += 360;
      }
      c4 = Math.sqrt(a3 * a3 + b4 * b4);
      return [l4, c4, h4];
    };
    convert.lch.lab = function(lch) {
      var l4 = lch[0];
      var c4 = lch[1];
      var h4 = lch[2];
      var a3;
      var b4;
      var hr;
      hr = h4 / 360 * 2 * Math.PI;
      a3 = c4 * Math.cos(hr);
      b4 = c4 * Math.sin(hr);
      return [l4, a3, b4];
    };
    convert.rgb.ansi16 = function(args2) {
      var r5 = args2[0];
      var g5 = args2[1];
      var b4 = args2[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args2)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b4 / 255) << 2 | Math.round(g5 / 255) << 1 | Math.round(r5 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args2) {
      return convert.rgb.ansi16(convert.hsv.rgb(args2), args2[2]);
    };
    convert.rgb.ansi256 = function(args2) {
      var r5 = args2[0];
      var g5 = args2[1];
      var b4 = args2[2];
      if (r5 === g5 && g5 === b4) {
        if (r5 < 8) {
          return 16;
        }
        if (r5 > 248) {
          return 231;
        }
        return Math.round((r5 - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r5 / 255 * 5) + 6 * Math.round(g5 / 255 * 5) + Math.round(b4 / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args2) {
      var color = args2 % 10;
      if (color === 0 || color === 7) {
        if (args2 > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args2 > 50) + 1) * 0.5;
      var r5 = (color & 1) * mult * 255;
      var g5 = (color >> 1 & 1) * mult * 255;
      var b4 = (color >> 2 & 1) * mult * 255;
      return [r5, g5, b4];
    };
    convert.ansi256.rgb = function(args2) {
      if (args2 >= 232) {
        var c4 = (args2 - 232) * 10 + 8;
        return [c4, c4, c4];
      }
      args2 -= 16;
      var rem;
      var r5 = Math.floor(args2 / 36) / 5 * 255;
      var g5 = Math.floor((rem = args2 % 36) / 6) / 5 * 255;
      var b4 = rem % 6 / 5 * 255;
      return [r5, g5, b4];
    };
    convert.rgb.hex = function(args2) {
      var integer = ((Math.round(args2[0]) & 255) << 16) + ((Math.round(args2[1]) & 255) << 8) + (Math.round(args2[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args2) {
      var match2 = args2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2) {
        return [0, 0, 0];
      }
      var colorString = match2[0];
      if (match2[0].length === 3) {
        colorString = colorString.split("").map(function(char2) {
          return char2 + char2;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r5 = integer >> 16 & 255;
      var g5 = integer >> 8 & 255;
      var b4 = integer & 255;
      return [r5, g5, b4];
    };
    convert.rgb.hcg = function(rgb) {
      var r5 = rgb[0] / 255;
      var g5 = rgb[1] / 255;
      var b4 = rgb[2] / 255;
      var max = Math.max(Math.max(r5, g5), b4);
      var min = Math.min(Math.min(r5, g5), b4);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r5) {
        hue = (g5 - b4) / chroma % 6;
      } else if (max === g5) {
        hue = 2 + (b4 - r5) / chroma;
      } else {
        hue = 4 + (r5 - g5) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s5 = hsl[1] / 100;
      var l4 = hsl[2] / 100;
      var c4 = 1;
      var f4 = 0;
      if (l4 < 0.5) {
        c4 = 2 * s5 * l4;
      } else {
        c4 = 2 * s5 * (1 - l4);
      }
      if (c4 < 1) {
        f4 = (l4 - 0.5 * c4) / (1 - c4);
      }
      return [hsl[0], c4 * 100, f4 * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s5 = hsv[1] / 100;
      var v4 = hsv[2] / 100;
      var c4 = s5 * v4;
      var f4 = 0;
      if (c4 < 1) {
        f4 = (v4 - c4) / (1 - c4);
      }
      return [hsv[0], c4 * 100, f4 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h4 = hcg[0] / 360;
      var c4 = hcg[1] / 100;
      var g5 = hcg[2] / 100;
      if (c4 === 0) {
        return [g5 * 255, g5 * 255, g5 * 255];
      }
      var pure = [0, 0, 0];
      var hi = h4 % 1 * 6;
      var v4 = hi % 1;
      var w6 = 1 - v4;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v4;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w6;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v4;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w6;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v4;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w6;
      }
      mg = (1 - c4) * g5;
      return [
        (c4 * pure[0] + mg) * 255,
        (c4 * pure[1] + mg) * 255,
        (c4 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c4 = hcg[1] / 100;
      var g5 = hcg[2] / 100;
      var v4 = c4 + g5 * (1 - c4);
      var f4 = 0;
      if (v4 > 0) {
        f4 = c4 / v4;
      }
      return [hcg[0], f4 * 100, v4 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c4 = hcg[1] / 100;
      var g5 = hcg[2] / 100;
      var l4 = g5 * (1 - c4) + 0.5 * c4;
      var s5 = 0;
      if (l4 > 0 && l4 < 0.5) {
        s5 = c4 / (2 * l4);
      } else if (l4 >= 0.5 && l4 < 1) {
        s5 = c4 / (2 * (1 - l4));
      }
      return [hcg[0], s5 * 100, l4 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c4 = hcg[1] / 100;
      var g5 = hcg[2] / 100;
      var v4 = c4 + g5 * (1 - c4);
      return [hcg[0], (v4 - c4) * 100, (1 - v4) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w6 = hwb[1] / 100;
      var b4 = hwb[2] / 100;
      var v4 = 1 - b4;
      var c4 = v4 - w6;
      var g5 = 0;
      if (c4 < 1) {
        g5 = (v4 - c4) / (1 - c4);
      }
      return [hwb[0], c4 * 100, g5 * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args2) {
      return [args2[0] / 100 * 255, args2[0] / 100 * 255, args2[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args2) {
      return [0, 0, args2[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i4 = 0; i4 < len; i4++) {
        graph[models[i4]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i4 = 0; i4 < len; i4++) {
          var adjacent = adjacents[i4];
          var node2 = graph[adjacent];
          if (node2.distance === -1) {
            node2.distance = graph[current].distance + 1;
            node2.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from2, to) {
      return function(args2) {
        return to(from2(args2));
      };
    }
    function wrapConversion(toModel, graph) {
      var path8 = [graph[toModel].parent, toModel];
      var fn2 = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path8.unshift(graph[cur].parent);
        fn2 = link(conversions[graph[cur].parent][cur], fn2);
        cur = graph[cur].parent;
      }
      fn2.conversion = path8;
      return fn2;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i4 = 0; i4 < len; i4++) {
        var toModel = models[i4];
        var node2 = graph[toModel];
        if (node2.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn2) {
      var wrappedFn = function(args2) {
        if (args2 === void 0 || args2 === null) {
          return args2;
        }
        if (arguments.length > 1) {
          args2 = Array.prototype.slice.call(arguments);
        }
        return fn2(args2);
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn2) {
      var wrappedFn = function(args2) {
        if (args2 === void 0 || args2 === null) {
          return args2;
        }
        if (arguments.length > 1) {
          args2 = Array.prototype.slice.call(arguments);
        }
        var result = fn2(args2);
        if (typeof result === "object") {
          for (var len = result.length, i4 = 0; i4 < len; i4++) {
            result[i4] = Math.round(result[i4]);
          }
        }
        return result;
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn2 = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn2);
        convert[fromModel][toModel].raw = wrapRaw(fn2);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports2, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color2(obj, model) {
      if (!(this instanceof Color2)) {
        return new Color2(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i4;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color2) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys = Object.keys(obj);
        if ("alpha" in obj) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color = [];
        for (i4 = 0; i4 < labels.length; i4++) {
          color.push(obj[labels[i4]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i4 = 0; i4 < channels; i4++) {
          var limit = limiters[this.model][i4];
          if (limit) {
            this.color[i4] = limit(this.color[i4]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color2.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args2 = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args2);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args2 = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args2);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i4 = 0; i4 < channels; i4++) {
          result[labels[i4]] = this.color[i4];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color2(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color2(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color2(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color2(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i4 = 0; i4 < rgb.length; i4++) {
          var chan = rgb[i4] / 255;
          lum[i4] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i4 = 0; i4 < 3; i4++) {
          rgb.color[i4] = 255 - rgb.color[i4];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color2.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p5 = weight === void 0 ? 0.5 : weight;
        var w6 = 2 * p5 - 1;
        var a3 = color1.alpha() - color2.alpha();
        var w1 = ((w6 * a3 === -1 ? w6 : (w6 + a3) / (1 + w6 * a3)) + 1) / 2;
        var w22 = 1 - w1;
        return Color2.rgb(
          w1 * color1.red() + w22 * color2.red(),
          w1 * color1.green() + w22 * color2.green(),
          w1 * color1.blue() + w22 * color2.blue(),
          color1.alpha() * p5 + color2.alpha() * (1 - p5)
        );
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color2.prototype[model] = function() {
        if (this.model === model) {
          return new Color2(this);
        }
        if (arguments.length) {
          return new Color2(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color2(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color2[model] = function(color) {
        if (typeof color === "number") {
          color = zeroArray(_slice.call(arguments), channels);
        }
        return new Color2(color, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m4) {
        (limiters[m4] || (limiters[m4] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v4) {
        return Math.max(0, Math.min(max, v4));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length2) {
      for (var i4 = 0; i4 < length2; i4++) {
        if (typeof arr[i4] !== "number") {
          arr[i4] = 0;
        }
      }
      return arr;
    }
    module2.exports = Color2;
  }
});

// node_modules/lodash.curry/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.curry/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var PLACEHOLDER = "__lodash_placeholder__";
    var BIND_FLAG = 1;
    var BIND_KEY_FLAG = 2;
    var CURRY_BOUND_FLAG = 4;
    var CURRY_FLAG = 8;
    var CURRY_RIGHT_FLAG = 16;
    var PARTIAL_FLAG = 32;
    var PARTIAL_RIGHT_FLAG = 64;
    var ARY_FLAG = 128;
    var REARG_FLAG = 256;
    var FLIP_FLAG = 512;
    var INFINITY2 = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var wrapFlags = [
      ["ary", ARY_FLAG],
      ["bind", BIND_FLAG],
      ["bindKey", BIND_KEY_FLAG],
      ["curry", CURRY_FLAG],
      ["curryRight", CURRY_RIGHT_FLAG],
      ["flip", FLIP_FLAG],
      ["partial", PARTIAL_FLAG],
      ["partialRight", PARTIAL_RIGHT_FLAG],
      ["rearg", REARG_FLAG]
    ];
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reTrim = /^\s+|\s+$/g;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
    var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
    var reSplitDetails = /,? & /;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args2) {
      switch (args2.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args2[0]);
        case 2:
          return func.call(thisArg, args2[0], args2[1]);
        case 3:
          return func.call(thisArg, args2[0], args2[1], args2[2]);
      }
      return func.apply(thisArg, args2);
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length2 = array ? array.length : 0;
      while (++index2 < length2) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayIncludes(array, value) {
      var length2 = array ? array.length : 0;
      return !!length2 && baseIndexOf(array, value, 0) > -1;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index2 = fromIndex - 1, length2 = array.length;
      while (++index2 < length2) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function countHolders(array, placeholder) {
      var length2 = array.length, result = 0;
      while (length2--) {
        if (array[length2] === placeholder) {
          result++;
        }
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e3) {
        }
      }
      return result;
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length2 = array.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var objectCreate = Object.create;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var defineProperty = function() {
      var func = getNative(Object, "defineProperty"), name = getNative.name;
      return name && name.length > 2 ? func : void 0;
    }();
    function baseCreate(proto) {
      return isObject2(proto) ? objectCreate(proto) : {};
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function composeArgs(args2, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args2.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args2[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args2[argsIndex++];
      }
      return result;
    }
    function composeArgsRight(args2, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args2.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
      while (++argsIndex < rangeLength) {
        result[argsIndex] = args2[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args2[argsIndex++];
        }
      }
      return result;
    }
    function copyArray(source, array) {
      var index2 = -1, length2 = source.length;
      array || (array = Array(length2));
      while (++index2 < length2) {
        array[index2] = source[index2];
      }
      return array;
    }
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
      function wrapper() {
        var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
        return fn2.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }
    function createCtor(Ctor) {
      return function() {
        var args2 = arguments;
        switch (args2.length) {
          case 0:
            return new Ctor();
          case 1:
            return new Ctor(args2[0]);
          case 2:
            return new Ctor(args2[0], args2[1]);
          case 3:
            return new Ctor(args2[0], args2[1], args2[2]);
          case 4:
            return new Ctor(args2[0], args2[1], args2[2], args2[3]);
          case 5:
            return new Ctor(args2[0], args2[1], args2[2], args2[3], args2[4]);
          case 6:
            return new Ctor(args2[0], args2[1], args2[2], args2[3], args2[4], args2[5]);
          case 7:
            return new Ctor(args2[0], args2[1], args2[2], args2[3], args2[4], args2[5], args2[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args2);
        return isObject2(result) ? result : thisBinding;
      };
    }
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);
      function wrapper() {
        var length2 = arguments.length, args2 = Array(length2), index2 = length2, placeholder = getHolder(wrapper);
        while (index2--) {
          args2[index2] = arguments[index2];
        }
        var holders = length2 < 3 && args2[0] !== placeholder && args2[length2 - 1] !== placeholder ? [] : replaceHolders(args2, placeholder);
        length2 -= holders.length;
        if (length2 < arity) {
          return createRecurry(
            func,
            bitmask,
            createHybrid,
            wrapper.placeholder,
            void 0,
            args2,
            holders,
            void 0,
            void 0,
            arity - length2
          );
        }
        var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
        return apply(fn2, this, args2);
      }
      return wrapper;
    }
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor(func);
      function wrapper() {
        var length2 = arguments.length, args2 = Array(length2), index2 = length2;
        while (index2--) {
          args2[index2] = arguments[index2];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper), holdersCount = countHolders(args2, placeholder);
        }
        if (partials) {
          args2 = composeArgs(args2, partials, holders, isCurried);
        }
        if (partialsRight) {
          args2 = composeArgsRight(args2, partialsRight, holdersRight, isCurried);
        }
        length2 -= holdersCount;
        if (isCurried && length2 < arity) {
          var newHolders = replaceHolders(args2, placeholder);
          return createRecurry(
            func,
            bitmask,
            createHybrid,
            wrapper.placeholder,
            thisArg,
            args2,
            newHolders,
            argPos,
            ary,
            arity - length2
          );
        }
        var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
        length2 = args2.length;
        if (argPos) {
          args2 = reorder(args2, argPos);
        } else if (isFlip && length2 > 1) {
          args2.reverse();
        }
        if (isAry && ary < length2) {
          args2.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn2 = Ctor || createCtor(fn2);
        }
        return fn2.apply(thisBinding, args2);
      }
      return wrapper;
    }
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
      function wrapper() {
        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args2 = Array(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
        while (++leftIndex < leftLength) {
          args2[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args2[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn2, isBind ? thisArg : this, args2);
      }
      return wrapper;
    }
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
      bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
      bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
      if (!(bitmask & CURRY_BOUND_FLAG)) {
        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
      }
      var result = wrapFunc(func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity);
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length2 = partials ? partials.length : 0;
      if (!length2) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = void 0;
      }
      ary = ary === void 0 ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === void 0 ? arity : toInteger(arity);
      length2 -= holders ? holders.length : 0;
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials, holdersRight = holders;
        partials = holders = void 0;
      }
      var newData = [
        func,
        bitmask,
        thisArg,
        partials,
        holders,
        partialsRight,
        holdersRight,
        argPos,
        ary,
        arity
      ];
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
      if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(void 0, newData);
      }
      return setWrapToString(result, func, bitmask);
    }
    function getHolder(func) {
      var object = func;
      return object.placeholder;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getWrapDetails(source) {
      var match2 = source.match(reWrapDetails);
      return match2 ? match2[1].split(reSplitDetails) : [];
    }
    function insertWrapDetails(source, details) {
      var length2 = details.length, lastIndex = length2 - 1;
      details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
      details = details.join(length2 > 2 ? ", " : " ");
      return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
    }
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function reorder(array, indexes) {
      var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
      while (length2--) {
        var index2 = indexes[length2];
        array[length2] = isIndex(index2, arrLength) ? oldArray[index2] : void 0;
      }
      return array;
    }
    var setWrapToString = !defineProperty ? identity2 : function(wrapper, reference, bitmask) {
      var source = reference + "";
      return defineProperty(wrapper, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
      });
    };
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e3) {
        }
        try {
          return func + "";
        } catch (e3) {
        }
      }
      return "";
    }
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = "_." + pair[0];
        if (bitmask & pair[1] && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }
    function curry2(func, arity, guard) {
      arity = guard ? void 0 : arity;
      var result = createWrap(func, CURRY_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
      result.placeholder = curry2.placeholder;
      return result;
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY2 || value === -INFINITY2) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity2(value) {
      return value;
    }
    curry2.placeholder = {};
    module2.exports = curry2;
  }
});

// node_modules/execa/node_modules/get-stream/buffer-stream.js
var require_buffer_stream2 = __commonJS({
  "node_modules/execa/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options3) => {
      options3 = { ...options3 };
      const { array } = options3;
      let { encoding } = options3;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream2 = new PassThroughStream({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      let length2 = 0;
      const chunks = [];
      stream2.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length2 = chunks.length;
        } else {
          length2 += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length2) : chunks.join("");
      };
      stream2.getBufferedLength = () => length2;
      return stream2;
    };
  }
});

// node_modules/execa/node_modules/get-stream/index.js
var require_get_stream2 = __commonJS({
  "node_modules/execa/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var stream2 = require("stream");
    var { promisify } = require("util");
    var bufferStream = require_buffer_stream2();
    var streamPipelinePromisified = promisify(stream2.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream2(inputStream, options3) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options3 = {
        maxBuffer: Infinity,
        ...options3
      };
      const { maxBuffer } = options3;
      const stream3 = bufferStream(options3);
      await new Promise((resolve2, reject2) => {
        const rejectPromise = (error) => {
          if (error && stream3.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream3.getBufferedValue();
          }
          reject2(error);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream3);
            resolve2();
          } catch (error) {
            rejectPromise(error);
          }
        })();
        stream3.on("data", () => {
          if (stream3.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream3.getBufferedValue();
    }
    module2.exports = getStream2;
    module2.exports.buffer = (stream3, options3) => getStream2(stream3, { ...options3, encoding: "buffer" });
    module2.exports.array = (stream3, options3) => getStream2(stream3, { ...options3, array: true });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/nunjucks/browser/nunjucks.js
var require_nunjucks = __commonJS({
  "node_modules/nunjucks/browser/nunjucks.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports2 === "object")
        exports2["nunjucks"] = factory();
      else
        root["nunjucks"] = factory();
    })(typeof self !== "undefined" ? self : exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.l = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports3, name, getter) {
            if (!__webpack_require__.o(exports3, name)) {
              Object.defineProperty(exports3, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 11);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var ArrayProto = Array.prototype;
            var ObjProto = Object.prototype;
            var escapeMap = {
              "&": "&amp;",
              '"': "&quot;",
              "'": "&#39;",
              "<": "&lt;",
              ">": "&gt;",
              "\\": "&#92;"
            };
            var escapeRegex = /[&"'<>\\]/g;
            var exports3 = module3.exports = {};
            function hasOwnProp2(obj, k4) {
              return ObjProto.hasOwnProperty.call(obj, k4);
            }
            exports3.hasOwnProp = hasOwnProp2;
            function lookupEscape(ch) {
              return escapeMap[ch];
            }
            function _prettifyError(path8, withInternals, err) {
              if (!err.Update) {
                err = new exports3.TemplateError(err);
              }
              err.Update(path8);
              if (!withInternals) {
                var old = err;
                err = new Error(old.message);
                err.name = old.name;
              }
              return err;
            }
            exports3._prettifyError = _prettifyError;
            function TemplateError(message, lineno, colno) {
              var err;
              var cause;
              if (message instanceof Error) {
                cause = message;
                message = cause.name + ": " + cause.message;
              }
              if (Object.setPrototypeOf) {
                err = new Error(message);
                Object.setPrototypeOf(err, TemplateError.prototype);
              } else {
                err = this;
                Object.defineProperty(err, "message", {
                  enumerable: false,
                  writable: true,
                  value: message
                });
              }
              Object.defineProperty(err, "name", {
                value: "Template render error"
              });
              if (Error.captureStackTrace) {
                Error.captureStackTrace(err, this.constructor);
              }
              var getStack;
              if (cause) {
                var stackDescriptor = Object.getOwnPropertyDescriptor(cause, "stack");
                getStack = stackDescriptor && (stackDescriptor.get || function() {
                  return stackDescriptor.value;
                });
                if (!getStack) {
                  getStack = function getStack2() {
                    return cause.stack;
                  };
                }
              } else {
                var stack = new Error(message).stack;
                getStack = function getStack2() {
                  return stack;
                };
              }
              Object.defineProperty(err, "stack", {
                get: function get2() {
                  return getStack.call(err);
                }
              });
              Object.defineProperty(err, "cause", {
                value: cause
              });
              err.lineno = lineno;
              err.colno = colno;
              err.firstUpdate = true;
              err.Update = function Update(path8) {
                var msg = "(" + (path8 || "unknown path") + ")";
                if (this.firstUpdate) {
                  if (this.lineno && this.colno) {
                    msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
                  } else if (this.lineno) {
                    msg += " [Line " + this.lineno + "]";
                  }
                }
                msg += "\n ";
                if (this.firstUpdate) {
                  msg += " ";
                }
                this.message = msg + (this.message || "");
                this.firstUpdate = false;
                return this;
              };
              return err;
            }
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
            } else {
              TemplateError.prototype = Object.create(Error.prototype, {
                constructor: {
                  value: TemplateError
                }
              });
            }
            exports3.TemplateError = TemplateError;
            function escape(val) {
              return val.replace(escapeRegex, lookupEscape);
            }
            exports3.escape = escape;
            function isFunction(obj) {
              return ObjProto.toString.call(obj) === "[object Function]";
            }
            exports3.isFunction = isFunction;
            function isArray3(obj) {
              return ObjProto.toString.call(obj) === "[object Array]";
            }
            exports3.isArray = isArray3;
            function isString2(obj) {
              return ObjProto.toString.call(obj) === "[object String]";
            }
            exports3.isString = isString2;
            function isObject2(obj) {
              return ObjProto.toString.call(obj) === "[object Object]";
            }
            exports3.isObject = isObject2;
            function _prepareAttributeParts2(attr) {
              if (!attr) {
                return [];
              }
              if (typeof attr === "string") {
                return attr.split(".");
              }
              return [attr];
            }
            function getAttrGetter2(attribute) {
              var parts = _prepareAttributeParts2(attribute);
              return function attrGetter(item) {
                var _item = item;
                for (var i4 = 0; i4 < parts.length; i4++) {
                  var part = parts[i4];
                  if (hasOwnProp2(_item, part)) {
                    _item = _item[part];
                  } else {
                    return void 0;
                  }
                }
                return _item;
              };
            }
            exports3.getAttrGetter = getAttrGetter2;
            function groupBy(obj, val, throwOnUndefined) {
              var result = {};
              var iterator = isFunction(val) ? val : getAttrGetter2(val);
              for (var i4 = 0; i4 < obj.length; i4++) {
                var value = obj[i4];
                var key = iterator(value, i4);
                if (key === void 0 && throwOnUndefined === true) {
                  throw new TypeError('groupby: attribute "' + val + '" resolved to undefined');
                }
                (result[key] || (result[key] = [])).push(value);
              }
              return result;
            }
            exports3.groupBy = groupBy;
            function toArray(obj) {
              return Array.prototype.slice.call(obj);
            }
            exports3.toArray = toArray;
            function without(array) {
              var result = [];
              if (!array) {
                return result;
              }
              var length2 = array.length;
              var contains = toArray(arguments).slice(1);
              var index2 = -1;
              while (++index2 < length2) {
                if (indexOf(contains, array[index2]) === -1) {
                  result.push(array[index2]);
                }
              }
              return result;
            }
            exports3.without = without;
            function repeat(char_, n3) {
              var str = "";
              for (var i4 = 0; i4 < n3; i4++) {
                str += char_;
              }
              return str;
            }
            exports3.repeat = repeat;
            function each(obj, func, context) {
              if (obj == null) {
                return;
              }
              if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
                obj.forEach(func, context);
              } else if (obj.length === +obj.length) {
                for (var i4 = 0, l4 = obj.length; i4 < l4; i4++) {
                  func.call(context, obj[i4], i4, obj);
                }
              }
            }
            exports3.each = each;
            function map(obj, func) {
              var results = [];
              if (obj == null) {
                return results;
              }
              if (ArrayProto.map && obj.map === ArrayProto.map) {
                return obj.map(func);
              }
              for (var i4 = 0; i4 < obj.length; i4++) {
                results[results.length] = func(obj[i4], i4);
              }
              if (obj.length === +obj.length) {
                results.length = obj.length;
              }
              return results;
            }
            exports3.map = map;
            function asyncIter(arr, iter, cb) {
              var i4 = -1;
              function next2() {
                i4++;
                if (i4 < arr.length) {
                  iter(arr[i4], i4, next2, cb);
                } else {
                  cb();
                }
              }
              next2();
            }
            exports3.asyncIter = asyncIter;
            function asyncFor(obj, iter, cb) {
              var keys = keys_(obj || {});
              var len = keys.length;
              var i4 = -1;
              function next2() {
                i4++;
                var k4 = keys[i4];
                if (i4 < len) {
                  iter(k4, obj[k4], i4, len, next2);
                } else {
                  cb();
                }
              }
              next2();
            }
            exports3.asyncFor = asyncFor;
            function indexOf(arr, searchElement, fromIndex) {
              return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
            }
            exports3.indexOf = indexOf;
            function keys_(obj) {
              var arr = [];
              for (var k4 in obj) {
                if (hasOwnProp2(obj, k4)) {
                  arr.push(k4);
                }
              }
              return arr;
            }
            exports3.keys = keys_;
            function _entries(obj) {
              return keys_(obj).map(function(k4) {
                return [k4, obj[k4]];
              });
            }
            exports3._entries = _entries;
            function _values(obj) {
              return keys_(obj).map(function(k4) {
                return obj[k4];
              });
            }
            exports3._values = _values;
            function extend(obj1, obj2) {
              obj1 = obj1 || {};
              keys_(obj2).forEach(function(k4) {
                obj1[k4] = obj2[k4];
              });
              return obj1;
            }
            exports3._assign = exports3.extend = extend;
            function inOperator(key, val) {
              if (isArray3(val) || isString2(val)) {
                return val.indexOf(key) !== -1;
              } else if (isObject2(val)) {
                return key in val;
              }
              throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
            }
            exports3.inOperator = inOperator;
          },
          /* 1 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function _defineProperties2(target, props) {
              for (var i4 = 0; i4 < props.length; i4++) {
                var descriptor = props[i4];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              Object.defineProperty(Constructor, "prototype", { writable: false });
              return Constructor;
            }
            function _toPropertyKey2(arg) {
              var key = _toPrimitive2(arg, "string");
              return typeof key === "symbol" ? key : String(key);
            }
            function _toPrimitive2(input, hint) {
              if (typeof input !== "object" || input === null)
                return input;
              var prim = input[Symbol.toPrimitive];
              if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (typeof res !== "object")
                  return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (hint === "string" ? String : Number)(input);
            }
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf2(subClass, superClass);
            }
            function _setPrototypeOf2(o4, p5) {
              _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p6) {
                o5.__proto__ = p6;
                return o5;
              };
              return _setPrototypeOf2(o4, p5);
            }
            var EventEmitter = __webpack_require__(16);
            var lib = __webpack_require__(0);
            function parentWrap(parent, prop) {
              if (typeof parent !== "function" || typeof prop !== "function") {
                return prop;
              }
              return function wrap() {
                var tmp = this.parent;
                this.parent = parent;
                var res = prop.apply(this, arguments);
                this.parent = tmp;
                return res;
              };
            }
            function extendClass(cls, name, props) {
              props = props || {};
              lib.keys(props).forEach(function(k4) {
                props[k4] = parentWrap(cls.prototype[k4], props[k4]);
              });
              var subclass = /* @__PURE__ */ function(_cls) {
                _inheritsLoose(subclass2, _cls);
                function subclass2() {
                  return _cls.apply(this, arguments) || this;
                }
                _createClass2(subclass2, [{
                  key: "typename",
                  get: function get2() {
                    return name;
                  }
                }]);
                return subclass2;
              }(cls);
              lib._assign(subclass.prototype, props);
              return subclass;
            }
            var Obj = /* @__PURE__ */ function() {
              function Obj2() {
                this.init.apply(this, arguments);
              }
              var _proto = Obj2.prototype;
              _proto.init = function init() {
              };
              Obj2.extend = function extend(name, props) {
                if (typeof name === "object") {
                  props = name;
                  name = "anonymous";
                }
                return extendClass(this, name, props);
              };
              _createClass2(Obj2, [{
                key: "typename",
                get: function get2() {
                  return this.constructor.name;
                }
              }]);
              return Obj2;
            }();
            var EmitterObj = /* @__PURE__ */ function(_EventEmitter) {
              _inheritsLoose(EmitterObj2, _EventEmitter);
              function EmitterObj2() {
                var _this2;
                var _this;
                _this = _EventEmitter.call(this) || this;
                (_this2 = _this).init.apply(_this2, arguments);
                return _this;
              }
              var _proto2 = EmitterObj2.prototype;
              _proto2.init = function init() {
              };
              EmitterObj2.extend = function extend(name, props) {
                if (typeof name === "object") {
                  props = name;
                  name = "anonymous";
                }
                return extendClass(this, name, props);
              };
              _createClass2(EmitterObj2, [{
                key: "typename",
                get: function get2() {
                  return this.constructor.name;
                }
              }]);
              return EmitterObj2;
            }(EventEmitter);
            module3.exports = {
              Obj,
              EmitterObj
            };
          },
          /* 2 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var arrayFrom = Array.from;
            var supportsIterators = typeof Symbol === "function" && Symbol.iterator && typeof arrayFrom === "function";
            var Frame = /* @__PURE__ */ function() {
              function Frame2(parent, isolateWrites) {
                this.variables = /* @__PURE__ */ Object.create(null);
                this.parent = parent;
                this.topLevel = false;
                this.isolateWrites = isolateWrites;
              }
              var _proto = Frame2.prototype;
              _proto.set = function set(name, val, resolveUp) {
                var parts = name.split(".");
                var obj = this.variables;
                var frame = this;
                if (resolveUp) {
                  if (frame = this.resolve(parts[0], true)) {
                    frame.set(name, val);
                    return;
                  }
                }
                for (var i4 = 0; i4 < parts.length - 1; i4++) {
                  var id = parts[i4];
                  if (!obj[id]) {
                    obj[id] = {};
                  }
                  obj = obj[id];
                }
                obj[parts[parts.length - 1]] = val;
              };
              _proto.get = function get2(name) {
                var val = this.variables[name];
                if (val !== void 0) {
                  return val;
                }
                return null;
              };
              _proto.lookup = function lookup(name) {
                var p5 = this.parent;
                var val = this.variables[name];
                if (val !== void 0) {
                  return val;
                }
                return p5 && p5.lookup(name);
              };
              _proto.resolve = function resolve2(name, forWrite) {
                var p5 = forWrite && this.isolateWrites ? void 0 : this.parent;
                var val = this.variables[name];
                if (val !== void 0) {
                  return this;
                }
                return p5 && p5.resolve(name);
              };
              _proto.push = function push(isolateWrites) {
                return new Frame2(this, isolateWrites);
              };
              _proto.pop = function pop() {
                return this.parent;
              };
              return Frame2;
            }();
            function makeMacro(argNames, kwargNames, func) {
              return function macro() {
                for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
                  macroArgs[_key] = arguments[_key];
                }
                var argCount = numArgs(macroArgs);
                var args2;
                var kwargs = getKeywordArgs(macroArgs);
                if (argCount > argNames.length) {
                  args2 = macroArgs.slice(0, argNames.length);
                  macroArgs.slice(args2.length, argCount).forEach(function(val, i5) {
                    if (i5 < kwargNames.length) {
                      kwargs[kwargNames[i5]] = val;
                    }
                  });
                  args2.push(kwargs);
                } else if (argCount < argNames.length) {
                  args2 = macroArgs.slice(0, argCount);
                  for (var i4 = argCount; i4 < argNames.length; i4++) {
                    var arg = argNames[i4];
                    args2.push(kwargs[arg]);
                    delete kwargs[arg];
                  }
                  args2.push(kwargs);
                } else {
                  args2 = macroArgs;
                }
                return func.apply(this, args2);
              };
            }
            function makeKeywordArgs(obj) {
              obj.__keywords = true;
              return obj;
            }
            function isKeywordArgs(obj) {
              return obj && Object.prototype.hasOwnProperty.call(obj, "__keywords");
            }
            function getKeywordArgs(args2) {
              var len = args2.length;
              if (len) {
                var lastArg = args2[len - 1];
                if (isKeywordArgs(lastArg)) {
                  return lastArg;
                }
              }
              return {};
            }
            function numArgs(args2) {
              var len = args2.length;
              if (len === 0) {
                return 0;
              }
              var lastArg = args2[len - 1];
              if (isKeywordArgs(lastArg)) {
                return len - 1;
              } else {
                return len;
              }
            }
            function SafeString(val) {
              if (typeof val !== "string") {
                return val;
              }
              this.val = val;
              this.length = val.length;
            }
            SafeString.prototype = Object.create(String.prototype, {
              length: {
                writable: true,
                configurable: true,
                value: 0
              }
            });
            SafeString.prototype.valueOf = function valueOf() {
              return this.val;
            };
            SafeString.prototype.toString = function toString2() {
              return this.val;
            };
            function copySafeness(dest, target) {
              if (dest instanceof SafeString) {
                return new SafeString(target);
              }
              return target.toString();
            }
            function markSafe(val) {
              var type = typeof val;
              if (type === "string") {
                return new SafeString(val);
              } else if (type !== "function") {
                return val;
              } else {
                return function wrapSafe(args2) {
                  var ret = val.apply(this, arguments);
                  if (typeof ret === "string") {
                    return new SafeString(ret);
                  }
                  return ret;
                };
              }
            }
            function suppressValue(val, autoescape) {
              val = val !== void 0 && val !== null ? val : "";
              if (autoescape && !(val instanceof SafeString)) {
                val = lib.escape(val.toString());
              }
              return val;
            }
            function ensureDefined(val, lineno, colno) {
              if (val === null || val === void 0) {
                throw new lib.TemplateError("attempted to output null or undefined value", lineno + 1, colno + 1);
              }
              return val;
            }
            function memberLookup2(obj, val) {
              if (obj === void 0 || obj === null) {
                return void 0;
              }
              if (typeof obj[val] === "function") {
                return function() {
                  for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args2[_key2] = arguments[_key2];
                  }
                  return obj[val].apply(obj, args2);
                };
              }
              return obj[val];
            }
            function callWrap(obj, name, context, args2) {
              if (!obj) {
                throw new Error("Unable to call `" + name + "`, which is undefined or falsey");
              } else if (typeof obj !== "function") {
                throw new Error("Unable to call `" + name + "`, which is not a function");
              }
              return obj.apply(context, args2);
            }
            function contextOrFrameLookup(context, frame, name) {
              var val = frame.lookup(name);
              return val !== void 0 ? val : context.lookup(name);
            }
            function handleError(error, lineno, colno) {
              if (error.lineno) {
                return error;
              } else {
                return new lib.TemplateError(error, lineno, colno);
              }
            }
            function asyncEach(arr, dimen, iter, cb) {
              if (lib.isArray(arr)) {
                var len = arr.length;
                lib.asyncIter(arr, function iterCallback(item, i4, next2) {
                  switch (dimen) {
                    case 1:
                      iter(item, i4, len, next2);
                      break;
                    case 2:
                      iter(item[0], item[1], i4, len, next2);
                      break;
                    case 3:
                      iter(item[0], item[1], item[2], i4, len, next2);
                      break;
                    default:
                      item.push(i4, len, next2);
                      iter.apply(this, item);
                  }
                }, cb);
              } else {
                lib.asyncFor(arr, function iterCallback(key, val, i4, len2, next2) {
                  iter(key, val, i4, len2, next2);
                }, cb);
              }
            }
            function asyncAll(arr, dimen, func, cb) {
              var finished = 0;
              var len;
              var outputArr;
              function done(i5, output) {
                finished++;
                outputArr[i5] = output;
                if (finished === len) {
                  cb(null, outputArr.join(""));
                }
              }
              if (lib.isArray(arr)) {
                len = arr.length;
                outputArr = new Array(len);
                if (len === 0) {
                  cb(null, "");
                } else {
                  for (var i4 = 0; i4 < arr.length; i4++) {
                    var item = arr[i4];
                    switch (dimen) {
                      case 1:
                        func(item, i4, len, done);
                        break;
                      case 2:
                        func(item[0], item[1], i4, len, done);
                        break;
                      case 3:
                        func(item[0], item[1], item[2], i4, len, done);
                        break;
                      default:
                        item.push(i4, len, done);
                        func.apply(this, item);
                    }
                  }
                }
              } else {
                var keys = lib.keys(arr || {});
                len = keys.length;
                outputArr = new Array(len);
                if (len === 0) {
                  cb(null, "");
                } else {
                  for (var _i = 0; _i < keys.length; _i++) {
                    var k4 = keys[_i];
                    func(k4, arr[k4], _i, len, done);
                  }
                }
              }
            }
            function fromIterator(arr) {
              if (typeof arr !== "object" || arr === null || lib.isArray(arr)) {
                return arr;
              } else if (supportsIterators && Symbol.iterator in arr) {
                return arrayFrom(arr);
              } else {
                return arr;
              }
            }
            module3.exports = {
              Frame,
              makeMacro,
              makeKeywordArgs,
              numArgs,
              suppressValue,
              ensureDefined,
              memberLookup: memberLookup2,
              contextOrFrameLookup,
              callWrap,
              handleError,
              isArray: lib.isArray,
              keys: lib.keys,
              SafeString,
              copySafeness,
              markSafe,
              asyncEach,
              asyncAll,
              inOperator: lib.inOperator,
              fromIterator
            };
          },
          /* 3 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function _defineProperties2(target, props) {
              for (var i4 = 0; i4 < props.length; i4++) {
                var descriptor = props[i4];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              Object.defineProperty(Constructor, "prototype", { writable: false });
              return Constructor;
            }
            function _toPropertyKey2(arg) {
              var key = _toPrimitive2(arg, "string");
              return typeof key === "symbol" ? key : String(key);
            }
            function _toPrimitive2(input, hint) {
              if (typeof input !== "object" || input === null)
                return input;
              var prim = input[Symbol.toPrimitive];
              if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (typeof res !== "object")
                  return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (hint === "string" ? String : Number)(input);
            }
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf2(subClass, superClass);
            }
            function _setPrototypeOf2(o4, p5) {
              _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p6) {
                o5.__proto__ = p6;
                return o5;
              };
              return _setPrototypeOf2(o4, p5);
            }
            var _require = __webpack_require__(1), Obj = _require.Obj;
            function traverseAndCheck(obj, type, results) {
              if (obj instanceof type) {
                results.push(obj);
              }
              if (obj instanceof Node) {
                obj.findAll(type, results);
              }
            }
            var Node = /* @__PURE__ */ function(_Obj) {
              _inheritsLoose(Node2, _Obj);
              function Node2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto = Node2.prototype;
              _proto.init = function init(lineno, colno) {
                var _arguments = arguments, _this = this;
                for (var _len = arguments.length, args2 = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                  args2[_key - 2] = arguments[_key];
                }
                this.lineno = lineno;
                this.colno = colno;
                this.fields.forEach(function(field, i4) {
                  var val = _arguments[i4 + 2];
                  if (val === void 0) {
                    val = null;
                  }
                  _this[field] = val;
                });
              };
              _proto.findAll = function findAll(type, results) {
                var _this2 = this;
                results = results || [];
                if (this instanceof NodeList) {
                  this.children.forEach(function(child) {
                    return traverseAndCheck(child, type, results);
                  });
                } else {
                  this.fields.forEach(function(field) {
                    return traverseAndCheck(_this2[field], type, results);
                  });
                }
                return results;
              };
              _proto.iterFields = function iterFields(func) {
                var _this3 = this;
                this.fields.forEach(function(field) {
                  func(_this3[field], field);
                });
              };
              return Node2;
            }(Obj);
            var Value = /* @__PURE__ */ function(_Node) {
              _inheritsLoose(Value2, _Node);
              function Value2() {
                return _Node.apply(this, arguments) || this;
              }
              _createClass2(Value2, [{
                key: "typename",
                get: function get2() {
                  return "Value";
                }
              }, {
                key: "fields",
                get: function get2() {
                  return ["value"];
                }
              }]);
              return Value2;
            }(Node);
            var NodeList = /* @__PURE__ */ function(_Node2) {
              _inheritsLoose(NodeList2, _Node2);
              function NodeList2() {
                return _Node2.apply(this, arguments) || this;
              }
              var _proto2 = NodeList2.prototype;
              _proto2.init = function init(lineno, colno, nodes) {
                _Node2.prototype.init.call(this, lineno, colno, nodes || []);
              };
              _proto2.addChild = function addChild(node2) {
                this.children.push(node2);
              };
              _createClass2(NodeList2, [{
                key: "typename",
                get: function get2() {
                  return "NodeList";
                }
              }, {
                key: "fields",
                get: function get2() {
                  return ["children"];
                }
              }]);
              return NodeList2;
            }(Node);
            var Root = NodeList.extend("Root");
            var Literal = Value.extend("Literal");
            var _Symbol = Value.extend("Symbol");
            var Group3 = NodeList.extend("Group");
            var ArrayNode = NodeList.extend("Array");
            var Pair = Node.extend("Pair", {
              fields: ["key", "value"]
            });
            var Dict = NodeList.extend("Dict");
            var LookupVal = Node.extend("LookupVal", {
              fields: ["target", "val"]
            });
            var If = Node.extend("If", {
              fields: ["cond", "body", "else_"]
            });
            var IfAsync = If.extend("IfAsync");
            var InlineIf = Node.extend("InlineIf", {
              fields: ["cond", "body", "else_"]
            });
            var For = Node.extend("For", {
              fields: ["arr", "name", "body", "else_"]
            });
            var AsyncEach = For.extend("AsyncEach");
            var AsyncAll = For.extend("AsyncAll");
            var Macro = Node.extend("Macro", {
              fields: ["name", "args", "body"]
            });
            var Caller = Macro.extend("Caller");
            var Import = Node.extend("Import", {
              fields: ["template", "target", "withContext"]
            });
            var FromImport = /* @__PURE__ */ function(_Node3) {
              _inheritsLoose(FromImport2, _Node3);
              function FromImport2() {
                return _Node3.apply(this, arguments) || this;
              }
              var _proto3 = FromImport2.prototype;
              _proto3.init = function init(lineno, colno, template2, names, withContext) {
                _Node3.prototype.init.call(this, lineno, colno, template2, names || new NodeList(), withContext);
              };
              _createClass2(FromImport2, [{
                key: "typename",
                get: function get2() {
                  return "FromImport";
                }
              }, {
                key: "fields",
                get: function get2() {
                  return ["template", "names", "withContext"];
                }
              }]);
              return FromImport2;
            }(Node);
            var FunCall = Node.extend("FunCall", {
              fields: ["name", "args"]
            });
            var Filter = FunCall.extend("Filter");
            var FilterAsync = Filter.extend("FilterAsync", {
              fields: ["name", "args", "symbol"]
            });
            var KeywordArgs = Dict.extend("KeywordArgs");
            var Block = Node.extend("Block", {
              fields: ["name", "body"]
            });
            var Super = Node.extend("Super", {
              fields: ["blockName", "symbol"]
            });
            var TemplateRef = Node.extend("TemplateRef", {
              fields: ["template"]
            });
            var Extends = TemplateRef.extend("Extends");
            var Include = Node.extend("Include", {
              fields: ["template", "ignoreMissing"]
            });
            var Set2 = Node.extend("Set", {
              fields: ["targets", "value"]
            });
            var Switch = Node.extend("Switch", {
              fields: ["expr", "cases", "default"]
            });
            var Case = Node.extend("Case", {
              fields: ["cond", "body"]
            });
            var Output = NodeList.extend("Output");
            var Capture = Node.extend("Capture", {
              fields: ["body"]
            });
            var TemplateData = Literal.extend("TemplateData");
            var UnaryOp = Node.extend("UnaryOp", {
              fields: ["target"]
            });
            var BinOp = Node.extend("BinOp", {
              fields: ["left", "right"]
            });
            var In = BinOp.extend("In");
            var Is = BinOp.extend("Is");
            var Or = BinOp.extend("Or");
            var And = BinOp.extend("And");
            var Not = UnaryOp.extend("Not");
            var Add = BinOp.extend("Add");
            var Concat = BinOp.extend("Concat");
            var Sub = BinOp.extend("Sub");
            var Mul = BinOp.extend("Mul");
            var Div = BinOp.extend("Div");
            var FloorDiv = BinOp.extend("FloorDiv");
            var Mod = BinOp.extend("Mod");
            var Pow = BinOp.extend("Pow");
            var Neg = UnaryOp.extend("Neg");
            var Pos = UnaryOp.extend("Pos");
            var Compare = Node.extend("Compare", {
              fields: ["expr", "ops"]
            });
            var CompareOperand = Node.extend("CompareOperand", {
              fields: ["expr", "type"]
            });
            var CallExtension = Node.extend("CallExtension", {
              init: function init(ext, prop, args2, contentArgs) {
                this.parent();
                this.extName = ext.__name || ext;
                this.prop = prop;
                this.args = args2 || new NodeList();
                this.contentArgs = contentArgs || [];
                this.autoescape = ext.autoescape;
              },
              fields: ["extName", "prop", "args", "contentArgs"]
            });
            var CallExtensionAsync = CallExtension.extend("CallExtensionAsync");
            function print(str, indent, inline) {
              var lines = str.split("\n");
              lines.forEach(function(line2, i4) {
                if (line2 && (inline && i4 > 0 || !inline)) {
                  process.stdout.write(" ".repeat(indent));
                }
                var nl = i4 === lines.length - 1 ? "" : "\n";
                process.stdout.write("" + line2 + nl);
              });
            }
            function printNodes(node2, indent) {
              indent = indent || 0;
              print(node2.typename + ": ", indent);
              if (node2 instanceof NodeList) {
                print("\n");
                node2.children.forEach(function(n3) {
                  printNodes(n3, indent + 2);
                });
              } else if (node2 instanceof CallExtension) {
                print(node2.extName + "." + node2.prop + "\n");
                if (node2.args) {
                  printNodes(node2.args, indent + 2);
                }
                if (node2.contentArgs) {
                  node2.contentArgs.forEach(function(n3) {
                    printNodes(n3, indent + 2);
                  });
                }
              } else {
                var nodes = [];
                var props = null;
                node2.iterFields(function(val, fieldName) {
                  if (val instanceof Node) {
                    nodes.push([fieldName, val]);
                  } else {
                    props = props || {};
                    props[fieldName] = val;
                  }
                });
                if (props) {
                  print(JSON.stringify(props, null, 2) + "\n", null, true);
                } else {
                  print("\n");
                }
                nodes.forEach(function(_ref3) {
                  var fieldName = _ref3[0], n3 = _ref3[1];
                  print("[" + fieldName + "] =>", indent + 2);
                  printNodes(n3, indent + 4);
                });
              }
            }
            module3.exports = {
              Node,
              Root,
              NodeList,
              Value,
              Literal,
              Symbol: _Symbol,
              Group: Group3,
              Array: ArrayNode,
              Pair,
              Dict,
              Output,
              Capture,
              TemplateData,
              If,
              IfAsync,
              InlineIf,
              For,
              AsyncEach,
              AsyncAll,
              Macro,
              Caller,
              Import,
              FromImport,
              FunCall,
              Filter,
              FilterAsync,
              KeywordArgs,
              Block,
              Super,
              Extends,
              Include,
              Set: Set2,
              Switch,
              Case,
              LookupVal,
              BinOp,
              In,
              Is,
              Or,
              And,
              Not,
              Add,
              Concat,
              Sub,
              Mul,
              Div,
              FloorDiv,
              Mod,
              Pow,
              Neg,
              Pos,
              Compare,
              CompareOperand,
              CallExtension,
              CallExtensionAsync,
              printNodes
            };
          },
          /* 4 */
          /***/
          function(module3, exports3) {
          },
          /* 5 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf2(subClass, superClass);
            }
            function _setPrototypeOf2(o4, p5) {
              _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p6) {
                o5.__proto__ = p6;
                return o5;
              };
              return _setPrototypeOf2(o4, p5);
            }
            var parser = __webpack_require__(8);
            var transformer = __webpack_require__(17);
            var nodes = __webpack_require__(3);
            var _require = __webpack_require__(0), TemplateError = _require.TemplateError;
            var _require2 = __webpack_require__(2), Frame = _require2.Frame;
            var _require3 = __webpack_require__(1), Obj = _require3.Obj;
            var compareOps = {
              "==": "==",
              "===": "===",
              "!=": "!=",
              "!==": "!==",
              "<": "<",
              ">": ">",
              "<=": "<=",
              ">=": ">="
            };
            var Compiler = /* @__PURE__ */ function(_Obj) {
              _inheritsLoose(Compiler2, _Obj);
              function Compiler2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto = Compiler2.prototype;
              _proto.init = function init(templateName, throwOnUndefined) {
                this.templateName = templateName;
                this.codebuf = [];
                this.lastId = 0;
                this.buffer = null;
                this.bufferStack = [];
                this._scopeClosers = "";
                this.inBlock = false;
                this.throwOnUndefined = throwOnUndefined;
              };
              _proto.fail = function fail(msg, lineno, colno) {
                if (lineno !== void 0) {
                  lineno += 1;
                }
                if (colno !== void 0) {
                  colno += 1;
                }
                throw new TemplateError(msg, lineno, colno);
              };
              _proto._pushBuffer = function _pushBuffer() {
                var id = this._tmpid();
                this.bufferStack.push(this.buffer);
                this.buffer = id;
                this._emit("var " + this.buffer + ' = "";');
                return id;
              };
              _proto._popBuffer = function _popBuffer() {
                this.buffer = this.bufferStack.pop();
              };
              _proto._emit = function _emit(code) {
                this.codebuf.push(code);
              };
              _proto._emitLine = function _emitLine(code) {
                this._emit(code + "\n");
              };
              _proto._emitLines = function _emitLines() {
                var _this = this;
                for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
                  lines[_key] = arguments[_key];
                }
                lines.forEach(function(line2) {
                  return _this._emitLine(line2);
                });
              };
              _proto._emitFuncBegin = function _emitFuncBegin(node2, name) {
                this.buffer = "output";
                this._scopeClosers = "";
                this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");
                this._emitLine("var lineno = " + node2.lineno + ";");
                this._emitLine("var colno = " + node2.colno + ";");
                this._emitLine("var " + this.buffer + ' = "";');
                this._emitLine("try {");
              };
              _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
                if (!noReturn) {
                  this._emitLine("cb(null, " + this.buffer + ");");
                }
                this._closeScopeLevels();
                this._emitLine("} catch (e) {");
                this._emitLine("  cb(runtime.handleError(e, lineno, colno));");
                this._emitLine("}");
                this._emitLine("}");
                this.buffer = null;
              };
              _proto._addScopeLevel = function _addScopeLevel() {
                this._scopeClosers += "})";
              };
              _proto._closeScopeLevels = function _closeScopeLevels() {
                this._emitLine(this._scopeClosers + ";");
                this._scopeClosers = "";
              };
              _proto._withScopedSyntax = function _withScopedSyntax(func) {
                var _scopeClosers = this._scopeClosers;
                this._scopeClosers = "";
                func.call(this);
                this._closeScopeLevels();
                this._scopeClosers = _scopeClosers;
              };
              _proto._makeCallback = function _makeCallback(res) {
                var err = this._tmpid();
                return "function(" + err + (res ? "," + res : "") + ") {\nif(" + err + ") { cb(" + err + "); return; }";
              };
              _proto._tmpid = function _tmpid() {
                this.lastId++;
                return "t_" + this.lastId;
              };
              _proto._templateName = function _templateName() {
                return this.templateName == null ? "undefined" : JSON.stringify(this.templateName);
              };
              _proto._compileChildren = function _compileChildren(node2, frame) {
                var _this2 = this;
                node2.children.forEach(function(child) {
                  _this2.compile(child, frame);
                });
              };
              _proto._compileAggregate = function _compileAggregate(node2, frame, startChar, endChar) {
                var _this3 = this;
                if (startChar) {
                  this._emit(startChar);
                }
                node2.children.forEach(function(child, i4) {
                  if (i4 > 0) {
                    _this3._emit(",");
                  }
                  _this3.compile(child, frame);
                });
                if (endChar) {
                  this._emit(endChar);
                }
              };
              _proto._compileExpression = function _compileExpression(node2, frame) {
                this.assertType(node2, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
                this.compile(node2, frame);
              };
              _proto.assertType = function assertType(node2) {
                for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  types[_key2 - 1] = arguments[_key2];
                }
                if (!types.some(function(t3) {
                  return node2 instanceof t3;
                })) {
                  this.fail("assertType: invalid type: " + node2.typename, node2.lineno, node2.colno);
                }
              };
              _proto.compileCallExtension = function compileCallExtension(node2, frame, async) {
                var _this4 = this;
                var args2 = node2.args;
                var contentArgs = node2.contentArgs;
                var autoescape = typeof node2.autoescape === "boolean" ? node2.autoescape : true;
                if (!async) {
                  this._emit(this.buffer + " += runtime.suppressValue(");
                }
                this._emit('env.getExtension("' + node2.extName + '")["' + node2.prop + '"](');
                this._emit("context");
                if (args2 || contentArgs) {
                  this._emit(",");
                }
                if (args2) {
                  if (!(args2 instanceof nodes.NodeList)) {
                    this.fail("compileCallExtension: arguments must be a NodeList, use `parser.parseSignature`");
                  }
                  args2.children.forEach(function(arg, i4) {
                    _this4._compileExpression(arg, frame);
                    if (i4 !== args2.children.length - 1 || contentArgs.length) {
                      _this4._emit(",");
                    }
                  });
                }
                if (contentArgs.length) {
                  contentArgs.forEach(function(arg, i4) {
                    if (i4 > 0) {
                      _this4._emit(",");
                    }
                    if (arg) {
                      _this4._emitLine("function(cb) {");
                      _this4._emitLine("if(!cb) { cb = function(err) { if(err) { throw err; }}}");
                      var id = _this4._pushBuffer();
                      _this4._withScopedSyntax(function() {
                        _this4.compile(arg, frame);
                        _this4._emitLine("cb(null, " + id + ");");
                      });
                      _this4._popBuffer();
                      _this4._emitLine("return " + id + ";");
                      _this4._emitLine("}");
                    } else {
                      _this4._emit("null");
                    }
                  });
                }
                if (async) {
                  var res = this._tmpid();
                  this._emitLine(", " + this._makeCallback(res));
                  this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");
                  this._addScopeLevel();
                } else {
                  this._emit(")");
                  this._emit(", " + autoescape + " && env.opts.autoescape);\n");
                }
              };
              _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node2, frame) {
                this.compileCallExtension(node2, frame, true);
              };
              _proto.compileNodeList = function compileNodeList(node2, frame) {
                this._compileChildren(node2, frame);
              };
              _proto.compileLiteral = function compileLiteral(node2) {
                if (typeof node2.value === "string") {
                  var val = node2.value.replace(/\\/g, "\\\\");
                  val = val.replace(/"/g, '\\"');
                  val = val.replace(/\n/g, "\\n");
                  val = val.replace(/\r/g, "\\r");
                  val = val.replace(/\t/g, "\\t");
                  val = val.replace(/\u2028/g, "\\u2028");
                  this._emit('"' + val + '"');
                } else if (node2.value === null) {
                  this._emit("null");
                } else {
                  this._emit(node2.value.toString());
                }
              };
              _proto.compileSymbol = function compileSymbol(node2, frame) {
                var name = node2.value;
                var v4 = frame.lookup(name);
                if (v4) {
                  this._emit(v4);
                } else {
                  this._emit('runtime.contextOrFrameLookup(context, frame, "' + name + '")');
                }
              };
              _proto.compileGroup = function compileGroup(node2, frame) {
                this._compileAggregate(node2, frame, "(", ")");
              };
              _proto.compileArray = function compileArray(node2, frame) {
                this._compileAggregate(node2, frame, "[", "]");
              };
              _proto.compileDict = function compileDict(node2, frame) {
                this._compileAggregate(node2, frame, "{", "}");
              };
              _proto.compilePair = function compilePair(node2, frame) {
                var key = node2.key;
                var val = node2.value;
                if (key instanceof nodes.Symbol) {
                  key = new nodes.Literal(key.lineno, key.colno, key.value);
                } else if (!(key instanceof nodes.Literal && typeof key.value === "string")) {
                  this.fail("compilePair: Dict keys must be strings or names", key.lineno, key.colno);
                }
                this.compile(key, frame);
                this._emit(": ");
                this._compileExpression(val, frame);
              };
              _proto.compileInlineIf = function compileInlineIf(node2, frame) {
                this._emit("(");
                this.compile(node2.cond, frame);
                this._emit("?");
                this.compile(node2.body, frame);
                this._emit(":");
                if (node2.else_ !== null) {
                  this.compile(node2.else_, frame);
                } else {
                  this._emit('""');
                }
                this._emit(")");
              };
              _proto.compileIn = function compileIn(node2, frame) {
                this._emit("runtime.inOperator(");
                this.compile(node2.left, frame);
                this._emit(",");
                this.compile(node2.right, frame);
                this._emit(")");
              };
              _proto.compileIs = function compileIs(node2, frame) {
                var right = node2.right.name ? node2.right.name.value : node2.right.value;
                this._emit('env.getTest("' + right + '").call(context, ');
                this.compile(node2.left, frame);
                if (node2.right.args) {
                  this._emit(",");
                  this.compile(node2.right.args, frame);
                }
                this._emit(") === true");
              };
              _proto._binOpEmitter = function _binOpEmitter(node2, frame, str) {
                this.compile(node2.left, frame);
                this._emit(str);
                this.compile(node2.right, frame);
              };
              _proto.compileOr = function compileOr(node2, frame) {
                return this._binOpEmitter(node2, frame, " || ");
              };
              _proto.compileAnd = function compileAnd(node2, frame) {
                return this._binOpEmitter(node2, frame, " && ");
              };
              _proto.compileAdd = function compileAdd(node2, frame) {
                return this._binOpEmitter(node2, frame, " + ");
              };
              _proto.compileConcat = function compileConcat(node2, frame) {
                return this._binOpEmitter(node2, frame, ' + "" + ');
              };
              _proto.compileSub = function compileSub(node2, frame) {
                return this._binOpEmitter(node2, frame, " - ");
              };
              _proto.compileMul = function compileMul(node2, frame) {
                return this._binOpEmitter(node2, frame, " * ");
              };
              _proto.compileDiv = function compileDiv(node2, frame) {
                return this._binOpEmitter(node2, frame, " / ");
              };
              _proto.compileMod = function compileMod(node2, frame) {
                return this._binOpEmitter(node2, frame, " % ");
              };
              _proto.compileNot = function compileNot(node2, frame) {
                this._emit("!");
                this.compile(node2.target, frame);
              };
              _proto.compileFloorDiv = function compileFloorDiv(node2, frame) {
                this._emit("Math.floor(");
                this.compile(node2.left, frame);
                this._emit(" / ");
                this.compile(node2.right, frame);
                this._emit(")");
              };
              _proto.compilePow = function compilePow(node2, frame) {
                this._emit("Math.pow(");
                this.compile(node2.left, frame);
                this._emit(", ");
                this.compile(node2.right, frame);
                this._emit(")");
              };
              _proto.compileNeg = function compileNeg(node2, frame) {
                this._emit("-");
                this.compile(node2.target, frame);
              };
              _proto.compilePos = function compilePos(node2, frame) {
                this._emit("+");
                this.compile(node2.target, frame);
              };
              _proto.compileCompare = function compileCompare(node2, frame) {
                var _this5 = this;
                this.compile(node2.expr, frame);
                node2.ops.forEach(function(op) {
                  _this5._emit(" " + compareOps[op.type] + " ");
                  _this5.compile(op.expr, frame);
                });
              };
              _proto.compileLookupVal = function compileLookupVal(node2, frame) {
                this._emit("runtime.memberLookup((");
                this._compileExpression(node2.target, frame);
                this._emit("),");
                this._compileExpression(node2.val, frame);
                this._emit(")");
              };
              _proto._getNodeName = function _getNodeName(node2) {
                switch (node2.typename) {
                  case "Symbol":
                    return node2.value;
                  case "FunCall":
                    return "the return value of (" + this._getNodeName(node2.name) + ")";
                  case "LookupVal":
                    return this._getNodeName(node2.target) + '["' + this._getNodeName(node2.val) + '"]';
                  case "Literal":
                    return node2.value.toString();
                  default:
                    return "--expression--";
                }
              };
              _proto.compileFunCall = function compileFunCall(node2, frame) {
                this._emit("(lineno = " + node2.lineno + ", colno = " + node2.colno + ", ");
                this._emit("runtime.callWrap(");
                this._compileExpression(node2.name, frame);
                this._emit(', "' + this._getNodeName(node2.name).replace(/"/g, '\\"') + '", context, ');
                this._compileAggregate(node2.args, frame, "[", "])");
                this._emit(")");
              };
              _proto.compileFilter = function compileFilter(node2, frame) {
                var name = node2.name;
                this.assertType(name, nodes.Symbol);
                this._emit('env.getFilter("' + name.value + '").call(context, ');
                this._compileAggregate(node2.args, frame);
                this._emit(")");
              };
              _proto.compileFilterAsync = function compileFilterAsync(node2, frame) {
                var name = node2.name;
                var symbol = node2.symbol.value;
                this.assertType(name, nodes.Symbol);
                frame.set(symbol, symbol);
                this._emit('env.getFilter("' + name.value + '").call(context, ');
                this._compileAggregate(node2.args, frame);
                this._emitLine(", " + this._makeCallback(symbol));
                this._addScopeLevel();
              };
              _proto.compileKeywordArgs = function compileKeywordArgs(node2, frame) {
                this._emit("runtime.makeKeywordArgs(");
                this.compileDict(node2, frame);
                this._emit(")");
              };
              _proto.compileSet = function compileSet(node2, frame) {
                var _this6 = this;
                var ids = [];
                node2.targets.forEach(function(target) {
                  var name = target.value;
                  var id = frame.lookup(name);
                  if (id === null || id === void 0) {
                    id = _this6._tmpid();
                    _this6._emitLine("var " + id + ";");
                  }
                  ids.push(id);
                });
                if (node2.value) {
                  this._emit(ids.join(" = ") + " = ");
                  this._compileExpression(node2.value, frame);
                  this._emitLine(";");
                } else {
                  this._emit(ids.join(" = ") + " = ");
                  this.compile(node2.body, frame);
                  this._emitLine(";");
                }
                node2.targets.forEach(function(target, i4) {
                  var id = ids[i4];
                  var name = target.value;
                  _this6._emitLine('frame.set("' + name + '", ' + id + ", true);");
                  _this6._emitLine("if(frame.topLevel) {");
                  _this6._emitLine('context.setVariable("' + name + '", ' + id + ");");
                  _this6._emitLine("}");
                  if (name.charAt(0) !== "_") {
                    _this6._emitLine("if(frame.topLevel) {");
                    _this6._emitLine('context.addExport("' + name + '", ' + id + ");");
                    _this6._emitLine("}");
                  }
                });
              };
              _proto.compileSwitch = function compileSwitch(node2, frame) {
                var _this7 = this;
                this._emit("switch (");
                this.compile(node2.expr, frame);
                this._emit(") {");
                node2.cases.forEach(function(c4, i4) {
                  _this7._emit("case ");
                  _this7.compile(c4.cond, frame);
                  _this7._emit(": ");
                  _this7.compile(c4.body, frame);
                  if (c4.body.children.length) {
                    _this7._emitLine("break;");
                  }
                });
                if (node2.default) {
                  this._emit("default:");
                  this.compile(node2.default, frame);
                }
                this._emit("}");
              };
              _proto.compileIf = function compileIf(node2, frame, async) {
                var _this8 = this;
                this._emit("if(");
                this._compileExpression(node2.cond, frame);
                this._emitLine(") {");
                this._withScopedSyntax(function() {
                  _this8.compile(node2.body, frame);
                  if (async) {
                    _this8._emit("cb()");
                  }
                });
                if (node2.else_) {
                  this._emitLine("}\nelse {");
                  this._withScopedSyntax(function() {
                    _this8.compile(node2.else_, frame);
                    if (async) {
                      _this8._emit("cb()");
                    }
                  });
                } else if (async) {
                  this._emitLine("}\nelse {");
                  this._emit("cb()");
                }
                this._emitLine("}");
              };
              _proto.compileIfAsync = function compileIfAsync(node2, frame) {
                this._emit("(function(cb) {");
                this.compileIf(node2, frame, true);
                this._emit("})(" + this._makeCallback());
                this._addScopeLevel();
              };
              _proto._emitLoopBindings = function _emitLoopBindings(node2, arr, i4, len) {
                var _this9 = this;
                var bindings = [{
                  name: "index",
                  val: i4 + " + 1"
                }, {
                  name: "index0",
                  val: i4
                }, {
                  name: "revindex",
                  val: len + " - " + i4
                }, {
                  name: "revindex0",
                  val: len + " - " + i4 + " - 1"
                }, {
                  name: "first",
                  val: i4 + " === 0"
                }, {
                  name: "last",
                  val: i4 + " === " + len + " - 1"
                }, {
                  name: "length",
                  val: len
                }];
                bindings.forEach(function(b4) {
                  _this9._emitLine('frame.set("loop.' + b4.name + '", ' + b4.val + ");");
                });
              };
              _proto.compileFor = function compileFor(node2, frame) {
                var _this10 = this;
                var i4 = this._tmpid();
                var len = this._tmpid();
                var arr = this._tmpid();
                frame = frame.push();
                this._emitLine("frame = frame.push();");
                this._emit("var " + arr + " = ");
                this._compileExpression(node2.arr, frame);
                this._emitLine(";");
                this._emit("if(" + arr + ") {");
                this._emitLine(arr + " = runtime.fromIterator(" + arr + ");");
                if (node2.name instanceof nodes.Array) {
                  this._emitLine("var " + i4 + ";");
                  this._emitLine("if(runtime.isArray(" + arr + ")) {");
                  this._emitLine("var " + len + " = " + arr + ".length;");
                  this._emitLine("for(" + i4 + "=0; " + i4 + " < " + arr + ".length; " + i4 + "++) {");
                  node2.name.children.forEach(function(child, u3) {
                    var tid = _this10._tmpid();
                    _this10._emitLine("var " + tid + " = " + arr + "[" + i4 + "][" + u3 + "];");
                    _this10._emitLine('frame.set("' + child + '", ' + arr + "[" + i4 + "][" + u3 + "]);");
                    frame.set(node2.name.children[u3].value, tid);
                  });
                  this._emitLoopBindings(node2, arr, i4, len);
                  this._withScopedSyntax(function() {
                    _this10.compile(node2.body, frame);
                  });
                  this._emitLine("}");
                  this._emitLine("} else {");
                  var _node$name$children = node2.name.children, key = _node$name$children[0], val = _node$name$children[1];
                  var k4 = this._tmpid();
                  var v4 = this._tmpid();
                  frame.set(key.value, k4);
                  frame.set(val.value, v4);
                  this._emitLine(i4 + " = -1;");
                  this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");
                  this._emitLine("for(var " + k4 + " in " + arr + ") {");
                  this._emitLine(i4 + "++;");
                  this._emitLine("var " + v4 + " = " + arr + "[" + k4 + "];");
                  this._emitLine('frame.set("' + key.value + '", ' + k4 + ");");
                  this._emitLine('frame.set("' + val.value + '", ' + v4 + ");");
                  this._emitLoopBindings(node2, arr, i4, len);
                  this._withScopedSyntax(function() {
                    _this10.compile(node2.body, frame);
                  });
                  this._emitLine("}");
                  this._emitLine("}");
                } else {
                  var _v = this._tmpid();
                  frame.set(node2.name.value, _v);
                  this._emitLine("var " + len + " = " + arr + ".length;");
                  this._emitLine("for(var " + i4 + "=0; " + i4 + " < " + arr + ".length; " + i4 + "++) {");
                  this._emitLine("var " + _v + " = " + arr + "[" + i4 + "];");
                  this._emitLine('frame.set("' + node2.name.value + '", ' + _v + ");");
                  this._emitLoopBindings(node2, arr, i4, len);
                  this._withScopedSyntax(function() {
                    _this10.compile(node2.body, frame);
                  });
                  this._emitLine("}");
                }
                this._emitLine("}");
                if (node2.else_) {
                  this._emitLine("if (!" + len + ") {");
                  this.compile(node2.else_, frame);
                  this._emitLine("}");
                }
                this._emitLine("frame = frame.pop();");
              };
              _proto._compileAsyncLoop = function _compileAsyncLoop(node2, frame, parallel) {
                var _this11 = this;
                var i4 = this._tmpid();
                var len = this._tmpid();
                var arr = this._tmpid();
                var asyncMethod = parallel ? "asyncAll" : "asyncEach";
                frame = frame.push();
                this._emitLine("frame = frame.push();");
                this._emit("var " + arr + " = runtime.fromIterator(");
                this._compileExpression(node2.arr, frame);
                this._emitLine(");");
                if (node2.name instanceof nodes.Array) {
                  var arrayLen = node2.name.children.length;
                  this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");
                  node2.name.children.forEach(function(name) {
                    _this11._emit(name.value + ",");
                  });
                  this._emit(i4 + "," + len + ",next) {");
                  node2.name.children.forEach(function(name) {
                    var id2 = name.value;
                    frame.set(id2, id2);
                    _this11._emitLine('frame.set("' + id2 + '", ' + id2 + ");");
                  });
                } else {
                  var id = node2.name.value;
                  this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i4 + ", " + len + ",next) {");
                  this._emitLine('frame.set("' + id + '", ' + id + ");");
                  frame.set(id, id);
                }
                this._emitLoopBindings(node2, arr, i4, len);
                this._withScopedSyntax(function() {
                  var buf;
                  if (parallel) {
                    buf = _this11._pushBuffer();
                  }
                  _this11.compile(node2.body, frame);
                  _this11._emitLine("next(" + i4 + (buf ? "," + buf : "") + ");");
                  if (parallel) {
                    _this11._popBuffer();
                  }
                });
                var output = this._tmpid();
                this._emitLine("}, " + this._makeCallback(output));
                this._addScopeLevel();
                if (parallel) {
                  this._emitLine(this.buffer + " += " + output + ";");
                }
                if (node2.else_) {
                  this._emitLine("if (!" + arr + ".length) {");
                  this.compile(node2.else_, frame);
                  this._emitLine("}");
                }
                this._emitLine("frame = frame.pop();");
              };
              _proto.compileAsyncEach = function compileAsyncEach(node2, frame) {
                this._compileAsyncLoop(node2, frame);
              };
              _proto.compileAsyncAll = function compileAsyncAll(node2, frame) {
                this._compileAsyncLoop(node2, frame, true);
              };
              _proto._compileMacro = function _compileMacro(node2, frame) {
                var _this12 = this;
                var args2 = [];
                var kwargs = null;
                var funcId = "macro_" + this._tmpid();
                var keepFrame = frame !== void 0;
                node2.args.children.forEach(function(arg, i4) {
                  if (i4 === node2.args.children.length - 1 && arg instanceof nodes.Dict) {
                    kwargs = arg;
                  } else {
                    _this12.assertType(arg, nodes.Symbol);
                    args2.push(arg);
                  }
                });
                var realNames = [].concat(args2.map(function(n3) {
                  return "l_" + n3.value;
                }), ["kwargs"]);
                var argNames = args2.map(function(n3) {
                  return '"' + n3.value + '"';
                });
                var kwargNames = (kwargs && kwargs.children || []).map(function(n3) {
                  return '"' + n3.key.value + '"';
                });
                var currFrame;
                if (keepFrame) {
                  currFrame = frame.push(true);
                } else {
                  currFrame = new Frame();
                }
                this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(", ") + "], ", "[" + kwargNames.join(", ") + "], ", "function (" + realNames.join(", ") + ") {", "var callerFrame = frame;", "frame = " + (keepFrame ? "frame.push(true);" : "new runtime.Frame();"), "kwargs = kwargs || {};", 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }');
                args2.forEach(function(arg) {
                  _this12._emitLine('frame.set("' + arg.value + '", l_' + arg.value + ");");
                  currFrame.set(arg.value, "l_" + arg.value);
                });
                if (kwargs) {
                  kwargs.children.forEach(function(pair) {
                    var name = pair.key.value;
                    _this12._emit('frame.set("' + name + '", ');
                    _this12._emit('Object.prototype.hasOwnProperty.call(kwargs, "' + name + '")');
                    _this12._emit(' ? kwargs["' + name + '"] : ');
                    _this12._compileExpression(pair.value, currFrame);
                    _this12._emit(");");
                  });
                }
                var bufferId = this._pushBuffer();
                this._withScopedSyntax(function() {
                  _this12.compile(node2.body, currFrame);
                });
                this._emitLine("frame = " + (keepFrame ? "frame.pop();" : "callerFrame;"));
                this._emitLine("return new runtime.SafeString(" + bufferId + ");");
                this._emitLine("});");
                this._popBuffer();
                return funcId;
              };
              _proto.compileMacro = function compileMacro(node2, frame) {
                var funcId = this._compileMacro(node2);
                var name = node2.name.value;
                frame.set(name, funcId);
                if (frame.parent) {
                  this._emitLine('frame.set("' + name + '", ' + funcId + ");");
                } else {
                  if (node2.name.value.charAt(0) !== "_") {
                    this._emitLine('context.addExport("' + name + '");');
                  }
                  this._emitLine('context.setVariable("' + name + '", ' + funcId + ");");
                }
              };
              _proto.compileCaller = function compileCaller(node2, frame) {
                this._emit("(function (){");
                var funcId = this._compileMacro(node2, frame);
                this._emit("return " + funcId + ";})()");
              };
              _proto._compileGetTemplate = function _compileGetTemplate(node2, frame, eagerCompile, ignoreMissing) {
                var parentTemplateId = this._tmpid();
                var parentName = this._templateName();
                var cb = this._makeCallback(parentTemplateId);
                var eagerCompileArg = eagerCompile ? "true" : "false";
                var ignoreMissingArg = ignoreMissing ? "true" : "false";
                this._emit("env.getTemplate(");
                this._compileExpression(node2.template, frame);
                this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);
                return parentTemplateId;
              };
              _proto.compileImport = function compileImport(node2, frame) {
                var target = node2.target.value;
                var id = this._compileGetTemplate(node2, frame, false, false);
                this._addScopeLevel();
                this._emitLine(id + ".getExported(" + (node2.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(id));
                this._addScopeLevel();
                frame.set(target, id);
                if (frame.parent) {
                  this._emitLine('frame.set("' + target + '", ' + id + ");");
                } else {
                  this._emitLine('context.setVariable("' + target + '", ' + id + ");");
                }
              };
              _proto.compileFromImport = function compileFromImport(node2, frame) {
                var _this13 = this;
                var importedId = this._compileGetTemplate(node2, frame, false, false);
                this._addScopeLevel();
                this._emitLine(importedId + ".getExported(" + (node2.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(importedId));
                this._addScopeLevel();
                node2.names.children.forEach(function(nameNode) {
                  var name;
                  var alias;
                  var id = _this13._tmpid();
                  if (nameNode instanceof nodes.Pair) {
                    name = nameNode.key.value;
                    alias = nameNode.value.value;
                  } else {
                    name = nameNode.value;
                    alias = name;
                  }
                  _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ', "' + name + '")) {');
                  _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");
                  _this13._emitLine("} else {");
                  _this13._emitLine(`cb(new Error("cannot import '` + name + `'")); return;`);
                  _this13._emitLine("}");
                  frame.set(alias, id);
                  if (frame.parent) {
                    _this13._emitLine('frame.set("' + alias + '", ' + id + ");");
                  } else {
                    _this13._emitLine('context.setVariable("' + alias + '", ' + id + ");");
                  }
                });
              };
              _proto.compileBlock = function compileBlock(node2) {
                var id = this._tmpid();
                if (!this.inBlock) {
                  this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
                }
                this._emit('context.getBlock("' + node2.name.value + '")');
                if (!this.inBlock) {
                  this._emit(")");
                }
                this._emitLine("(env, context, frame, runtime, " + this._makeCallback(id));
                this._emitLine(this.buffer + " += " + id + ";");
                this._addScopeLevel();
              };
              _proto.compileSuper = function compileSuper(node2, frame) {
                var name = node2.blockName.value;
                var id = node2.symbol.value;
                var cb = this._makeCallback(id);
                this._emitLine('context.getSuper(env, "' + name + '", b_' + name + ", frame, runtime, " + cb);
                this._emitLine(id + " = runtime.markSafe(" + id + ");");
                this._addScopeLevel();
                frame.set(id, id);
              };
              _proto.compileExtends = function compileExtends(node2, frame) {
                var k4 = this._tmpid();
                var parentTemplateId = this._compileGetTemplate(node2, frame, true, false);
                this._emitLine("parentTemplate = " + parentTemplateId);
                this._emitLine("for(var " + k4 + " in parentTemplate.blocks) {");
                this._emitLine("context.addBlock(" + k4 + ", parentTemplate.blocks[" + k4 + "]);");
                this._emitLine("}");
                this._addScopeLevel();
              };
              _proto.compileInclude = function compileInclude(node2, frame) {
                this._emitLine("var tasks = [];");
                this._emitLine("tasks.push(");
                this._emitLine("function(callback) {");
                var id = this._compileGetTemplate(node2, frame, false, node2.ignoreMissing);
                this._emitLine("callback(null," + id + ");});");
                this._emitLine("});");
                var id2 = this._tmpid();
                this._emitLine("tasks.push(");
                this._emitLine("function(template, callback){");
                this._emitLine("template.render(context.getVariables(), frame, " + this._makeCallback(id2));
                this._emitLine("callback(null," + id2 + ");});");
                this._emitLine("});");
                this._emitLine("tasks.push(");
                this._emitLine("function(result, callback){");
                this._emitLine(this.buffer + " += result;");
                this._emitLine("callback(null);");
                this._emitLine("});");
                this._emitLine("env.waterfall(tasks, function(){");
                this._addScopeLevel();
              };
              _proto.compileTemplateData = function compileTemplateData(node2, frame) {
                this.compileLiteral(node2, frame);
              };
              _proto.compileCapture = function compileCapture(node2, frame) {
                var _this14 = this;
                var buffer = this.buffer;
                this.buffer = "output";
                this._emitLine("(function() {");
                this._emitLine('var output = "";');
                this._withScopedSyntax(function() {
                  _this14.compile(node2.body, frame);
                });
                this._emitLine("return output;");
                this._emitLine("})()");
                this.buffer = buffer;
              };
              _proto.compileOutput = function compileOutput(node2, frame) {
                var _this15 = this;
                var children = node2.children;
                children.forEach(function(child) {
                  if (child instanceof nodes.TemplateData) {
                    if (child.value) {
                      _this15._emit(_this15.buffer + " += ");
                      _this15.compileLiteral(child, frame);
                      _this15._emitLine(";");
                    }
                  } else {
                    _this15._emit(_this15.buffer + " += runtime.suppressValue(");
                    if (_this15.throwOnUndefined) {
                      _this15._emit("runtime.ensureDefined(");
                    }
                    _this15.compile(child, frame);
                    if (_this15.throwOnUndefined) {
                      _this15._emit("," + node2.lineno + "," + node2.colno + ")");
                    }
                    _this15._emit(", env.opts.autoescape);\n");
                  }
                });
              };
              _proto.compileRoot = function compileRoot(node2, frame) {
                var _this16 = this;
                if (frame) {
                  this.fail("compileRoot: root node can't have frame");
                }
                frame = new Frame();
                this._emitFuncBegin(node2, "root");
                this._emitLine("var parentTemplate = null;");
                this._compileChildren(node2, frame);
                this._emitLine("if(parentTemplate) {");
                this._emitLine("parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);");
                this._emitLine("} else {");
                this._emitLine("cb(null, " + this.buffer + ");");
                this._emitLine("}");
                this._emitFuncEnd(true);
                this.inBlock = true;
                var blockNames = [];
                var blocks = node2.findAll(nodes.Block);
                blocks.forEach(function(block, i4) {
                  var name = block.name.value;
                  if (blockNames.indexOf(name) !== -1) {
                    throw new Error('Block "' + name + '" defined more than once.');
                  }
                  blockNames.push(name);
                  _this16._emitFuncBegin(block, "b_" + name);
                  var tmpFrame = new Frame();
                  _this16._emitLine("var frame = frame.push(true);");
                  _this16.compile(block.body, tmpFrame);
                  _this16._emitFuncEnd();
                });
                this._emitLine("return {");
                blocks.forEach(function(block, i4) {
                  var blockName = "b_" + block.name.value;
                  _this16._emitLine(blockName + ": " + blockName + ",");
                });
                this._emitLine("root: root\n};");
              };
              _proto.compile = function compile2(node2, frame) {
                var _compile = this["compile" + node2.typename];
                if (_compile) {
                  _compile.call(this, node2, frame);
                } else {
                  this.fail("compile: Cannot compile node: " + node2.typename, node2.lineno, node2.colno);
                }
              };
              _proto.getCode = function getCode() {
                return this.codebuf.join("");
              };
              return Compiler2;
            }(Obj);
            module3.exports = {
              compile: function compile2(src, asyncFilters, extensions, name, opts) {
                if (opts === void 0) {
                  opts = {};
                }
                var c4 = new Compiler(name, opts.throwOnUndefined);
                var preprocessors = (extensions || []).map(function(ext) {
                  return ext.preprocess;
                }).filter(function(f4) {
                  return !!f4;
                });
                var processedSrc = preprocessors.reduce(function(s5, processor) {
                  return processor(s5);
                }, src);
                c4.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
                return c4.getCode();
              },
              Compiler
            };
          },
          /* 6 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf2(subClass, superClass);
            }
            function _setPrototypeOf2(o4, p5) {
              _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p6) {
                o5.__proto__ = p6;
                return o5;
              };
              return _setPrototypeOf2(o4, p5);
            }
            var path8 = __webpack_require__(4);
            var _require = __webpack_require__(1), EmitterObj = _require.EmitterObj;
            module3.exports = /* @__PURE__ */ function(_EmitterObj) {
              _inheritsLoose(Loader2, _EmitterObj);
              function Loader2() {
                return _EmitterObj.apply(this, arguments) || this;
              }
              var _proto = Loader2.prototype;
              _proto.resolve = function resolve2(from2, to) {
                return path8.resolve(path8.dirname(from2), to);
              };
              _proto.isRelative = function isRelative(filename) {
                return filename.indexOf("./") === 0 || filename.indexOf("../") === 0;
              };
              return Loader2;
            }(EmitterObj);
          },
          /* 7 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf2(subClass, superClass);
            }
            function _setPrototypeOf2(o4, p5) {
              _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p6) {
                o5.__proto__ = p6;
                return o5;
              };
              return _setPrototypeOf2(o4, p5);
            }
            var asap = __webpack_require__(12);
            var _waterfall = __webpack_require__(15);
            var lib = __webpack_require__(0);
            var compiler = __webpack_require__(5);
            var filters = __webpack_require__(18);
            var _require = __webpack_require__(10), FileSystemLoader = _require.FileSystemLoader, WebLoader = _require.WebLoader, PrecompiledLoader = _require.PrecompiledLoader;
            var tests = __webpack_require__(20);
            var globals = __webpack_require__(21);
            var _require2 = __webpack_require__(1), Obj = _require2.Obj, EmitterObj = _require2.EmitterObj;
            var globalRuntime = __webpack_require__(2);
            var handleError = globalRuntime.handleError, Frame = globalRuntime.Frame;
            var expressApp = __webpack_require__(22);
            function callbackAsap(cb, err, res) {
              asap(function() {
                cb(err, res);
              });
            }
            var noopTmplSrc = {
              type: "code",
              obj: {
                root: function root(env2, context, frame, runtime, cb) {
                  try {
                    cb(null, "");
                  } catch (e3) {
                    cb(handleError(e3, null, null));
                  }
                }
              }
            };
            var Environment = /* @__PURE__ */ function(_EmitterObj) {
              _inheritsLoose(Environment2, _EmitterObj);
              function Environment2() {
                return _EmitterObj.apply(this, arguments) || this;
              }
              var _proto = Environment2.prototype;
              _proto.init = function init(loaders, opts) {
                var _this = this;
                opts = this.opts = opts || {};
                this.opts.dev = !!opts.dev;
                this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;
                this.opts.throwOnUndefined = !!opts.throwOnUndefined;
                this.opts.trimBlocks = !!opts.trimBlocks;
                this.opts.lstripBlocks = !!opts.lstripBlocks;
                this.loaders = [];
                if (!loaders) {
                  if (FileSystemLoader) {
                    this.loaders = [new FileSystemLoader("views")];
                  } else if (WebLoader) {
                    this.loaders = [new WebLoader("/views")];
                  }
                } else {
                  this.loaders = lib.isArray(loaders) ? loaders : [loaders];
                }
                if (typeof window !== "undefined" && window.nunjucksPrecompiled) {
                  this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
                }
                this._initLoaders();
                this.globals = globals();
                this.filters = {};
                this.tests = {};
                this.asyncFilters = [];
                this.extensions = {};
                this.extensionsList = [];
                lib._entries(filters).forEach(function(_ref3) {
                  var name = _ref3[0], filter = _ref3[1];
                  return _this.addFilter(name, filter);
                });
                lib._entries(tests).forEach(function(_ref23) {
                  var name = _ref23[0], test = _ref23[1];
                  return _this.addTest(name, test);
                });
              };
              _proto._initLoaders = function _initLoaders() {
                var _this2 = this;
                this.loaders.forEach(function(loader2) {
                  loader2.cache = {};
                  if (typeof loader2.on === "function") {
                    loader2.on("update", function(name, fullname) {
                      loader2.cache[name] = null;
                      _this2.emit("update", name, fullname, loader2);
                    });
                    loader2.on("load", function(name, source) {
                      _this2.emit("load", name, source, loader2);
                    });
                  }
                });
              };
              _proto.invalidateCache = function invalidateCache() {
                this.loaders.forEach(function(loader2) {
                  loader2.cache = {};
                });
              };
              _proto.addExtension = function addExtension(name, extension) {
                extension.__name = name;
                this.extensions[name] = extension;
                this.extensionsList.push(extension);
                return this;
              };
              _proto.removeExtension = function removeExtension(name) {
                var extension = this.getExtension(name);
                if (!extension) {
                  return;
                }
                this.extensionsList = lib.without(this.extensionsList, extension);
                delete this.extensions[name];
              };
              _proto.getExtension = function getExtension(name) {
                return this.extensions[name];
              };
              _proto.hasExtension = function hasExtension(name) {
                return !!this.extensions[name];
              };
              _proto.addGlobal = function addGlobal(name, value) {
                this.globals[name] = value;
                return this;
              };
              _proto.getGlobal = function getGlobal(name) {
                if (typeof this.globals[name] === "undefined") {
                  throw new Error("global not found: " + name);
                }
                return this.globals[name];
              };
              _proto.addFilter = function addFilter(name, func, async) {
                var wrapped = func;
                if (async) {
                  this.asyncFilters.push(name);
                }
                this.filters[name] = wrapped;
                return this;
              };
              _proto.getFilter = function getFilter(name) {
                if (!this.filters[name]) {
                  throw new Error("filter not found: " + name);
                }
                return this.filters[name];
              };
              _proto.addTest = function addTest(name, func) {
                this.tests[name] = func;
                return this;
              };
              _proto.getTest = function getTest(name) {
                if (!this.tests[name]) {
                  throw new Error("test not found: " + name);
                }
                return this.tests[name];
              };
              _proto.resolveTemplate = function resolveTemplate(loader2, parentName, filename) {
                var isRelative = loader2.isRelative && parentName ? loader2.isRelative(filename) : false;
                return isRelative && loader2.resolve ? loader2.resolve(parentName, filename) : filename;
              };
              _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
                var _this3 = this;
                var that = this;
                var tmpl = null;
                if (name && name.raw) {
                  name = name.raw;
                }
                if (lib.isFunction(parentName)) {
                  cb = parentName;
                  parentName = null;
                  eagerCompile = eagerCompile || false;
                }
                if (lib.isFunction(eagerCompile)) {
                  cb = eagerCompile;
                  eagerCompile = false;
                }
                if (name instanceof Template) {
                  tmpl = name;
                } else if (typeof name !== "string") {
                  throw new Error("template names must be a string: " + name);
                } else {
                  for (var i4 = 0; i4 < this.loaders.length; i4++) {
                    var loader2 = this.loaders[i4];
                    tmpl = loader2.cache[this.resolveTemplate(loader2, parentName, name)];
                    if (tmpl) {
                      break;
                    }
                  }
                }
                if (tmpl) {
                  if (eagerCompile) {
                    tmpl.compile();
                  }
                  if (cb) {
                    cb(null, tmpl);
                    return void 0;
                  } else {
                    return tmpl;
                  }
                }
                var syncResult;
                var createTemplate = function createTemplate2(err, info) {
                  if (!info && !err && !ignoreMissing) {
                    err = new Error("template not found: " + name);
                  }
                  if (err) {
                    if (cb) {
                      cb(err);
                      return;
                    } else {
                      throw err;
                    }
                  }
                  var newTmpl;
                  if (!info) {
                    newTmpl = new Template(noopTmplSrc, _this3, "", eagerCompile);
                  } else {
                    newTmpl = new Template(info.src, _this3, info.path, eagerCompile);
                    if (!info.noCache) {
                      info.loader.cache[name] = newTmpl;
                    }
                  }
                  if (cb) {
                    cb(null, newTmpl);
                  } else {
                    syncResult = newTmpl;
                  }
                };
                lib.asyncIter(this.loaders, function(loader3, i5, next2, done) {
                  function handle(err, src) {
                    if (err) {
                      done(err);
                    } else if (src) {
                      src.loader = loader3;
                      done(null, src);
                    } else {
                      next2();
                    }
                  }
                  name = that.resolveTemplate(loader3, parentName, name);
                  if (loader3.async) {
                    loader3.getSource(name, handle);
                  } else {
                    handle(null, loader3.getSource(name));
                  }
                }, createTemplate);
                return syncResult;
              };
              _proto.express = function express(app2) {
                return expressApp(this, app2);
              };
              _proto.render = function render(name, ctx, cb) {
                if (lib.isFunction(ctx)) {
                  cb = ctx;
                  ctx = null;
                }
                var syncResult = null;
                this.getTemplate(name, function(err, tmpl) {
                  if (err && cb) {
                    callbackAsap(cb, err);
                  } else if (err) {
                    throw err;
                  } else {
                    syncResult = tmpl.render(ctx, cb);
                  }
                });
                return syncResult;
              };
              _proto.renderString = function renderString(src, ctx, opts, cb) {
                if (lib.isFunction(opts)) {
                  cb = opts;
                  opts = {};
                }
                opts = opts || {};
                var tmpl = new Template(src, this, opts.path);
                return tmpl.render(ctx, cb);
              };
              _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
                return _waterfall(tasks, callback, forceAsync);
              };
              return Environment2;
            }(EmitterObj);
            var Context = /* @__PURE__ */ function(_Obj) {
              _inheritsLoose(Context2, _Obj);
              function Context2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto2 = Context2.prototype;
              _proto2.init = function init(ctx, blocks, env2) {
                var _this4 = this;
                this.env = env2 || new Environment();
                this.ctx = lib.extend({}, ctx);
                this.blocks = {};
                this.exported = [];
                lib.keys(blocks).forEach(function(name) {
                  _this4.addBlock(name, blocks[name]);
                });
              };
              _proto2.lookup = function lookup(name) {
                if (name in this.env.globals && !(name in this.ctx)) {
                  return this.env.globals[name];
                } else {
                  return this.ctx[name];
                }
              };
              _proto2.setVariable = function setVariable(name, val) {
                this.ctx[name] = val;
              };
              _proto2.getVariables = function getVariables() {
                return this.ctx;
              };
              _proto2.addBlock = function addBlock(name, block) {
                this.blocks[name] = this.blocks[name] || [];
                this.blocks[name].push(block);
                return this;
              };
              _proto2.getBlock = function getBlock(name) {
                if (!this.blocks[name]) {
                  throw new Error('unknown block "' + name + '"');
                }
                return this.blocks[name][0];
              };
              _proto2.getSuper = function getSuper(env2, name, block, frame, runtime, cb) {
                var idx = lib.indexOf(this.blocks[name] || [], block);
                var blk = this.blocks[name][idx + 1];
                var context = this;
                if (idx === -1 || !blk) {
                  throw new Error('no super block available for "' + name + '"');
                }
                blk(env2, context, frame, runtime, cb);
              };
              _proto2.addExport = function addExport(name) {
                this.exported.push(name);
              };
              _proto2.getExported = function getExported() {
                var _this5 = this;
                var exported = {};
                this.exported.forEach(function(name) {
                  exported[name] = _this5.ctx[name];
                });
                return exported;
              };
              return Context2;
            }(Obj);
            var Template = /* @__PURE__ */ function(_Obj2) {
              _inheritsLoose(Template2, _Obj2);
              function Template2() {
                return _Obj2.apply(this, arguments) || this;
              }
              var _proto3 = Template2.prototype;
              _proto3.init = function init(src, env2, path8, eagerCompile) {
                this.env = env2 || new Environment();
                if (lib.isObject(src)) {
                  switch (src.type) {
                    case "code":
                      this.tmplProps = src.obj;
                      break;
                    case "string":
                      this.tmplStr = src.obj;
                      break;
                    default:
                      throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
                  }
                } else if (lib.isString(src)) {
                  this.tmplStr = src;
                } else {
                  throw new Error("src must be a string or an object describing the source");
                }
                this.path = path8;
                if (eagerCompile) {
                  try {
                    this._compile();
                  } catch (err) {
                    throw lib._prettifyError(this.path, this.env.opts.dev, err);
                  }
                } else {
                  this.compiled = false;
                }
              };
              _proto3.render = function render(ctx, parentFrame, cb) {
                var _this6 = this;
                if (typeof ctx === "function") {
                  cb = ctx;
                  ctx = {};
                } else if (typeof parentFrame === "function") {
                  cb = parentFrame;
                  parentFrame = null;
                }
                var forceAsync = !parentFrame;
                try {
                  this.compile();
                } catch (e3) {
                  var err = lib._prettifyError(this.path, this.env.opts.dev, e3);
                  if (cb) {
                    return callbackAsap(cb, err);
                  } else {
                    throw err;
                  }
                }
                var context = new Context(ctx || {}, this.blocks, this.env);
                var frame = parentFrame ? parentFrame.push(true) : new Frame();
                frame.topLevel = true;
                var syncResult = null;
                var didError = false;
                this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err2, res) {
                  if (didError && cb && typeof res !== "undefined") {
                    return;
                  }
                  if (err2) {
                    err2 = lib._prettifyError(_this6.path, _this6.env.opts.dev, err2);
                    didError = true;
                  }
                  if (cb) {
                    if (forceAsync) {
                      callbackAsap(cb, err2, res);
                    } else {
                      cb(err2, res);
                    }
                  } else {
                    if (err2) {
                      throw err2;
                    }
                    syncResult = res;
                  }
                });
                return syncResult;
              };
              _proto3.getExported = function getExported(ctx, parentFrame, cb) {
                if (typeof ctx === "function") {
                  cb = ctx;
                  ctx = {};
                }
                if (typeof parentFrame === "function") {
                  cb = parentFrame;
                  parentFrame = null;
                }
                try {
                  this.compile();
                } catch (e3) {
                  if (cb) {
                    return cb(e3);
                  } else {
                    throw e3;
                  }
                }
                var frame = parentFrame ? parentFrame.push() : new Frame();
                frame.topLevel = true;
                var context = new Context(ctx || {}, this.blocks, this.env);
                this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err) {
                  if (err) {
                    cb(err, null);
                  } else {
                    cb(null, context.getExported());
                  }
                });
              };
              _proto3.compile = function compile2() {
                if (!this.compiled) {
                  this._compile();
                }
              };
              _proto3._compile = function _compile() {
                var props;
                if (this.tmplProps) {
                  props = this.tmplProps;
                } else {
                  var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
                  var func = new Function(source);
                  props = func();
                }
                this.blocks = this._getBlocks(props);
                this.rootRenderFunc = props.root;
                this.compiled = true;
              };
              _proto3._getBlocks = function _getBlocks(props) {
                var blocks = {};
                lib.keys(props).forEach(function(k4) {
                  if (k4.slice(0, 2) === "b_") {
                    blocks[k4.slice(2)] = props[k4];
                  }
                });
                return blocks;
              };
              return Template2;
            }(Obj);
            module3.exports = {
              Environment,
              Template
            };
          },
          /* 8 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf2(subClass, superClass);
            }
            function _setPrototypeOf2(o4, p5) {
              _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p6) {
                o5.__proto__ = p6;
                return o5;
              };
              return _setPrototypeOf2(o4, p5);
            }
            var lexer = __webpack_require__(9);
            var nodes = __webpack_require__(3);
            var Obj = __webpack_require__(1).Obj;
            var lib = __webpack_require__(0);
            var Parser = /* @__PURE__ */ function(_Obj) {
              _inheritsLoose(Parser2, _Obj);
              function Parser2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto = Parser2.prototype;
              _proto.init = function init(tokens) {
                this.tokens = tokens;
                this.peeked = null;
                this.breakOnBlocks = null;
                this.dropLeadingWhitespace = false;
                this.extensions = [];
              };
              _proto.nextToken = function nextToken(withWhitespace) {
                var tok;
                if (this.peeked) {
                  if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
                    this.peeked = null;
                  } else {
                    tok = this.peeked;
                    this.peeked = null;
                    return tok;
                  }
                }
                tok = this.tokens.nextToken();
                if (!withWhitespace) {
                  while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
                    tok = this.tokens.nextToken();
                  }
                }
                return tok;
              };
              _proto.peekToken = function peekToken() {
                this.peeked = this.peeked || this.nextToken();
                return this.peeked;
              };
              _proto.pushToken = function pushToken(tok) {
                if (this.peeked) {
                  throw new Error("pushToken: can only push one token on between reads");
                }
                this.peeked = tok;
              };
              _proto.error = function error(msg, lineno, colno) {
                if (lineno === void 0 || colno === void 0) {
                  var tok = this.peekToken() || {};
                  lineno = tok.lineno;
                  colno = tok.colno;
                }
                if (lineno !== void 0) {
                  lineno += 1;
                }
                if (colno !== void 0) {
                  colno += 1;
                }
                return new lib.TemplateError(msg, lineno, colno);
              };
              _proto.fail = function fail(msg, lineno, colno) {
                throw this.error(msg, lineno, colno);
              };
              _proto.skip = function skip(type) {
                var tok = this.nextToken();
                if (!tok || tok.type !== type) {
                  this.pushToken(tok);
                  return false;
                }
                return true;
              };
              _proto.expect = function expect(type) {
                var tok = this.nextToken();
                if (tok.type !== type) {
                  this.fail("expected " + type + ", got " + tok.type, tok.lineno, tok.colno);
                }
                return tok;
              };
              _proto.skipValue = function skipValue(type, val) {
                var tok = this.nextToken();
                if (!tok || tok.type !== type || tok.value !== val) {
                  this.pushToken(tok);
                  return false;
                }
                return true;
              };
              _proto.skipSymbol = function skipSymbol(val) {
                return this.skipValue(lexer.TOKEN_SYMBOL, val);
              };
              _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
                var tok;
                if (!name) {
                  tok = this.peekToken();
                  if (!tok) {
                    this.fail("unexpected end of file");
                  }
                  if (tok.type !== lexer.TOKEN_SYMBOL) {
                    this.fail("advanceAfterBlockEnd: expected symbol token or explicit name to be passed");
                  }
                  name = this.nextToken().value;
                }
                tok = this.nextToken();
                if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
                  if (tok.value.charAt(0) === "-") {
                    this.dropLeadingWhitespace = true;
                  }
                } else {
                  this.fail("expected block end in " + name + " statement");
                }
                return tok;
              };
              _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
                var tok = this.nextToken();
                if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
                  this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === "-";
                } else {
                  this.pushToken(tok);
                  this.fail("expected variable end");
                }
              };
              _proto.parseFor = function parseFor() {
                var forTok = this.peekToken();
                var node2;
                var endBlock;
                if (this.skipSymbol("for")) {
                  node2 = new nodes.For(forTok.lineno, forTok.colno);
                  endBlock = "endfor";
                } else if (this.skipSymbol("asyncEach")) {
                  node2 = new nodes.AsyncEach(forTok.lineno, forTok.colno);
                  endBlock = "endeach";
                } else if (this.skipSymbol("asyncAll")) {
                  node2 = new nodes.AsyncAll(forTok.lineno, forTok.colno);
                  endBlock = "endall";
                } else {
                  this.fail("parseFor: expected for{Async}", forTok.lineno, forTok.colno);
                }
                node2.name = this.parsePrimary();
                if (!(node2.name instanceof nodes.Symbol)) {
                  this.fail("parseFor: variable name expected for loop");
                }
                var type = this.peekToken().type;
                if (type === lexer.TOKEN_COMMA) {
                  var key = node2.name;
                  node2.name = new nodes.Array(key.lineno, key.colno);
                  node2.name.addChild(key);
                  while (this.skip(lexer.TOKEN_COMMA)) {
                    var prim = this.parsePrimary();
                    node2.name.addChild(prim);
                  }
                }
                if (!this.skipSymbol("in")) {
                  this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
                }
                node2.arr = this.parseExpression();
                this.advanceAfterBlockEnd(forTok.value);
                node2.body = this.parseUntilBlocks(endBlock, "else");
                if (this.skipSymbol("else")) {
                  this.advanceAfterBlockEnd("else");
                  node2.else_ = this.parseUntilBlocks(endBlock);
                }
                this.advanceAfterBlockEnd();
                return node2;
              };
              _proto.parseMacro = function parseMacro() {
                var macroTok = this.peekToken();
                if (!this.skipSymbol("macro")) {
                  this.fail("expected macro");
                }
                var name = this.parsePrimary(true);
                var args2 = this.parseSignature();
                var node2 = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args2);
                this.advanceAfterBlockEnd(macroTok.value);
                node2.body = this.parseUntilBlocks("endmacro");
                this.advanceAfterBlockEnd();
                return node2;
              };
              _proto.parseCall = function parseCall() {
                var callTok = this.peekToken();
                if (!this.skipSymbol("call")) {
                  this.fail("expected call");
                }
                var callerArgs = this.parseSignature(true) || new nodes.NodeList();
                var macroCall = this.parsePrimary();
                this.advanceAfterBlockEnd(callTok.value);
                var body = this.parseUntilBlocks("endcall");
                this.advanceAfterBlockEnd();
                var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, "caller");
                var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body);
                var args2 = macroCall.args.children;
                if (!(args2[args2.length - 1] instanceof nodes.KeywordArgs)) {
                  args2.push(new nodes.KeywordArgs());
                }
                var kwargs = args2[args2.length - 1];
                kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
                return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
              };
              _proto.parseWithContext = function parseWithContext() {
                var tok = this.peekToken();
                var withContext = null;
                if (this.skipSymbol("with")) {
                  withContext = true;
                } else if (this.skipSymbol("without")) {
                  withContext = false;
                }
                if (withContext !== null) {
                  if (!this.skipSymbol("context")) {
                    this.fail("parseFrom: expected context after with/without", tok.lineno, tok.colno);
                  }
                }
                return withContext;
              };
              _proto.parseImport = function parseImport() {
                var importTok = this.peekToken();
                if (!this.skipSymbol("import")) {
                  this.fail("parseImport: expected import", importTok.lineno, importTok.colno);
                }
                var template2 = this.parseExpression();
                if (!this.skipSymbol("as")) {
                  this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
                }
                var target = this.parseExpression();
                var withContext = this.parseWithContext();
                var node2 = new nodes.Import(importTok.lineno, importTok.colno, template2, target, withContext);
                this.advanceAfterBlockEnd(importTok.value);
                return node2;
              };
              _proto.parseFrom = function parseFrom() {
                var fromTok = this.peekToken();
                if (!this.skipSymbol("from")) {
                  this.fail("parseFrom: expected from");
                }
                var template2 = this.parseExpression();
                if (!this.skipSymbol("import")) {
                  this.fail("parseFrom: expected import", fromTok.lineno, fromTok.colno);
                }
                var names = new nodes.NodeList();
                var withContext;
                while (1) {
                  var nextTok = this.peekToken();
                  if (nextTok.type === lexer.TOKEN_BLOCK_END) {
                    if (!names.children.length) {
                      this.fail("parseFrom: Expected at least one import name", fromTok.lineno, fromTok.colno);
                    }
                    if (nextTok.value.charAt(0) === "-") {
                      this.dropLeadingWhitespace = true;
                    }
                    this.nextToken();
                    break;
                  }
                  if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
                    this.fail("parseFrom: expected comma", fromTok.lineno, fromTok.colno);
                  }
                  var name = this.parsePrimary();
                  if (name.value.charAt(0) === "_") {
                    this.fail("parseFrom: names starting with an underscore cannot be imported", name.lineno, name.colno);
                  }
                  if (this.skipSymbol("as")) {
                    var alias = this.parsePrimary();
                    names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
                  } else {
                    names.addChild(name);
                  }
                  withContext = this.parseWithContext();
                }
                return new nodes.FromImport(fromTok.lineno, fromTok.colno, template2, names, withContext);
              };
              _proto.parseBlock = function parseBlock() {
                var tag = this.peekToken();
                if (!this.skipSymbol("block")) {
                  this.fail("parseBlock: expected block", tag.lineno, tag.colno);
                }
                var node2 = new nodes.Block(tag.lineno, tag.colno);
                node2.name = this.parsePrimary();
                if (!(node2.name instanceof nodes.Symbol)) {
                  this.fail("parseBlock: variable name expected", tag.lineno, tag.colno);
                }
                this.advanceAfterBlockEnd(tag.value);
                node2.body = this.parseUntilBlocks("endblock");
                this.skipSymbol("endblock");
                this.skipSymbol(node2.name.value);
                var tok = this.peekToken();
                if (!tok) {
                  this.fail("parseBlock: expected endblock, got end of file");
                }
                this.advanceAfterBlockEnd(tok.value);
                return node2;
              };
              _proto.parseExtends = function parseExtends() {
                var tagName = "extends";
                var tag = this.peekToken();
                if (!this.skipSymbol(tagName)) {
                  this.fail("parseTemplateRef: expected " + tagName);
                }
                var node2 = new nodes.Extends(tag.lineno, tag.colno);
                node2.template = this.parseExpression();
                this.advanceAfterBlockEnd(tag.value);
                return node2;
              };
              _proto.parseInclude = function parseInclude() {
                var tagName = "include";
                var tag = this.peekToken();
                if (!this.skipSymbol(tagName)) {
                  this.fail("parseInclude: expected " + tagName);
                }
                var node2 = new nodes.Include(tag.lineno, tag.colno);
                node2.template = this.parseExpression();
                if (this.skipSymbol("ignore") && this.skipSymbol("missing")) {
                  node2.ignoreMissing = true;
                }
                this.advanceAfterBlockEnd(tag.value);
                return node2;
              };
              _proto.parseIf = function parseIf() {
                var tag = this.peekToken();
                var node2;
                if (this.skipSymbol("if") || this.skipSymbol("elif") || this.skipSymbol("elseif")) {
                  node2 = new nodes.If(tag.lineno, tag.colno);
                } else if (this.skipSymbol("ifAsync")) {
                  node2 = new nodes.IfAsync(tag.lineno, tag.colno);
                } else {
                  this.fail("parseIf: expected if, elif, or elseif", tag.lineno, tag.colno);
                }
                node2.cond = this.parseExpression();
                this.advanceAfterBlockEnd(tag.value);
                node2.body = this.parseUntilBlocks("elif", "elseif", "else", "endif");
                var tok = this.peekToken();
                switch (tok && tok.value) {
                  case "elseif":
                  case "elif":
                    node2.else_ = this.parseIf();
                    break;
                  case "else":
                    this.advanceAfterBlockEnd();
                    node2.else_ = this.parseUntilBlocks("endif");
                    this.advanceAfterBlockEnd();
                    break;
                  case "endif":
                    node2.else_ = null;
                    this.advanceAfterBlockEnd();
                    break;
                  default:
                    this.fail("parseIf: expected elif, else, or endif, got end of file");
                }
                return node2;
              };
              _proto.parseSet = function parseSet() {
                var tag = this.peekToken();
                if (!this.skipSymbol("set")) {
                  this.fail("parseSet: expected set", tag.lineno, tag.colno);
                }
                var node2 = new nodes.Set(tag.lineno, tag.colno, []);
                var target;
                while (target = this.parsePrimary()) {
                  node2.targets.push(target);
                  if (!this.skip(lexer.TOKEN_COMMA)) {
                    break;
                  }
                }
                if (!this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
                  if (!this.skip(lexer.TOKEN_BLOCK_END)) {
                    this.fail("parseSet: expected = or block end in set tag", tag.lineno, tag.colno);
                  } else {
                    node2.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks("endset"));
                    node2.value = null;
                    this.advanceAfterBlockEnd();
                  }
                } else {
                  node2.value = this.parseExpression();
                  this.advanceAfterBlockEnd(tag.value);
                }
                return node2;
              };
              _proto.parseSwitch = function parseSwitch() {
                var switchStart = "switch";
                var switchEnd = "endswitch";
                var caseStart = "case";
                var caseDefault = "default";
                var tag = this.peekToken();
                if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
                  this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
                }
                var expr = this.parseExpression();
                this.advanceAfterBlockEnd(switchStart);
                this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
                var tok = this.peekToken();
                var cases = [];
                var defaultCase;
                do {
                  this.skipSymbol(caseStart);
                  var cond = this.parseExpression();
                  this.advanceAfterBlockEnd(switchStart);
                  var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
                  cases.push(new nodes.Case(tok.line, tok.col, cond, body));
                  tok = this.peekToken();
                } while (tok && tok.value === caseStart);
                switch (tok.value) {
                  case caseDefault:
                    this.advanceAfterBlockEnd();
                    defaultCase = this.parseUntilBlocks(switchEnd);
                    this.advanceAfterBlockEnd();
                    break;
                  case switchEnd:
                    this.advanceAfterBlockEnd();
                    break;
                  default:
                    this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
                }
                return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
              };
              _proto.parseStatement = function parseStatement() {
                var tok = this.peekToken();
                var node2;
                if (tok.type !== lexer.TOKEN_SYMBOL) {
                  this.fail("tag name expected", tok.lineno, tok.colno);
                }
                if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
                  return null;
                }
                switch (tok.value) {
                  case "raw":
                    return this.parseRaw();
                  case "verbatim":
                    return this.parseRaw("verbatim");
                  case "if":
                  case "ifAsync":
                    return this.parseIf();
                  case "for":
                  case "asyncEach":
                  case "asyncAll":
                    return this.parseFor();
                  case "block":
                    return this.parseBlock();
                  case "extends":
                    return this.parseExtends();
                  case "include":
                    return this.parseInclude();
                  case "set":
                    return this.parseSet();
                  case "macro":
                    return this.parseMacro();
                  case "call":
                    return this.parseCall();
                  case "import":
                    return this.parseImport();
                  case "from":
                    return this.parseFrom();
                  case "filter":
                    return this.parseFilterStatement();
                  case "switch":
                    return this.parseSwitch();
                  default:
                    if (this.extensions.length) {
                      for (var i4 = 0; i4 < this.extensions.length; i4++) {
                        var ext = this.extensions[i4];
                        if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
                          return ext.parse(this, nodes, lexer);
                        }
                      }
                    }
                    this.fail("unknown block tag: " + tok.value, tok.lineno, tok.colno);
                }
                return node2;
              };
              _proto.parseRaw = function parseRaw(tagName) {
                tagName = tagName || "raw";
                var endTagName = "end" + tagName;
                var rawBlockRegex = new RegExp("([\\s\\S]*?){%\\s*(" + tagName + "|" + endTagName + ")\\s*(?=%})%}");
                var rawLevel = 1;
                var str = "";
                var matches = null;
                var begun = this.advanceAfterBlockEnd();
                while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
                  var all = matches[0];
                  var pre = matches[1];
                  var blockName = matches[2];
                  if (blockName === tagName) {
                    rawLevel += 1;
                  } else if (blockName === endTagName) {
                    rawLevel -= 1;
                  }
                  if (rawLevel === 0) {
                    str += pre;
                    this.tokens.backN(all.length - pre.length);
                  } else {
                    str += all;
                  }
                }
                return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
              };
              _proto.parsePostfix = function parsePostfix(node2) {
                var lookup;
                var tok = this.peekToken();
                while (tok) {
                  if (tok.type === lexer.TOKEN_LEFT_PAREN) {
                    node2 = new nodes.FunCall(tok.lineno, tok.colno, node2, this.parseSignature());
                  } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
                    lookup = this.parseAggregate();
                    if (lookup.children.length > 1) {
                      this.fail("invalid index");
                    }
                    node2 = new nodes.LookupVal(tok.lineno, tok.colno, node2, lookup.children[0]);
                  } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === ".") {
                    this.nextToken();
                    var val = this.nextToken();
                    if (val.type !== lexer.TOKEN_SYMBOL) {
                      this.fail("expected name as lookup value, got " + val.value, val.lineno, val.colno);
                    }
                    lookup = new nodes.Literal(val.lineno, val.colno, val.value);
                    node2 = new nodes.LookupVal(tok.lineno, tok.colno, node2, lookup);
                  } else {
                    break;
                  }
                  tok = this.peekToken();
                }
                return node2;
              };
              _proto.parseExpression = function parseExpression2() {
                var node2 = this.parseInlineIf();
                return node2;
              };
              _proto.parseInlineIf = function parseInlineIf() {
                var node2 = this.parseOr();
                if (this.skipSymbol("if")) {
                  var condNode = this.parseOr();
                  var bodyNode = node2;
                  node2 = new nodes.InlineIf(node2.lineno, node2.colno);
                  node2.body = bodyNode;
                  node2.cond = condNode;
                  if (this.skipSymbol("else")) {
                    node2.else_ = this.parseOr();
                  } else {
                    node2.else_ = null;
                  }
                }
                return node2;
              };
              _proto.parseOr = function parseOr() {
                var node2 = this.parseAnd();
                while (this.skipSymbol("or")) {
                  var node22 = this.parseAnd();
                  node2 = new nodes.Or(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parseAnd = function parseAnd() {
                var node2 = this.parseNot();
                while (this.skipSymbol("and")) {
                  var node22 = this.parseNot();
                  node2 = new nodes.And(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parseNot = function parseNot() {
                var tok = this.peekToken();
                if (this.skipSymbol("not")) {
                  return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
                }
                return this.parseIn();
              };
              _proto.parseIn = function parseIn() {
                var node2 = this.parseIs();
                while (1) {
                  var tok = this.nextToken();
                  if (!tok) {
                    break;
                  }
                  var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === "not";
                  if (!invert) {
                    this.pushToken(tok);
                  }
                  if (this.skipSymbol("in")) {
                    var node22 = this.parseIs();
                    node2 = new nodes.In(node2.lineno, node2.colno, node2, node22);
                    if (invert) {
                      node2 = new nodes.Not(node2.lineno, node2.colno, node2);
                    }
                  } else {
                    if (invert) {
                      this.pushToken(tok);
                    }
                    break;
                  }
                }
                return node2;
              };
              _proto.parseIs = function parseIs() {
                var node2 = this.parseCompare();
                if (this.skipSymbol("is")) {
                  var not = this.skipSymbol("not");
                  var node22 = this.parseCompare();
                  node2 = new nodes.Is(node2.lineno, node2.colno, node2, node22);
                  if (not) {
                    node2 = new nodes.Not(node2.lineno, node2.colno, node2);
                  }
                }
                return node2;
              };
              _proto.parseCompare = function parseCompare() {
                var compareOps = ["==", "===", "!=", "!==", "<", ">", "<=", ">="];
                var expr = this.parseConcat();
                var ops = [];
                while (1) {
                  var tok = this.nextToken();
                  if (!tok) {
                    break;
                  } else if (compareOps.indexOf(tok.value) !== -1) {
                    ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
                  } else {
                    this.pushToken(tok);
                    break;
                  }
                }
                if (ops.length) {
                  return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
                } else {
                  return expr;
                }
              };
              _proto.parseConcat = function parseConcat() {
                var node2 = this.parseAdd();
                while (this.skipValue(lexer.TOKEN_TILDE, "~")) {
                  var node22 = this.parseAdd();
                  node2 = new nodes.Concat(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parseAdd = function parseAdd() {
                var node2 = this.parseSub();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
                  var node22 = this.parseSub();
                  node2 = new nodes.Add(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parseSub = function parseSub() {
                var node2 = this.parseMul();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
                  var node22 = this.parseMul();
                  node2 = new nodes.Sub(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parseMul = function parseMul() {
                var node2 = this.parseDiv();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "*")) {
                  var node22 = this.parseDiv();
                  node2 = new nodes.Mul(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parseDiv = function parseDiv() {
                var node2 = this.parseFloorDiv();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "/")) {
                  var node22 = this.parseFloorDiv();
                  node2 = new nodes.Div(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parseFloorDiv = function parseFloorDiv() {
                var node2 = this.parseMod();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "//")) {
                  var node22 = this.parseMod();
                  node2 = new nodes.FloorDiv(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parseMod = function parseMod() {
                var node2 = this.parsePow();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "%")) {
                  var node22 = this.parsePow();
                  node2 = new nodes.Mod(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parsePow = function parsePow() {
                var node2 = this.parseUnary();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "**")) {
                  var node22 = this.parseUnary();
                  node2 = new nodes.Pow(node2.lineno, node2.colno, node2, node22);
                }
                return node2;
              };
              _proto.parseUnary = function parseUnary(noFilters) {
                var tok = this.peekToken();
                var node2;
                if (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
                  node2 = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
                } else if (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
                  node2 = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
                } else {
                  node2 = this.parsePrimary();
                }
                if (!noFilters) {
                  node2 = this.parseFilter(node2);
                }
                return node2;
              };
              _proto.parsePrimary = function parsePrimary(noPostfix) {
                var tok = this.nextToken();
                var val;
                var node2 = null;
                if (!tok) {
                  this.fail("expected expression, got end of file");
                } else if (tok.type === lexer.TOKEN_STRING) {
                  val = tok.value;
                } else if (tok.type === lexer.TOKEN_INT) {
                  val = parseInt(tok.value, 10);
                } else if (tok.type === lexer.TOKEN_FLOAT) {
                  val = parseFloat(tok.value);
                } else if (tok.type === lexer.TOKEN_BOOLEAN) {
                  if (tok.value === "true") {
                    val = true;
                  } else if (tok.value === "false") {
                    val = false;
                  } else {
                    this.fail("invalid boolean: " + tok.value, tok.lineno, tok.colno);
                  }
                } else if (tok.type === lexer.TOKEN_NONE) {
                  val = null;
                } else if (tok.type === lexer.TOKEN_REGEX) {
                  val = new RegExp(tok.value.body, tok.value.flags);
                }
                if (val !== void 0) {
                  node2 = new nodes.Literal(tok.lineno, tok.colno, val);
                } else if (tok.type === lexer.TOKEN_SYMBOL) {
                  node2 = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
                } else {
                  this.pushToken(tok);
                  node2 = this.parseAggregate();
                }
                if (!noPostfix) {
                  node2 = this.parsePostfix(node2);
                }
                if (node2) {
                  return node2;
                } else {
                  throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
                }
              };
              _proto.parseFilterName = function parseFilterName() {
                var tok = this.expect(lexer.TOKEN_SYMBOL);
                var name = tok.value;
                while (this.skipValue(lexer.TOKEN_OPERATOR, ".")) {
                  name += "." + this.expect(lexer.TOKEN_SYMBOL).value;
                }
                return new nodes.Symbol(tok.lineno, tok.colno, name);
              };
              _proto.parseFilterArgs = function parseFilterArgs(node2) {
                if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
                  var call = this.parsePostfix(node2);
                  return call.args.children;
                }
                return [];
              };
              _proto.parseFilter = function parseFilter(node2) {
                while (this.skip(lexer.TOKEN_PIPE)) {
                  var name = this.parseFilterName();
                  node2 = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node2].concat(this.parseFilterArgs(node2))));
                }
                return node2;
              };
              _proto.parseFilterStatement = function parseFilterStatement() {
                var filterTok = this.peekToken();
                if (!this.skipSymbol("filter")) {
                  this.fail("parseFilterStatement: expected filter");
                }
                var name = this.parseFilterName();
                var args2 = this.parseFilterArgs(name);
                this.advanceAfterBlockEnd(filterTok.value);
                var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks("endfilter"));
                this.advanceAfterBlockEnd();
                var node2 = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args2)));
                return new nodes.Output(name.lineno, name.colno, [node2]);
              };
              _proto.parseAggregate = function parseAggregate() {
                var tok = this.nextToken();
                var node2;
                switch (tok.type) {
                  case lexer.TOKEN_LEFT_PAREN:
                    node2 = new nodes.Group(tok.lineno, tok.colno);
                    break;
                  case lexer.TOKEN_LEFT_BRACKET:
                    node2 = new nodes.Array(tok.lineno, tok.colno);
                    break;
                  case lexer.TOKEN_LEFT_CURLY:
                    node2 = new nodes.Dict(tok.lineno, tok.colno);
                    break;
                  default:
                    return null;
                }
                while (1) {
                  var type = this.peekToken().type;
                  if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
                    this.nextToken();
                    break;
                  }
                  if (node2.children.length > 0) {
                    if (!this.skip(lexer.TOKEN_COMMA)) {
                      this.fail("parseAggregate: expected comma after expression", tok.lineno, tok.colno);
                    }
                  }
                  if (node2 instanceof nodes.Dict) {
                    var key = this.parsePrimary();
                    if (!this.skip(lexer.TOKEN_COLON)) {
                      this.fail("parseAggregate: expected colon after dict key", tok.lineno, tok.colno);
                    }
                    var value = this.parseExpression();
                    node2.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
                  } else {
                    var expr = this.parseExpression();
                    node2.addChild(expr);
                  }
                }
                return node2;
              };
              _proto.parseSignature = function parseSignature(tolerant, noParens) {
                var tok = this.peekToken();
                if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
                  if (tolerant) {
                    return null;
                  } else {
                    this.fail("expected arguments", tok.lineno, tok.colno);
                  }
                }
                if (tok.type === lexer.TOKEN_LEFT_PAREN) {
                  tok = this.nextToken();
                }
                var args2 = new nodes.NodeList(tok.lineno, tok.colno);
                var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
                var checkComma = false;
                while (1) {
                  tok = this.peekToken();
                  if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
                    this.nextToken();
                    break;
                  } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
                    break;
                  }
                  if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
                    this.fail("parseSignature: expected comma after expression", tok.lineno, tok.colno);
                  } else {
                    var arg = this.parseExpression();
                    if (this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
                      kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
                    } else {
                      args2.addChild(arg);
                    }
                  }
                  checkComma = true;
                }
                if (kwargs.children.length) {
                  args2.addChild(kwargs);
                }
                return args2;
              };
              _proto.parseUntilBlocks = function parseUntilBlocks() {
                var prev2 = this.breakOnBlocks;
                for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
                  blockNames[_key] = arguments[_key];
                }
                this.breakOnBlocks = blockNames;
                var ret = this.parse();
                this.breakOnBlocks = prev2;
                return ret;
              };
              _proto.parseNodes = function parseNodes() {
                var tok;
                var buf = [];
                while (tok = this.nextToken()) {
                  if (tok.type === lexer.TOKEN_DATA) {
                    var data = tok.value;
                    var nextToken = this.peekToken();
                    var nextVal = nextToken && nextToken.value;
                    if (this.dropLeadingWhitespace) {
                      data = data.replace(/^\s*/, "");
                      this.dropLeadingWhitespace = false;
                    }
                    if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === "-" || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === "-" || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === "-")) {
                      data = data.replace(/\s*$/, "");
                    }
                    buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
                  } else if (tok.type === lexer.TOKEN_BLOCK_START) {
                    this.dropLeadingWhitespace = false;
                    var n3 = this.parseStatement();
                    if (!n3) {
                      break;
                    }
                    buf.push(n3);
                  } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
                    var e3 = this.parseExpression();
                    this.dropLeadingWhitespace = false;
                    this.advanceAfterVariableEnd();
                    buf.push(new nodes.Output(tok.lineno, tok.colno, [e3]));
                  } else if (tok.type === lexer.TOKEN_COMMENT) {
                    this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === "-";
                  } else {
                    this.fail("Unexpected token at top-level: " + tok.type, tok.lineno, tok.colno);
                  }
                }
                return buf;
              };
              _proto.parse = function parse3() {
                return new nodes.NodeList(0, 0, this.parseNodes());
              };
              _proto.parseAsRoot = function parseAsRoot() {
                return new nodes.Root(0, 0, this.parseNodes());
              };
              return Parser2;
            }(Obj);
            module3.exports = {
              parse: function parse3(src, extensions, opts) {
                var p5 = new Parser(lexer.lex(src, opts));
                if (extensions !== void 0) {
                  p5.extensions = extensions;
                }
                return p5.parseAsRoot();
              },
              Parser
            };
          },
          /* 9 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var whitespaceChars = " \n	\r\xA0";
            var delimChars = "()[]{}%*-+~/#,:|.<>=!";
            var intChars = "0123456789";
            var BLOCK_START = "{%";
            var BLOCK_END = "%}";
            var VARIABLE_START = "{{";
            var VARIABLE_END = "}}";
            var COMMENT_START = "{#";
            var COMMENT_END = "#}";
            var TOKEN_STRING = "string";
            var TOKEN_WHITESPACE = "whitespace";
            var TOKEN_DATA = "data";
            var TOKEN_BLOCK_START = "block-start";
            var TOKEN_BLOCK_END = "block-end";
            var TOKEN_VARIABLE_START = "variable-start";
            var TOKEN_VARIABLE_END = "variable-end";
            var TOKEN_COMMENT = "comment";
            var TOKEN_LEFT_PAREN = "left-paren";
            var TOKEN_RIGHT_PAREN = "right-paren";
            var TOKEN_LEFT_BRACKET = "left-bracket";
            var TOKEN_RIGHT_BRACKET = "right-bracket";
            var TOKEN_LEFT_CURLY = "left-curly";
            var TOKEN_RIGHT_CURLY = "right-curly";
            var TOKEN_OPERATOR = "operator";
            var TOKEN_COMMA = "comma";
            var TOKEN_COLON = "colon";
            var TOKEN_TILDE = "tilde";
            var TOKEN_PIPE = "pipe";
            var TOKEN_INT = "int";
            var TOKEN_FLOAT = "float";
            var TOKEN_BOOLEAN = "boolean";
            var TOKEN_NONE = "none";
            var TOKEN_SYMBOL = "symbol";
            var TOKEN_SPECIAL = "special";
            var TOKEN_REGEX = "regex";
            function token2(type, value, lineno, colno) {
              return {
                type,
                value,
                lineno,
                colno
              };
            }
            var Tokenizer = /* @__PURE__ */ function() {
              function Tokenizer2(str, opts) {
                this.str = str;
                this.index = 0;
                this.len = str.length;
                this.lineno = 0;
                this.colno = 0;
                this.in_code = false;
                opts = opts || {};
                var tags = opts.tags || {};
                this.tags = {
                  BLOCK_START: tags.blockStart || BLOCK_START,
                  BLOCK_END: tags.blockEnd || BLOCK_END,
                  VARIABLE_START: tags.variableStart || VARIABLE_START,
                  VARIABLE_END: tags.variableEnd || VARIABLE_END,
                  COMMENT_START: tags.commentStart || COMMENT_START,
                  COMMENT_END: tags.commentEnd || COMMENT_END
                };
                this.trimBlocks = !!opts.trimBlocks;
                this.lstripBlocks = !!opts.lstripBlocks;
              }
              var _proto = Tokenizer2.prototype;
              _proto.nextToken = function nextToken() {
                var lineno = this.lineno;
                var colno = this.colno;
                var tok;
                if (this.in_code) {
                  var cur = this.current();
                  if (this.isFinished()) {
                    return null;
                  } else if (cur === '"' || cur === "'") {
                    return token2(TOKEN_STRING, this._parseString(cur), lineno, colno);
                  } else if (tok = this._extract(whitespaceChars)) {
                    return token2(TOKEN_WHITESPACE, tok, lineno, colno);
                  } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString("-" + this.tags.BLOCK_END))) {
                    this.in_code = false;
                    if (this.trimBlocks) {
                      cur = this.current();
                      if (cur === "\n") {
                        this.forward();
                      } else if (cur === "\r") {
                        this.forward();
                        cur = this.current();
                        if (cur === "\n") {
                          this.forward();
                        } else {
                          this.back();
                        }
                      }
                    }
                    return token2(TOKEN_BLOCK_END, tok, lineno, colno);
                  } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString("-" + this.tags.VARIABLE_END))) {
                    this.in_code = false;
                    return token2(TOKEN_VARIABLE_END, tok, lineno, colno);
                  } else if (cur === "r" && this.str.charAt(this.index + 1) === "/") {
                    this.forwardN(2);
                    var regexBody = "";
                    while (!this.isFinished()) {
                      if (this.current() === "/" && this.previous() !== "\\") {
                        this.forward();
                        break;
                      } else {
                        regexBody += this.current();
                        this.forward();
                      }
                    }
                    var POSSIBLE_FLAGS = ["g", "i", "m", "y"];
                    var regexFlags = "";
                    while (!this.isFinished()) {
                      var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
                      if (isCurrentAFlag) {
                        regexFlags += this.current();
                        this.forward();
                      } else {
                        break;
                      }
                    }
                    return token2(TOKEN_REGEX, {
                      body: regexBody,
                      flags: regexFlags
                    }, lineno, colno);
                  } else if (delimChars.indexOf(cur) !== -1) {
                    this.forward();
                    var complexOps = ["==", "===", "!=", "!==", "<=", ">=", "//", "**"];
                    var curComplex = cur + this.current();
                    var type;
                    if (lib.indexOf(complexOps, curComplex) !== -1) {
                      this.forward();
                      cur = curComplex;
                      if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
                        cur = curComplex + this.current();
                        this.forward();
                      }
                    }
                    switch (cur) {
                      case "(":
                        type = TOKEN_LEFT_PAREN;
                        break;
                      case ")":
                        type = TOKEN_RIGHT_PAREN;
                        break;
                      case "[":
                        type = TOKEN_LEFT_BRACKET;
                        break;
                      case "]":
                        type = TOKEN_RIGHT_BRACKET;
                        break;
                      case "{":
                        type = TOKEN_LEFT_CURLY;
                        break;
                      case "}":
                        type = TOKEN_RIGHT_CURLY;
                        break;
                      case ",":
                        type = TOKEN_COMMA;
                        break;
                      case ":":
                        type = TOKEN_COLON;
                        break;
                      case "~":
                        type = TOKEN_TILDE;
                        break;
                      case "|":
                        type = TOKEN_PIPE;
                        break;
                      default:
                        type = TOKEN_OPERATOR;
                    }
                    return token2(type, cur, lineno, colno);
                  } else {
                    tok = this._extractUntil(whitespaceChars + delimChars);
                    if (tok.match(/^[-+]?[0-9]+$/)) {
                      if (this.current() === ".") {
                        this.forward();
                        var dec = this._extract(intChars);
                        return token2(TOKEN_FLOAT, tok + "." + dec, lineno, colno);
                      } else {
                        return token2(TOKEN_INT, tok, lineno, colno);
                      }
                    } else if (tok.match(/^(true|false)$/)) {
                      return token2(TOKEN_BOOLEAN, tok, lineno, colno);
                    } else if (tok === "none") {
                      return token2(TOKEN_NONE, tok, lineno, colno);
                    } else if (tok === "null") {
                      return token2(TOKEN_NONE, tok, lineno, colno);
                    } else if (tok) {
                      return token2(TOKEN_SYMBOL, tok, lineno, colno);
                    } else {
                      throw new Error("Unexpected value while parsing: " + tok);
                    }
                  }
                } else {
                  var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);
                  if (this.isFinished()) {
                    return null;
                  } else if ((tok = this._extractString(this.tags.BLOCK_START + "-")) || (tok = this._extractString(this.tags.BLOCK_START))) {
                    this.in_code = true;
                    return token2(TOKEN_BLOCK_START, tok, lineno, colno);
                  } else if ((tok = this._extractString(this.tags.VARIABLE_START + "-")) || (tok = this._extractString(this.tags.VARIABLE_START))) {
                    this.in_code = true;
                    return token2(TOKEN_VARIABLE_START, tok, lineno, colno);
                  } else {
                    tok = "";
                    var data;
                    var inComment = false;
                    if (this._matches(this.tags.COMMENT_START)) {
                      inComment = true;
                      tok = this._extractString(this.tags.COMMENT_START);
                    }
                    while ((data = this._extractUntil(beginChars)) !== null) {
                      tok += data;
                      if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
                        if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
                          var lastLine = tok.slice(-this.colno);
                          if (/^\s+$/.test(lastLine)) {
                            tok = tok.slice(0, -this.colno);
                            if (!tok.length) {
                              return this.nextToken();
                            }
                          }
                        }
                        break;
                      } else if (this._matches(this.tags.COMMENT_END)) {
                        if (!inComment) {
                          throw new Error("unexpected end of comment");
                        }
                        tok += this._extractString(this.tags.COMMENT_END);
                        break;
                      } else {
                        tok += this.current();
                        this.forward();
                      }
                    }
                    if (data === null && inComment) {
                      throw new Error("expected end of comment, got end of file");
                    }
                    return token2(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
                  }
                }
              };
              _proto._parseString = function _parseString(delimiter2) {
                this.forward();
                var str = "";
                while (!this.isFinished() && this.current() !== delimiter2) {
                  var cur = this.current();
                  if (cur === "\\") {
                    this.forward();
                    switch (this.current()) {
                      case "n":
                        str += "\n";
                        break;
                      case "t":
                        str += "	";
                        break;
                      case "r":
                        str += "\r";
                        break;
                      default:
                        str += this.current();
                    }
                    this.forward();
                  } else {
                    str += cur;
                    this.forward();
                  }
                }
                this.forward();
                return str;
              };
              _proto._matches = function _matches(str) {
                if (this.index + str.length > this.len) {
                  return null;
                }
                var m4 = this.str.slice(this.index, this.index + str.length);
                return m4 === str;
              };
              _proto._extractString = function _extractString(str) {
                if (this._matches(str)) {
                  this.forwardN(str.length);
                  return str;
                }
                return null;
              };
              _proto._extractUntil = function _extractUntil(charString) {
                return this._extractMatching(true, charString || "");
              };
              _proto._extract = function _extract(charString) {
                return this._extractMatching(false, charString);
              };
              _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
                if (this.isFinished()) {
                  return null;
                }
                var first = charString.indexOf(this.current());
                if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
                  var t3 = this.current();
                  this.forward();
                  var idx = charString.indexOf(this.current());
                  while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
                    t3 += this.current();
                    this.forward();
                    idx = charString.indexOf(this.current());
                  }
                  return t3;
                }
                return "";
              };
              _proto._extractRegex = function _extractRegex(regex2) {
                var matches = this.currentStr().match(regex2);
                if (!matches) {
                  return null;
                }
                this.forwardN(matches[0].length);
                return matches;
              };
              _proto.isFinished = function isFinished() {
                return this.index >= this.len;
              };
              _proto.forwardN = function forwardN(n3) {
                for (var i4 = 0; i4 < n3; i4++) {
                  this.forward();
                }
              };
              _proto.forward = function forward() {
                this.index++;
                if (this.previous() === "\n") {
                  this.lineno++;
                  this.colno = 0;
                } else {
                  this.colno++;
                }
              };
              _proto.backN = function backN(n3) {
                for (var i4 = 0; i4 < n3; i4++) {
                  this.back();
                }
              };
              _proto.back = function back() {
                this.index--;
                if (this.current() === "\n") {
                  this.lineno--;
                  var idx = this.src.lastIndexOf("\n", this.index - 1);
                  if (idx === -1) {
                    this.colno = this.index;
                  } else {
                    this.colno = this.index - idx;
                  }
                } else {
                  this.colno--;
                }
              };
              _proto.current = function current() {
                if (!this.isFinished()) {
                  return this.str.charAt(this.index);
                }
                return "";
              };
              _proto.currentStr = function currentStr() {
                if (!this.isFinished()) {
                  return this.str.substr(this.index);
                }
                return "";
              };
              _proto.previous = function previous() {
                return this.str.charAt(this.index - 1);
              };
              return Tokenizer2;
            }();
            module3.exports = {
              lex: function lex(src, opts) {
                return new Tokenizer(src, opts);
              },
              TOKEN_STRING,
              TOKEN_WHITESPACE,
              TOKEN_DATA,
              TOKEN_BLOCK_START,
              TOKEN_BLOCK_END,
              TOKEN_VARIABLE_START,
              TOKEN_VARIABLE_END,
              TOKEN_COMMENT,
              TOKEN_LEFT_PAREN,
              TOKEN_RIGHT_PAREN,
              TOKEN_LEFT_BRACKET,
              TOKEN_RIGHT_BRACKET,
              TOKEN_LEFT_CURLY,
              TOKEN_RIGHT_CURLY,
              TOKEN_OPERATOR,
              TOKEN_COMMA,
              TOKEN_COLON,
              TOKEN_TILDE,
              TOKEN_PIPE,
              TOKEN_INT,
              TOKEN_FLOAT,
              TOKEN_BOOLEAN,
              TOKEN_NONE,
              TOKEN_SYMBOL,
              TOKEN_SPECIAL,
              TOKEN_REGEX
            };
          },
          /* 10 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf2(subClass, superClass);
            }
            function _setPrototypeOf2(o4, p5) {
              _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p6) {
                o5.__proto__ = p6;
                return o5;
              };
              return _setPrototypeOf2(o4, p5);
            }
            var Loader2 = __webpack_require__(6);
            var _require = __webpack_require__(19), PrecompiledLoader = _require.PrecompiledLoader;
            var WebLoader = /* @__PURE__ */ function(_Loader) {
              _inheritsLoose(WebLoader2, _Loader);
              function WebLoader2(baseURL, opts) {
                var _this;
                _this = _Loader.call(this) || this;
                _this.baseURL = baseURL || ".";
                opts = opts || {};
                _this.useCache = !!opts.useCache;
                _this.async = !!opts.async;
                return _this;
              }
              var _proto = WebLoader2.prototype;
              _proto.resolve = function resolve2(from2, to) {
                throw new Error("relative templates not support in the browser yet");
              };
              _proto.getSource = function getSource(name, cb) {
                var _this2 = this;
                var useCache = this.useCache;
                var result;
                this.fetch(this.baseURL + "/" + name, function(err, src) {
                  if (err) {
                    if (cb) {
                      cb(err.content);
                    } else if (err.status === 404) {
                      result = null;
                    } else {
                      throw err.content;
                    }
                  } else {
                    result = {
                      src,
                      path: name,
                      noCache: !useCache
                    };
                    _this2.emit("load", name, result);
                    if (cb) {
                      cb(null, result);
                    }
                  }
                });
                return result;
              };
              _proto.fetch = function fetch(url2, cb) {
                if (typeof window === "undefined") {
                  throw new Error("WebLoader can only by used in a browser");
                }
                var ajax = new XMLHttpRequest();
                var loading = true;
                ajax.onreadystatechange = function() {
                  if (ajax.readyState === 4 && loading) {
                    loading = false;
                    if (ajax.status === 0 || ajax.status === 200) {
                      cb(null, ajax.responseText);
                    } else {
                      cb({
                        status: ajax.status,
                        content: ajax.responseText
                      });
                    }
                  }
                };
                url2 += (url2.indexOf("?") === -1 ? "?" : "&") + "s=" + (/* @__PURE__ */ new Date()).getTime();
                ajax.open("GET", url2, this.async);
                ajax.send();
              };
              return WebLoader2;
            }(Loader2);
            module3.exports = {
              WebLoader,
              PrecompiledLoader
            };
          },
          /* 11 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var _require = __webpack_require__(7), Environment = _require.Environment, Template = _require.Template;
            var Loader2 = __webpack_require__(6);
            var loaders = __webpack_require__(10);
            var precompile = __webpack_require__(23);
            var compiler = __webpack_require__(5);
            var parser = __webpack_require__(8);
            var lexer = __webpack_require__(9);
            var runtime = __webpack_require__(2);
            var nodes = __webpack_require__(3);
            var installJinjaCompat = __webpack_require__(25);
            var e3;
            function configure(templatesPath, opts) {
              opts = opts || {};
              if (lib.isObject(templatesPath)) {
                opts = templatesPath;
                templatesPath = null;
              }
              var TemplateLoader;
              if (loaders.FileSystemLoader) {
                TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
                  watch: opts.watch,
                  noCache: opts.noCache
                });
              } else if (loaders.WebLoader) {
                TemplateLoader = new loaders.WebLoader(templatesPath, {
                  useCache: opts.web && opts.web.useCache,
                  async: opts.web && opts.web.async
                });
              }
              e3 = new Environment(TemplateLoader, opts);
              if (opts && opts.express) {
                e3.express(opts.express);
              }
              return e3;
            }
            module3.exports = {
              Environment,
              Template,
              Loader: Loader2,
              FileSystemLoader: loaders.FileSystemLoader,
              NodeResolveLoader: loaders.NodeResolveLoader,
              PrecompiledLoader: loaders.PrecompiledLoader,
              WebLoader: loaders.WebLoader,
              compiler,
              parser,
              lexer,
              runtime,
              lib,
              nodes,
              installJinjaCompat,
              configure,
              reset: function reset() {
                e3 = void 0;
              },
              compile: function compile2(src, env2, path8, eagerCompile) {
                if (!e3) {
                  configure();
                }
                return new Template(src, env2, path8, eagerCompile);
              },
              render: function render(name, ctx, cb) {
                if (!e3) {
                  configure();
                }
                return e3.render(name, ctx, cb);
              },
              renderString: function renderString(src, ctx, cb) {
                if (!e3) {
                  configure();
                }
                return e3.renderString(src, ctx, cb);
              },
              precompile: precompile ? precompile.precompile : void 0,
              precompileString: precompile ? precompile.precompileString : void 0
            };
          },
          /* 12 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var rawAsap = __webpack_require__(13);
            var freeTasks = [];
            var pendingErrors = [];
            var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
            function throwFirstError() {
              if (pendingErrors.length) {
                throw pendingErrors.shift();
              }
            }
            module3.exports = asap;
            function asap(task) {
              var rawTask;
              if (freeTasks.length) {
                rawTask = freeTasks.pop();
              } else {
                rawTask = new RawTask();
              }
              rawTask.task = task;
              rawAsap(rawTask);
            }
            function RawTask() {
              this.task = null;
            }
            RawTask.prototype.call = function() {
              try {
                this.task.call();
              } catch (error) {
                if (asap.onerror) {
                  asap.onerror(error);
                } else {
                  pendingErrors.push(error);
                  requestErrorThrow();
                }
              } finally {
                this.task = null;
                freeTasks[freeTasks.length] = this;
              }
            };
          },
          /* 13 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            (function(global2) {
              module3.exports = rawAsap;
              function rawAsap(task) {
                if (!queue.length) {
                  requestFlush();
                  flushing = true;
                }
                queue[queue.length] = task;
              }
              var queue = [];
              var flushing = false;
              var requestFlush;
              var index2 = 0;
              var capacity = 1024;
              function flush() {
                while (index2 < queue.length) {
                  var currentIndex = index2;
                  index2 = index2 + 1;
                  queue[currentIndex].call();
                  if (index2 > capacity) {
                    for (var scan = 0, newLength = queue.length - index2; scan < newLength; scan++) {
                      queue[scan] = queue[scan + index2];
                    }
                    queue.length -= index2;
                    index2 = 0;
                  }
                }
                queue.length = 0;
                index2 = 0;
                flushing = false;
              }
              var scope = typeof global2 !== "undefined" ? global2 : self;
              var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
              if (typeof BrowserMutationObserver === "function") {
                requestFlush = makeRequestCallFromMutationObserver(flush);
              } else {
                requestFlush = makeRequestCallFromTimer(flush);
              }
              rawAsap.requestFlush = requestFlush;
              function makeRequestCallFromMutationObserver(callback) {
                var toggle = 1;
                var observer = new BrowserMutationObserver(callback);
                var node2 = document.createTextNode("");
                observer.observe(node2, { characterData: true });
                return function requestCall() {
                  toggle = -toggle;
                  node2.data = toggle;
                };
              }
              function makeRequestCallFromTimer(callback) {
                return function requestCall() {
                  var timeoutHandle = setTimeout(handleTimer, 0);
                  var intervalHandle = setInterval(handleTimer, 50);
                  function handleTimer() {
                    clearTimeout(timeoutHandle);
                    clearInterval(intervalHandle);
                    callback();
                  }
                };
              }
              rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
            }).call(exports3, __webpack_require__(14));
          },
          /* 14 */
          /***/
          function(module3, exports3) {
            var g5;
            g5 = function() {
              return this;
            }();
            try {
              g5 = g5 || Function("return this")() || (1, eval)("this");
            } catch (e3) {
              if (typeof window === "object")
                g5 = window;
            }
            module3.exports = g5;
          },
          /* 15 */
          /***/
          function(module3, exports3, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(globals) {
              "use strict";
              var executeSync = function() {
                var args2 = Array.prototype.slice.call(arguments);
                if (typeof args2[0] === "function") {
                  args2[0].apply(null, args2.splice(1));
                }
              };
              var executeAsync = function(fn2) {
                if (typeof setImmediate === "function") {
                  setImmediate(fn2);
                } else if (typeof process !== "undefined" && process.nextTick) {
                  process.nextTick(fn2);
                } else {
                  setTimeout(fn2, 0);
                }
              };
              var makeIterator = function(tasks) {
                var makeCallback = function(index2) {
                  var fn2 = function() {
                    if (tasks.length) {
                      tasks[index2].apply(null, arguments);
                    }
                    return fn2.next();
                  };
                  fn2.next = function() {
                    return index2 < tasks.length - 1 ? makeCallback(index2 + 1) : null;
                  };
                  return fn2;
                };
                return makeCallback(0);
              };
              var _isArray = Array.isArray || function(maybeArray) {
                return Object.prototype.toString.call(maybeArray) === "[object Array]";
              };
              var waterfall = function(tasks, callback, forceAsync) {
                var nextTick = forceAsync ? executeAsync : executeSync;
                callback = callback || function() {
                };
                if (!_isArray(tasks)) {
                  var err = new Error("First argument to waterfall must be an array of functions");
                  return callback(err);
                }
                if (!tasks.length) {
                  return callback();
                }
                var wrapIterator = function(iterator) {
                  return function(err2) {
                    if (err2) {
                      callback.apply(null, arguments);
                      callback = function() {
                      };
                    } else {
                      var args2 = Array.prototype.slice.call(arguments, 1);
                      var next2 = iterator.next();
                      if (next2) {
                        args2.push(wrapIterator(next2));
                      } else {
                        args2.push(callback);
                      }
                      nextTick(function() {
                        iterator.apply(null, args2);
                      });
                    }
                  };
                };
                wrapIterator(makeIterator(tasks))();
              };
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                  return waterfall;
                }.apply(exports3, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof module3 !== "undefined" && module3.exports) {
                module3.exports = waterfall;
              } else {
                globals.waterfall = waterfall;
              }
            })(this);
          },
          /* 16 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var R3 = typeof Reflect === "object" ? Reflect : null;
            var ReflectApply = R3 && typeof R3.apply === "function" ? R3.apply : function ReflectApply2(target, receiver, args2) {
              return Function.prototype.apply.call(target, receiver, args2);
            };
            var ReflectOwnKeys;
            if (R3 && typeof R3.ownKeys === "function") {
              ReflectOwnKeys = R3.ownKeys;
            } else if (Object.getOwnPropertySymbols) {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
              };
            } else {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target);
              };
            }
            function ProcessEmitWarning(warning) {
              if (console && console.warn)
                console.warn(warning);
            }
            var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
              return value !== value;
            };
            function EventEmitter() {
              EventEmitter.init.call(this);
            }
            module3.exports = EventEmitter;
            module3.exports.once = once;
            EventEmitter.EventEmitter = EventEmitter;
            EventEmitter.prototype._events = void 0;
            EventEmitter.prototype._eventsCount = 0;
            EventEmitter.prototype._maxListeners = void 0;
            var defaultMaxListeners = 10;
            function checkListener(listener) {
              if (typeof listener !== "function") {
                throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
              }
            }
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
              enumerable: true,
              get: function() {
                return defaultMaxListeners;
              },
              set: function(arg) {
                if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                  throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                }
                defaultMaxListeners = arg;
              }
            });
            EventEmitter.init = function() {
              if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
              }
              this._maxListeners = this._maxListeners || void 0;
            };
            EventEmitter.prototype.setMaxListeners = function setMaxListeners(n3) {
              if (typeof n3 !== "number" || n3 < 0 || NumberIsNaN(n3)) {
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n3 + ".");
              }
              this._maxListeners = n3;
              return this;
            };
            function _getMaxListeners(that) {
              if (that._maxListeners === void 0)
                return EventEmitter.defaultMaxListeners;
              return that._maxListeners;
            }
            EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
              return _getMaxListeners(this);
            };
            EventEmitter.prototype.emit = function emit(type) {
              var args2 = [];
              for (var i4 = 1; i4 < arguments.length; i4++)
                args2.push(arguments[i4]);
              var doError = type === "error";
              var events = this._events;
              if (events !== void 0)
                doError = doError && events.error === void 0;
              else if (!doError)
                return false;
              if (doError) {
                var er;
                if (args2.length > 0)
                  er = args2[0];
                if (er instanceof Error) {
                  throw er;
                }
                var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                err.context = er;
                throw err;
              }
              var handler = events[type];
              if (handler === void 0)
                return false;
              if (typeof handler === "function") {
                ReflectApply(handler, this, args2);
              } else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i4 = 0; i4 < len; ++i4)
                  ReflectApply(listeners[i4], this, args2);
              }
              return true;
            };
            function _addListener(target, type, listener, prepend) {
              var m4;
              var events;
              var existing;
              checkListener(listener);
              events = target._events;
              if (events === void 0) {
                events = target._events = /* @__PURE__ */ Object.create(null);
                target._eventsCount = 0;
              } else {
                if (events.newListener !== void 0) {
                  target.emit(
                    "newListener",
                    type,
                    listener.listener ? listener.listener : listener
                  );
                  events = target._events;
                }
                existing = events[type];
              }
              if (existing === void 0) {
                existing = events[type] = listener;
                ++target._eventsCount;
              } else {
                if (typeof existing === "function") {
                  existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                } else if (prepend) {
                  existing.unshift(listener);
                } else {
                  existing.push(listener);
                }
                m4 = _getMaxListeners(target);
                if (m4 > 0 && existing.length > m4 && !existing.warned) {
                  existing.warned = true;
                  var w6 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                  w6.name = "MaxListenersExceededWarning";
                  w6.emitter = target;
                  w6.type = type;
                  w6.count = existing.length;
                  ProcessEmitWarning(w6);
                }
              }
              return target;
            }
            EventEmitter.prototype.addListener = function addListener(type, listener) {
              return _addListener(this, type, listener, false);
            };
            EventEmitter.prototype.on = EventEmitter.prototype.addListener;
            EventEmitter.prototype.prependListener = function prependListener(type, listener) {
              return _addListener(this, type, listener, true);
            };
            function onceWrapper() {
              if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                if (arguments.length === 0)
                  return this.listener.call(this.target);
                return this.listener.apply(this.target, arguments);
              }
            }
            function _onceWrap(target, type, listener) {
              var state = { fired: false, wrapFn: void 0, target, type, listener };
              var wrapped = onceWrapper.bind(state);
              wrapped.listener = listener;
              state.wrapFn = wrapped;
              return wrapped;
            }
            EventEmitter.prototype.once = function once2(type, listener) {
              checkListener(listener);
              this.on(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
              checkListener(listener);
              this.prependListener(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.removeListener = function removeListener(type, listener) {
              var list, events, position2, i4, originalListener;
              checkListener(listener);
              events = this._events;
              if (events === void 0)
                return this;
              list = events[type];
              if (list === void 0)
                return this;
              if (list === listener || list.listener === listener) {
                if (--this._eventsCount === 0)
                  this._events = /* @__PURE__ */ Object.create(null);
                else {
                  delete events[type];
                  if (events.removeListener)
                    this.emit("removeListener", type, list.listener || listener);
                }
              } else if (typeof list !== "function") {
                position2 = -1;
                for (i4 = list.length - 1; i4 >= 0; i4--) {
                  if (list[i4] === listener || list[i4].listener === listener) {
                    originalListener = list[i4].listener;
                    position2 = i4;
                    break;
                  }
                }
                if (position2 < 0)
                  return this;
                if (position2 === 0)
                  list.shift();
                else {
                  spliceOne(list, position2);
                }
                if (list.length === 1)
                  events[type] = list[0];
                if (events.removeListener !== void 0)
                  this.emit("removeListener", type, originalListener || listener);
              }
              return this;
            };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
              var listeners, events, i4;
              events = this._events;
              if (events === void 0)
                return this;
              if (events.removeListener === void 0) {
                if (arguments.length === 0) {
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                } else if (events[type] !== void 0) {
                  if (--this._eventsCount === 0)
                    this._events = /* @__PURE__ */ Object.create(null);
                  else
                    delete events[type];
                }
                return this;
              }
              if (arguments.length === 0) {
                var keys = Object.keys(events);
                var key;
                for (i4 = 0; i4 < keys.length; ++i4) {
                  key = keys[i4];
                  if (key === "removeListener")
                    continue;
                  this.removeAllListeners(key);
                }
                this.removeAllListeners("removeListener");
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
                return this;
              }
              listeners = events[type];
              if (typeof listeners === "function") {
                this.removeListener(type, listeners);
              } else if (listeners !== void 0) {
                for (i4 = listeners.length - 1; i4 >= 0; i4--) {
                  this.removeListener(type, listeners[i4]);
                }
              }
              return this;
            };
            function _listeners(target, type, unwrap) {
              var events = target._events;
              if (events === void 0)
                return [];
              var evlistener = events[type];
              if (evlistener === void 0)
                return [];
              if (typeof evlistener === "function")
                return unwrap ? [evlistener.listener || evlistener] : [evlistener];
              return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
            }
            EventEmitter.prototype.listeners = function listeners(type) {
              return _listeners(this, type, true);
            };
            EventEmitter.prototype.rawListeners = function rawListeners(type) {
              return _listeners(this, type, false);
            };
            EventEmitter.listenerCount = function(emitter, type) {
              if (typeof emitter.listenerCount === "function") {
                return emitter.listenerCount(type);
              } else {
                return listenerCount.call(emitter, type);
              }
            };
            EventEmitter.prototype.listenerCount = listenerCount;
            function listenerCount(type) {
              var events = this._events;
              if (events !== void 0) {
                var evlistener = events[type];
                if (typeof evlistener === "function") {
                  return 1;
                } else if (evlistener !== void 0) {
                  return evlistener.length;
                }
              }
              return 0;
            }
            EventEmitter.prototype.eventNames = function eventNames() {
              return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
            };
            function arrayClone(arr, n3) {
              var copy2 = new Array(n3);
              for (var i4 = 0; i4 < n3; ++i4)
                copy2[i4] = arr[i4];
              return copy2;
            }
            function spliceOne(list, index2) {
              for (; index2 + 1 < list.length; index2++)
                list[index2] = list[index2 + 1];
              list.pop();
            }
            function unwrapListeners(arr) {
              var ret = new Array(arr.length);
              for (var i4 = 0; i4 < ret.length; ++i4) {
                ret[i4] = arr[i4].listener || arr[i4];
              }
              return ret;
            }
            function once(emitter, name) {
              return new Promise(function(resolve2, reject2) {
                function errorListener(err) {
                  emitter.removeListener(name, resolver);
                  reject2(err);
                }
                function resolver() {
                  if (typeof emitter.removeListener === "function") {
                    emitter.removeListener("error", errorListener);
                  }
                  resolve2([].slice.call(arguments));
                }
                ;
                eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                if (name !== "error") {
                  addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                }
              });
            }
            function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
              if (typeof emitter.on === "function") {
                eventTargetAgnosticAddListener(emitter, "error", handler, flags);
              }
            }
            function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
              if (typeof emitter.on === "function") {
                if (flags.once) {
                  emitter.once(name, listener);
                } else {
                  emitter.on(name, listener);
                }
              } else if (typeof emitter.addEventListener === "function") {
                emitter.addEventListener(name, function wrapListener(arg) {
                  if (flags.once) {
                    emitter.removeEventListener(name, wrapListener);
                  }
                  listener(arg);
                });
              } else {
                throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
              }
            }
          },
          /* 17 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var nodes = __webpack_require__(3);
            var lib = __webpack_require__(0);
            var sym = 0;
            function gensym() {
              return "hole_" + sym++;
            }
            function mapCOW(arr, func) {
              var res = null;
              for (var i4 = 0; i4 < arr.length; i4++) {
                var item = func(arr[i4]);
                if (item !== arr[i4]) {
                  if (!res) {
                    res = arr.slice();
                  }
                  res[i4] = item;
                }
              }
              return res || arr;
            }
            function walk(ast, func, depthFirst) {
              if (!(ast instanceof nodes.Node)) {
                return ast;
              }
              if (!depthFirst) {
                var astT = func(ast);
                if (astT && astT !== ast) {
                  return astT;
                }
              }
              if (ast instanceof nodes.NodeList) {
                var children = mapCOW(ast.children, function(node2) {
                  return walk(node2, func, depthFirst);
                });
                if (children !== ast.children) {
                  ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
                }
              } else if (ast instanceof nodes.CallExtension) {
                var args2 = walk(ast.args, func, depthFirst);
                var contentArgs = mapCOW(ast.contentArgs, function(node2) {
                  return walk(node2, func, depthFirst);
                });
                if (args2 !== ast.args || contentArgs !== ast.contentArgs) {
                  ast = new nodes[ast.typename](ast.extName, ast.prop, args2, contentArgs);
                }
              } else {
                var props = ast.fields.map(function(field) {
                  return ast[field];
                });
                var propsT = mapCOW(props, function(prop) {
                  return walk(prop, func, depthFirst);
                });
                if (propsT !== props) {
                  ast = new nodes[ast.typename](ast.lineno, ast.colno);
                  propsT.forEach(function(prop, i4) {
                    ast[ast.fields[i4]] = prop;
                  });
                }
              }
              return depthFirst ? func(ast) || ast : ast;
            }
            function depthWalk(ast, func) {
              return walk(ast, func, true);
            }
            function _liftFilters(node2, asyncFilters, prop) {
              var children = [];
              var walked = depthWalk(prop ? node2[prop] : node2, function(descNode) {
                var symbol;
                if (descNode instanceof nodes.Block) {
                  return descNode;
                } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
                  symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
                  children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
                }
                return symbol;
              });
              if (prop) {
                node2[prop] = walked;
              } else {
                node2 = walked;
              }
              if (children.length) {
                children.push(node2);
                return new nodes.NodeList(node2.lineno, node2.colno, children);
              } else {
                return node2;
              }
            }
            function liftFilters(ast, asyncFilters) {
              return depthWalk(ast, function(node2) {
                if (node2 instanceof nodes.Output) {
                  return _liftFilters(node2, asyncFilters);
                } else if (node2 instanceof nodes.Set) {
                  return _liftFilters(node2, asyncFilters, "value");
                } else if (node2 instanceof nodes.For) {
                  return _liftFilters(node2, asyncFilters, "arr");
                } else if (node2 instanceof nodes.If) {
                  return _liftFilters(node2, asyncFilters, "cond");
                } else if (node2 instanceof nodes.CallExtension) {
                  return _liftFilters(node2, asyncFilters, "args");
                } else {
                  return void 0;
                }
              });
            }
            function liftSuper(ast) {
              return walk(ast, function(blockNode) {
                if (!(blockNode instanceof nodes.Block)) {
                  return;
                }
                var hasSuper = false;
                var symbol = gensym();
                blockNode.body = walk(blockNode.body, function(node2) {
                  if (node2 instanceof nodes.FunCall && node2.name.value === "super") {
                    hasSuper = true;
                    return new nodes.Symbol(node2.lineno, node2.colno, symbol);
                  }
                });
                if (hasSuper) {
                  blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
                }
              });
            }
            function convertStatements(ast) {
              return depthWalk(ast, function(node2) {
                if (!(node2 instanceof nodes.If) && !(node2 instanceof nodes.For)) {
                  return void 0;
                }
                var async = false;
                walk(node2, function(child) {
                  if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
                    async = true;
                    return child;
                  }
                  return void 0;
                });
                if (async) {
                  if (node2 instanceof nodes.If) {
                    return new nodes.IfAsync(node2.lineno, node2.colno, node2.cond, node2.body, node2.else_);
                  } else if (node2 instanceof nodes.For && !(node2 instanceof nodes.AsyncAll)) {
                    return new nodes.AsyncEach(node2.lineno, node2.colno, node2.arr, node2.name, node2.body, node2.else_);
                  }
                }
                return void 0;
              });
            }
            function cps(ast, asyncFilters) {
              return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
            }
            function transform(ast, asyncFilters) {
              return cps(ast, asyncFilters || []);
            }
            module3.exports = {
              transform
            };
          },
          /* 18 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var r5 = __webpack_require__(2);
            var exports3 = module3.exports = {};
            function normalize(value, defaultValue) {
              if (value === null || value === void 0 || value === false) {
                return defaultValue;
              }
              return value;
            }
            exports3.abs = Math.abs;
            function isNaN2(num) {
              return num !== num;
            }
            function batch(arr, linecount, fillWith) {
              var i4;
              var res = [];
              var tmp = [];
              for (i4 = 0; i4 < arr.length; i4++) {
                if (i4 % linecount === 0 && tmp.length) {
                  res.push(tmp);
                  tmp = [];
                }
                tmp.push(arr[i4]);
              }
              if (tmp.length) {
                if (fillWith) {
                  for (i4 = tmp.length; i4 < linecount; i4++) {
                    tmp.push(fillWith);
                  }
                }
                res.push(tmp);
              }
              return res;
            }
            exports3.batch = batch;
            function capitalize(str) {
              str = normalize(str, "");
              var ret = str.toLowerCase();
              return r5.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
            }
            exports3.capitalize = capitalize;
            function center(str, width) {
              str = normalize(str, "");
              width = width || 80;
              if (str.length >= width) {
                return str;
              }
              var spaces = width - str.length;
              var pre = lib.repeat(" ", spaces / 2 - spaces % 2);
              var post = lib.repeat(" ", spaces / 2);
              return r5.copySafeness(str, pre + str + post);
            }
            exports3.center = center;
            function default_(val, def, bool) {
              if (bool) {
                return val || def;
              } else {
                return val !== void 0 ? val : def;
              }
            }
            exports3["default"] = default_;
            function dictsort(val, caseSensitive, by) {
              if (!lib.isObject(val)) {
                throw new lib.TemplateError("dictsort filter: val must be an object");
              }
              var array = [];
              for (var k4 in val) {
                array.push([k4, val[k4]]);
              }
              var si;
              if (by === void 0 || by === "key") {
                si = 0;
              } else if (by === "value") {
                si = 1;
              } else {
                throw new lib.TemplateError("dictsort filter: You can only sort by either key or value");
              }
              array.sort(function(t1, t22) {
                var a3 = t1[si];
                var b4 = t22[si];
                if (!caseSensitive) {
                  if (lib.isString(a3)) {
                    a3 = a3.toUpperCase();
                  }
                  if (lib.isString(b4)) {
                    b4 = b4.toUpperCase();
                  }
                }
                return a3 > b4 ? 1 : a3 === b4 ? 0 : -1;
              });
              return array;
            }
            exports3.dictsort = dictsort;
            function dump(obj, spaces) {
              return JSON.stringify(obj, null, spaces);
            }
            exports3.dump = dump;
            function escape(str) {
              if (str instanceof r5.SafeString) {
                return str;
              }
              str = str === null || str === void 0 ? "" : str;
              return r5.markSafe(lib.escape(str.toString()));
            }
            exports3.escape = escape;
            function safe(str) {
              if (str instanceof r5.SafeString) {
                return str;
              }
              str = str === null || str === void 0 ? "" : str;
              return r5.markSafe(str.toString());
            }
            exports3.safe = safe;
            function first(arr) {
              return arr[0];
            }
            exports3.first = first;
            function forceescape(str) {
              str = str === null || str === void 0 ? "" : str;
              return r5.markSafe(lib.escape(str.toString()));
            }
            exports3.forceescape = forceescape;
            function groupby(arr, attr) {
              return lib.groupBy(arr, attr, this.env.opts.throwOnUndefined);
            }
            exports3.groupby = groupby;
            function indent(str, width, indentfirst) {
              str = normalize(str, "");
              if (str === "") {
                return "";
              }
              width = width || 4;
              var lines = str.split("\n");
              var sp = lib.repeat(" ", width);
              var res = lines.map(function(l4, i4) {
                return i4 === 0 && !indentfirst ? l4 : "" + sp + l4;
              }).join("\n");
              return r5.copySafeness(str, res);
            }
            exports3.indent = indent;
            function join(arr, del, attr) {
              del = del || "";
              if (attr) {
                arr = lib.map(arr, function(v4) {
                  return v4[attr];
                });
              }
              return arr.join(del);
            }
            exports3.join = join;
            function last(arr) {
              return arr[arr.length - 1];
            }
            exports3.last = last;
            function lengthFilter(val) {
              var value = normalize(val, "");
              if (value !== void 0) {
                if (typeof Map === "function" && value instanceof Map || typeof Set === "function" && value instanceof Set) {
                  return value.size;
                }
                if (lib.isObject(value) && !(value instanceof r5.SafeString)) {
                  return lib.keys(value).length;
                }
                return value.length;
              }
              return 0;
            }
            exports3.length = lengthFilter;
            function list(val) {
              if (lib.isString(val)) {
                return val.split("");
              } else if (lib.isObject(val)) {
                return lib._entries(val || {}).map(function(_ref3) {
                  var key = _ref3[0], value = _ref3[1];
                  return {
                    key,
                    value
                  };
                });
              } else if (lib.isArray(val)) {
                return val;
              } else {
                throw new lib.TemplateError("list filter: type not iterable");
              }
            }
            exports3.list = list;
            function lower(str) {
              str = normalize(str, "");
              return str.toLowerCase();
            }
            exports3.lower = lower;
            function nl2br(str) {
              if (str === null || str === void 0) {
                return "";
              }
              return r5.copySafeness(str, str.replace(/\r\n|\n/g, "<br />\n"));
            }
            exports3.nl2br = nl2br;
            function random(arr) {
              return arr[Math.floor(Math.random() * arr.length)];
            }
            exports3.random = random;
            function getSelectOrReject(expectedTestResult) {
              function filter(arr, testName, secondArg) {
                if (testName === void 0) {
                  testName = "truthy";
                }
                var context = this;
                var test = context.env.getTest(testName);
                return lib.toArray(arr).filter(function examineTestResult(item) {
                  return test.call(context, item, secondArg) === expectedTestResult;
                });
              }
              return filter;
            }
            exports3.reject = getSelectOrReject(false);
            function rejectattr(arr, attr) {
              return arr.filter(function(item) {
                return !item[attr];
              });
            }
            exports3.rejectattr = rejectattr;
            exports3.select = getSelectOrReject(true);
            function selectattr(arr, attr) {
              return arr.filter(function(item) {
                return !!item[attr];
              });
            }
            exports3.selectattr = selectattr;
            function replace2(str, old, new_, maxCount) {
              var originalStr = str;
              if (old instanceof RegExp) {
                return str.replace(old, new_);
              }
              if (typeof maxCount === "undefined") {
                maxCount = -1;
              }
              var res = "";
              if (typeof old === "number") {
                old = "" + old;
              } else if (typeof old !== "string") {
                return str;
              }
              if (typeof str === "number") {
                str = "" + str;
              }
              if (typeof str !== "string" && !(str instanceof r5.SafeString)) {
                return str;
              }
              if (old === "") {
                res = new_ + str.split("").join(new_) + new_;
                return r5.copySafeness(str, res);
              }
              var nextIndex = str.indexOf(old);
              if (maxCount === 0 || nextIndex === -1) {
                return str;
              }
              var pos = 0;
              var count = 0;
              while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
                res += str.substring(pos, nextIndex) + new_;
                pos = nextIndex + old.length;
                count++;
                nextIndex = str.indexOf(old, pos);
              }
              if (pos < str.length) {
                res += str.substring(pos);
              }
              return r5.copySafeness(originalStr, res);
            }
            exports3.replace = replace2;
            function reverse(val) {
              var arr;
              if (lib.isString(val)) {
                arr = list(val);
              } else {
                arr = lib.map(val, function(v4) {
                  return v4;
                });
              }
              arr.reverse();
              if (lib.isString(val)) {
                return r5.copySafeness(val, arr.join(""));
              }
              return arr;
            }
            exports3.reverse = reverse;
            function round(val, precision, method) {
              precision = precision || 0;
              var factor = Math.pow(10, precision);
              var rounder;
              if (method === "ceil") {
                rounder = Math.ceil;
              } else if (method === "floor") {
                rounder = Math.floor;
              } else {
                rounder = Math.round;
              }
              return rounder(val * factor) / factor;
            }
            exports3.round = round;
            function slice2(arr, slices, fillWith) {
              var sliceLength = Math.floor(arr.length / slices);
              var extra = arr.length % slices;
              var res = [];
              var offset = 0;
              for (var i4 = 0; i4 < slices; i4++) {
                var start = offset + i4 * sliceLength;
                if (i4 < extra) {
                  offset++;
                }
                var end = offset + (i4 + 1) * sliceLength;
                var currSlice = arr.slice(start, end);
                if (fillWith && i4 >= extra) {
                  currSlice.push(fillWith);
                }
                res.push(currSlice);
              }
              return res;
            }
            exports3.slice = slice2;
            function sum(arr, attr, start) {
              if (start === void 0) {
                start = 0;
              }
              if (attr) {
                arr = lib.map(arr, function(v4) {
                  return v4[attr];
                });
              }
              return start + arr.reduce(function(a3, b4) {
                return a3 + b4;
              }, 0);
            }
            exports3.sum = sum;
            exports3.sort = r5.makeMacro(["value", "reverse", "case_sensitive", "attribute"], [], function sortFilter(arr, reversed, caseSens, attr) {
              var _this = this;
              var array = lib.map(arr, function(v4) {
                return v4;
              });
              var getAttribute = lib.getAttrGetter(attr);
              array.sort(function(a3, b4) {
                var x5 = attr ? getAttribute(a3) : a3;
                var y4 = attr ? getAttribute(b4) : b4;
                if (_this.env.opts.throwOnUndefined && attr && (x5 === void 0 || y4 === void 0)) {
                  throw new TypeError('sort: attribute "' + attr + '" resolved to undefined');
                }
                if (!caseSens && lib.isString(x5) && lib.isString(y4)) {
                  x5 = x5.toLowerCase();
                  y4 = y4.toLowerCase();
                }
                if (x5 < y4) {
                  return reversed ? 1 : -1;
                } else if (x5 > y4) {
                  return reversed ? -1 : 1;
                } else {
                  return 0;
                }
              });
              return array;
            });
            function string(obj) {
              return r5.copySafeness(obj, obj);
            }
            exports3.string = string;
            function striptags(input, preserveLinebreaks) {
              input = normalize(input, "");
              var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
              var trimmedInput = trim2(input.replace(tags, ""));
              var res = "";
              if (preserveLinebreaks) {
                res = trimmedInput.replace(/^ +| +$/gm, "").replace(/ +/g, " ").replace(/(\r\n)/g, "\n").replace(/\n\n\n+/g, "\n\n");
              } else {
                res = trimmedInput.replace(/\s+/gi, " ");
              }
              return r5.copySafeness(input, res);
            }
            exports3.striptags = striptags;
            function title(str) {
              str = normalize(str, "");
              var words = str.split(" ").map(function(word) {
                return capitalize(word);
              });
              return r5.copySafeness(str, words.join(" "));
            }
            exports3.title = title;
            function trim2(str) {
              return r5.copySafeness(str, str.replace(/^\s*|\s*$/g, ""));
            }
            exports3.trim = trim2;
            function truncate(input, length2, killwords, end) {
              var orig = input;
              input = normalize(input, "");
              length2 = length2 || 255;
              if (input.length <= length2) {
                return input;
              }
              if (killwords) {
                input = input.substring(0, length2);
              } else {
                var idx = input.lastIndexOf(" ", length2);
                if (idx === -1) {
                  idx = length2;
                }
                input = input.substring(0, idx);
              }
              input += end !== void 0 && end !== null ? end : "...";
              return r5.copySafeness(orig, input);
            }
            exports3.truncate = truncate;
            function upper(str) {
              str = normalize(str, "");
              return str.toUpperCase();
            }
            exports3.upper = upper;
            function urlencode(obj) {
              var enc = encodeURIComponent;
              if (lib.isString(obj)) {
                return enc(obj);
              } else {
                var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
                return keyvals.map(function(_ref23) {
                  var k4 = _ref23[0], v4 = _ref23[1];
                  return enc(k4) + "=" + enc(v4);
                }).join("&");
              }
            }
            exports3.urlencode = urlencode;
            var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
            var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
            var httpHttpsRe = /^https?:\/\/.*$/;
            var wwwRe = /^www\./;
            var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;
            function urlize(str, length2, nofollow) {
              if (isNaN2(length2)) {
                length2 = Infinity;
              }
              var noFollowAttr = nofollow === true ? ' rel="nofollow"' : "";
              var words = str.split(/(\s+)/).filter(function(word) {
                return word && word.length;
              }).map(function(word) {
                var matches = word.match(puncRe);
                var possibleUrl = matches ? matches[1] : word;
                var shortUrl = possibleUrl.substr(0, length2);
                if (httpHttpsRe.test(possibleUrl)) {
                  return '<a href="' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
                }
                if (wwwRe.test(possibleUrl)) {
                  return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
                }
                if (emailRe.test(possibleUrl)) {
                  return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + "</a>";
                }
                if (tldRe.test(possibleUrl)) {
                  return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
                }
                return word;
              });
              return words.join("");
            }
            exports3.urlize = urlize;
            function wordcount(str) {
              str = normalize(str, "");
              var words = str ? str.match(/\w+/g) : null;
              return words ? words.length : null;
            }
            exports3.wordcount = wordcount;
            function float(val, def) {
              var res = parseFloat(val);
              return isNaN2(res) ? def : res;
            }
            exports3.float = float;
            var intFilter = r5.makeMacro(["value", "default", "base"], [], function doInt(value, defaultValue, base) {
              if (base === void 0) {
                base = 10;
              }
              var res = parseInt(value, base);
              return isNaN2(res) ? defaultValue : res;
            });
            exports3.int = intFilter;
            exports3.d = exports3.default;
            exports3.e = exports3.escape;
          },
          /* 19 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf2(subClass, superClass);
            }
            function _setPrototypeOf2(o4, p5) {
              _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p6) {
                o5.__proto__ = p6;
                return o5;
              };
              return _setPrototypeOf2(o4, p5);
            }
            var Loader2 = __webpack_require__(6);
            var PrecompiledLoader = /* @__PURE__ */ function(_Loader) {
              _inheritsLoose(PrecompiledLoader2, _Loader);
              function PrecompiledLoader2(compiledTemplates) {
                var _this;
                _this = _Loader.call(this) || this;
                _this.precompiled = compiledTemplates || {};
                return _this;
              }
              var _proto = PrecompiledLoader2.prototype;
              _proto.getSource = function getSource(name) {
                if (this.precompiled[name]) {
                  return {
                    src: {
                      type: "code",
                      obj: this.precompiled[name]
                    },
                    path: name
                  };
                }
                return null;
              };
              return PrecompiledLoader2;
            }(Loader2);
            module3.exports = {
              PrecompiledLoader
            };
          },
          /* 20 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var SafeString = __webpack_require__(2).SafeString;
            function callable(value) {
              return typeof value === "function";
            }
            exports3.callable = callable;
            function defined(value) {
              return value !== void 0;
            }
            exports3.defined = defined;
            function divisibleby(one, two) {
              return one % two === 0;
            }
            exports3.divisibleby = divisibleby;
            function escaped(value) {
              return value instanceof SafeString;
            }
            exports3.escaped = escaped;
            function equalto(one, two) {
              return one === two;
            }
            exports3.equalto = equalto;
            exports3.eq = exports3.equalto;
            exports3.sameas = exports3.equalto;
            function even(value) {
              return value % 2 === 0;
            }
            exports3.even = even;
            function falsy(value) {
              return !value;
            }
            exports3.falsy = falsy;
            function ge(one, two) {
              return one >= two;
            }
            exports3.ge = ge;
            function greaterthan(one, two) {
              return one > two;
            }
            exports3.greaterthan = greaterthan;
            exports3.gt = exports3.greaterthan;
            function le(one, two) {
              return one <= two;
            }
            exports3.le = le;
            function lessthan(one, two) {
              return one < two;
            }
            exports3.lessthan = lessthan;
            exports3.lt = exports3.lessthan;
            function lower(value) {
              return value.toLowerCase() === value;
            }
            exports3.lower = lower;
            function ne(one, two) {
              return one !== two;
            }
            exports3.ne = ne;
            function nullTest(value) {
              return value === null;
            }
            exports3.null = nullTest;
            function number(value) {
              return typeof value === "number";
            }
            exports3.number = number;
            function odd(value) {
              return value % 2 === 1;
            }
            exports3.odd = odd;
            function string(value) {
              return typeof value === "string";
            }
            exports3.string = string;
            function truthy(value) {
              return !!value;
            }
            exports3.truthy = truthy;
            function undefinedTest(value) {
              return value === void 0;
            }
            exports3.undefined = undefinedTest;
            function upper(value) {
              return value.toUpperCase() === value;
            }
            exports3.upper = upper;
            function iterable(value) {
              if (typeof Symbol !== "undefined") {
                return !!value[Symbol.iterator];
              } else {
                return Array.isArray(value) || typeof value === "string";
              }
            }
            exports3.iterable = iterable;
            function mapping(value) {
              var bool = value !== null && value !== void 0 && typeof value === "object" && !Array.isArray(value);
              if (Set) {
                return bool && !(value instanceof Set);
              } else {
                return bool;
              }
            }
            exports3.mapping = mapping;
          },
          /* 21 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function _cycler(items) {
              var index2 = -1;
              return {
                current: null,
                reset: function reset() {
                  index2 = -1;
                  this.current = null;
                },
                next: function next2() {
                  index2++;
                  if (index2 >= items.length) {
                    index2 = 0;
                  }
                  this.current = items[index2];
                  return this.current;
                }
              };
            }
            function _joiner(sep) {
              sep = sep || ",";
              var first = true;
              return function() {
                var val = first ? "" : sep;
                first = false;
                return val;
              };
            }
            function globals() {
              return {
                range: function range(start, stop, step) {
                  if (typeof stop === "undefined") {
                    stop = start;
                    start = 0;
                    step = 1;
                  } else if (!step) {
                    step = 1;
                  }
                  var arr = [];
                  if (step > 0) {
                    for (var i4 = start; i4 < stop; i4 += step) {
                      arr.push(i4);
                    }
                  } else {
                    for (var _i = start; _i > stop; _i += step) {
                      arr.push(_i);
                    }
                  }
                  return arr;
                },
                cycler: function cycler() {
                  return _cycler(Array.prototype.slice.call(arguments));
                },
                joiner: function joiner(sep) {
                  return _joiner(sep);
                }
              };
            }
            module3.exports = globals;
          },
          /* 22 */
          /***/
          function(module3, exports3, __webpack_require__) {
            var path8 = __webpack_require__(4);
            module3.exports = function express(env2, app2) {
              function NunjucksView(name, opts) {
                this.name = name;
                this.path = name;
                this.defaultEngine = opts.defaultEngine;
                this.ext = path8.extname(name);
                if (!this.ext && !this.defaultEngine) {
                  throw new Error("No default engine was specified and no extension was provided.");
                }
                if (!this.ext) {
                  this.name += this.ext = (this.defaultEngine[0] !== "." ? "." : "") + this.defaultEngine;
                }
              }
              NunjucksView.prototype.render = function render(opts, cb) {
                env2.render(this.name, opts, cb);
              };
              app2.set("view", NunjucksView);
              app2.set("nunjucksEnv", env2);
              return env2;
            };
          },
          /* 23 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var fs2 = __webpack_require__(4);
            var path8 = __webpack_require__(4);
            var _require = __webpack_require__(0), _prettifyError = _require._prettifyError;
            var compiler = __webpack_require__(5);
            var _require2 = __webpack_require__(7), Environment = _require2.Environment;
            var precompileGlobal = __webpack_require__(24);
            function match2(filename, patterns) {
              if (!Array.isArray(patterns)) {
                return false;
              }
              return patterns.some(function(pattern) {
                return filename.match(pattern);
              });
            }
            function precompileString(str, opts) {
              opts = opts || {};
              opts.isString = true;
              var env2 = opts.env || new Environment([]);
              var wrapper = opts.wrapper || precompileGlobal;
              if (!opts.name) {
                throw new Error('the "name" option is required when compiling a string');
              }
              return wrapper([_precompile(str, opts.name, env2)], opts);
            }
            function precompile(input, opts) {
              opts = opts || {};
              var env2 = opts.env || new Environment([]);
              var wrapper = opts.wrapper || precompileGlobal;
              if (opts.isString) {
                return precompileString(input, opts);
              }
              var pathStats = fs2.existsSync(input) && fs2.statSync(input);
              var precompiled = [];
              var templates = [];
              function addTemplates(dir) {
                fs2.readdirSync(dir).forEach(function(file) {
                  var filepath = path8.join(dir, file);
                  var subpath = filepath.substr(path8.join(input, "/").length);
                  var stat = fs2.statSync(filepath);
                  if (stat && stat.isDirectory()) {
                    subpath += "/";
                    if (!match2(subpath, opts.exclude)) {
                      addTemplates(filepath);
                    }
                  } else if (match2(subpath, opts.include)) {
                    templates.push(filepath);
                  }
                });
              }
              if (pathStats.isFile()) {
                precompiled.push(_precompile(fs2.readFileSync(input, "utf-8"), opts.name || input, env2));
              } else if (pathStats.isDirectory()) {
                addTemplates(input);
                for (var i4 = 0; i4 < templates.length; i4++) {
                  var name = templates[i4].replace(path8.join(input, "/"), "");
                  try {
                    precompiled.push(_precompile(fs2.readFileSync(templates[i4], "utf-8"), name, env2));
                  } catch (e3) {
                    if (opts.force) {
                      console.error(e3);
                    } else {
                      throw e3;
                    }
                  }
                }
              }
              return wrapper(precompiled, opts);
            }
            function _precompile(str, name, env2) {
              env2 = env2 || new Environment([]);
              var asyncFilters = env2.asyncFilters;
              var extensions = env2.extensionsList;
              var template2;
              name = name.replace(/\\/g, "/");
              try {
                template2 = compiler.compile(str, asyncFilters, extensions, name, env2.opts);
              } catch (err) {
                throw _prettifyError(name, false, err);
              }
              return {
                name,
                template: template2
              };
            }
            module3.exports = {
              precompile,
              precompileString
            };
          },
          /* 24 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function precompileGlobal(templates, opts) {
              var out = "";
              opts = opts || {};
              for (var i4 = 0; i4 < templates.length; i4++) {
                var name = JSON.stringify(templates[i4].name);
                var template2 = templates[i4].template;
                out += "(function() {(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})[" + name + "] = (function() {\n" + template2 + "\n})();\n";
                if (opts.asFunction) {
                  out += "return function(ctx, cb) { return nunjucks.render(" + name + ", ctx, cb); }\n";
                }
                out += "})();\n";
              }
              return out;
            }
            module3.exports = precompileGlobal;
          },
          /* 25 */
          /***/
          function(module3, exports3, __webpack_require__) {
            function installCompat() {
              "use strict";
              var runtime = this.runtime;
              var lib = this.lib;
              var Compiler = this.compiler.Compiler;
              var Parser = this.parser.Parser;
              var nodes = this.nodes;
              var lexer = this.lexer;
              var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
              var orig_memberLookup = runtime.memberLookup;
              var orig_Compiler_assertType;
              var orig_Parser_parseAggregate;
              if (Compiler) {
                orig_Compiler_assertType = Compiler.prototype.assertType;
              }
              if (Parser) {
                orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
              }
              function uninstall() {
                runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
                runtime.memberLookup = orig_memberLookup;
                if (Compiler) {
                  Compiler.prototype.assertType = orig_Compiler_assertType;
                }
                if (Parser) {
                  Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
                }
              }
              runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
                var val = orig_contextOrFrameLookup.apply(this, arguments);
                if (val !== void 0) {
                  return val;
                }
                switch (key) {
                  case "True":
                    return true;
                  case "False":
                    return false;
                  case "None":
                    return null;
                  default:
                    return void 0;
                }
              };
              function getTokensState(tokens) {
                return {
                  index: tokens.index,
                  lineno: tokens.lineno,
                  colno: tokens.colno
                };
              }
              if (nodes && Compiler && Parser) {
                var Slice = nodes.Node.extend("Slice", {
                  fields: ["start", "stop", "step"],
                  init: function init(lineno, colno, start, stop, step) {
                    start = start || new nodes.Literal(lineno, colno, null);
                    stop = stop || new nodes.Literal(lineno, colno, null);
                    step = step || new nodes.Literal(lineno, colno, 1);
                    this.parent(lineno, colno, start, stop, step);
                  }
                });
                Compiler.prototype.assertType = function assertType(node2) {
                  if (node2 instanceof Slice) {
                    return;
                  }
                  orig_Compiler_assertType.apply(this, arguments);
                };
                Compiler.prototype.compileSlice = function compileSlice(node2, frame) {
                  this._emit("(");
                  this._compileExpression(node2.start, frame);
                  this._emit("),(");
                  this._compileExpression(node2.stop, frame);
                  this._emit("),(");
                  this._compileExpression(node2.step, frame);
                  this._emit(")");
                };
                Parser.prototype.parseAggregate = function parseAggregate() {
                  var _this = this;
                  var origState = getTokensState(this.tokens);
                  origState.colno--;
                  origState.index--;
                  try {
                    return orig_Parser_parseAggregate.apply(this);
                  } catch (e3) {
                    var errState = getTokensState(this.tokens);
                    var rethrow = function rethrow2() {
                      lib._assign(_this.tokens, errState);
                      return e3;
                    };
                    lib._assign(this.tokens, origState);
                    this.peeked = false;
                    var tok = this.peekToken();
                    if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
                      throw rethrow();
                    } else {
                      this.nextToken();
                    }
                    var node2 = new Slice(tok.lineno, tok.colno);
                    var isSlice = false;
                    for (var i4 = 0; i4 <= node2.fields.length; i4++) {
                      if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
                        break;
                      }
                      if (i4 === node2.fields.length) {
                        if (isSlice) {
                          this.fail("parseSlice: too many slice components", tok.lineno, tok.colno);
                        } else {
                          break;
                        }
                      }
                      if (this.skip(lexer.TOKEN_COLON)) {
                        isSlice = true;
                      } else {
                        var field = node2.fields[i4];
                        node2[field] = this.parseExpression();
                        isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
                      }
                    }
                    if (!isSlice) {
                      throw rethrow();
                    }
                    return new nodes.Array(tok.lineno, tok.colno, [node2]);
                  }
                };
              }
              function sliceLookup(obj, start, stop, step) {
                obj = obj || [];
                if (start === null) {
                  start = step < 0 ? obj.length - 1 : 0;
                }
                if (stop === null) {
                  stop = step < 0 ? -1 : obj.length;
                } else if (stop < 0) {
                  stop += obj.length;
                }
                if (start < 0) {
                  start += obj.length;
                }
                var results = [];
                for (var i4 = start; ; i4 += step) {
                  if (i4 < 0 || i4 > obj.length) {
                    break;
                  }
                  if (step > 0 && i4 >= stop) {
                    break;
                  }
                  if (step < 0 && i4 <= stop) {
                    break;
                  }
                  results.push(runtime.memberLookup(obj, i4));
                }
                return results;
              }
              function hasOwnProp2(obj, key) {
                return Object.prototype.hasOwnProperty.call(obj, key);
              }
              var ARRAY_MEMBERS = {
                pop: function pop(index2) {
                  if (index2 === void 0) {
                    return this.pop();
                  }
                  if (index2 >= this.length || index2 < 0) {
                    throw new Error("KeyError");
                  }
                  return this.splice(index2, 1);
                },
                append: function append2(element) {
                  return this.push(element);
                },
                remove: function remove(element) {
                  for (var i4 = 0; i4 < this.length; i4++) {
                    if (this[i4] === element) {
                      return this.splice(i4, 1);
                    }
                  }
                  throw new Error("ValueError");
                },
                count: function count(element) {
                  var count2 = 0;
                  for (var i4 = 0; i4 < this.length; i4++) {
                    if (this[i4] === element) {
                      count2++;
                    }
                  }
                  return count2;
                },
                index: function index2(element) {
                  var i4;
                  if ((i4 = this.indexOf(element)) === -1) {
                    throw new Error("ValueError");
                  }
                  return i4;
                },
                find: function find(element) {
                  return this.indexOf(element);
                },
                insert: function insert(index2, elem) {
                  return this.splice(index2, 0, elem);
                }
              };
              var OBJECT_MEMBERS = {
                items: function items() {
                  return lib._entries(this);
                },
                values: function values() {
                  return lib._values(this);
                },
                keys: function keys() {
                  return lib.keys(this);
                },
                get: function get2(key, def) {
                  var output = this[key];
                  if (output === void 0) {
                    output = def;
                  }
                  return output;
                },
                has_key: function has_key(key) {
                  return hasOwnProp2(this, key);
                },
                pop: function pop(key, def) {
                  var output = this[key];
                  if (output === void 0 && def !== void 0) {
                    output = def;
                  } else if (output === void 0) {
                    throw new Error("KeyError");
                  } else {
                    delete this[key];
                  }
                  return output;
                },
                popitem: function popitem() {
                  var keys = lib.keys(this);
                  if (!keys.length) {
                    throw new Error("KeyError");
                  }
                  var k4 = keys[0];
                  var val = this[k4];
                  delete this[k4];
                  return [k4, val];
                },
                setdefault: function setdefault(key, def) {
                  if (def === void 0) {
                    def = null;
                  }
                  if (!(key in this)) {
                    this[key] = def;
                  }
                  return this[key];
                },
                update: function update(kwargs) {
                  lib._assign(this, kwargs);
                  return null;
                }
              };
              OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
              OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
              OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
              runtime.memberLookup = function memberLookup2(obj, val, autoescape) {
                if (arguments.length === 4) {
                  return sliceLookup.apply(this, arguments);
                }
                obj = obj || {};
                if (lib.isArray(obj) && hasOwnProp2(ARRAY_MEMBERS, val)) {
                  return ARRAY_MEMBERS[val].bind(obj);
                }
                if (lib.isObject(obj) && hasOwnProp2(OBJECT_MEMBERS, val)) {
                  return OBJECT_MEMBERS[val].bind(obj);
                }
                return orig_memberLookup.apply(this, arguments);
              };
              return uninstall;
            }
            module3.exports = installCompat;
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length2) {
      return Buffer4(arg, encodingOrOffset, length2);
    }
    SafeBuffer.prototype = Object.create(Buffer4.prototype);
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length2);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    module2.exports = contentDisposition;
    module2.exports.parse = parse3;
    var basename = require("path").basename;
    var Buffer4 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options3) {
      var opts = options3 || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format3(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
        params["filename*"] = name;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
      }
      return params;
    }
    function format3(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i4 = 0; i4 < params.length; i4++) {
          param = params[i4];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string += "; " + param + "=" + val;
        }
      }
      return string;
    }
    function decodefield(str) {
      var match2 = EXT_VALUE_REGEXP.exec(str);
      if (!match2) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match2[1].toLowerCase();
      var encoded = match2[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer4.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse3(string) {
      if (!string || typeof string !== "string") {
        throw new TypeError("argument string is required");
      }
      var match2 = DISPOSITION_TYPE_REGEXP.exec(string);
      if (!match2) {
        throw new TypeError("invalid type format");
      }
      var index2 = match2[0].length;
      var type = match2[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index2 = PARAM_REGEXP.lastIndex = match2[0].substr(-1) === ";" ? index2 - 1 : index2;
      while (match2 = PARAM_REGEXP.exec(string)) {
        if (match2.index !== index2) {
          throw new TypeError("invalid parameter format");
        }
        index2 += match2[0].length;
        key = match2[1].toLowerCase();
        value = match2[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index2 !== -1 && index2 !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char2) {
      return "%" + String(char2).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/archive-type/node_modules/file-type/index.js
var require_file_type = __commonJS({
  "node_modules/archive-type/node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (input) => {
      const buf = new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, opts) => {
        opts = Object.assign({
          offset: 0
        }, opts);
        for (let i4 = 0; i4 < header.length; i4++) {
          if (header[i4] !== buf[i4 + opts.offset]) {
            return false;
          }
        }
        return true;
      };
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4]) && check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
        return {
          ext: "epub",
          mime: "application/epub+zip"
        };
      }
      if (check([80, 75, 3, 4]) && check([77, 69, 84, 65, 45, 73, 78, 70, 47, 109, 111, 122, 105, 108, 108, 97, 46, 114, 115, 97], { offset: 30 })) {
        return {
          ext: "xpi",
          mime: "application/x-xpinstall"
        };
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([0, 0, 0]) && (buf[3] === 24 || buf[3] === 32) && check([102, 116, 121, 112], { offset: 4 }) || check([51, 103, 112, 53]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50]) && check([109, 112, 52, 49, 109, 112, 52, 50, 105, 115, 111, 109], { offset: 16 }) || check([0, 0, 0, 28, 102, 116, 121, 112, 105, 115, 111, 109]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50, 0, 0, 0, 0])) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([0, 0, 0, 28, 102, 116, 121, 112, 77, 52, 86])) {
        return {
          ext: "m4v",
          mime: "video/x-m4v"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i4, arr) => arr[i4] === 66 && arr[i4 + 1] === 130);
        if (idPos >= 0) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => Array.from(type).every((c4, i4) => sliced[docTypePos + i4] === c4.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || // MJPEG
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70]) && check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/x-msvideo"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (check([0, 0, 1, 186])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([73, 68, 51]) || check([255, 251])) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 }) || check([77, 52, 65, 32])) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([82, 73, 70, 70]) && check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/x-wav"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "application/font-woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "application/font-woff"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "application/font-sfnt"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "application/font-sfnt"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      return null;
    };
  }
});

// node_modules/archive-type/index.js
var require_archive_type = __commonJS({
  "node_modules/archive-type/index.js"(exports2, module2) {
    "use strict";
    var fileType2 = require_file_type();
    var exts = /* @__PURE__ */ new Set([
      "7z",
      "bz2",
      "gz",
      "rar",
      "tar",
      "zip",
      "xz",
      "gz"
    ]);
    module2.exports = (input) => {
      const ret = fileType2(input);
      return exts.has(ret && ret.ext) ? ret : null;
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants3 = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d5) {
        cwd = null;
        chdir.call(process, d5);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs2) {
      if (constants3.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (fs2.chmod && !fs2.lchmod) {
        fs2.lchmod = function(path8, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (fs2.chown && !fs2.lchown) {
        fs2.lchown = function(path8, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
          function rename(from2, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from2, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from2, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs2.rename);
      }
      fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
        function read(fd, buffer, offset, length2, position2, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _3, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer, offset, length2, position2, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer, offset, length2, position2, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs2.read);
      fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length2, position2) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer, offset, length2, position2);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs3) {
        fs3.lchmod = function(path8, mode, callback) {
          fs3.open(
            path8,
            constants3.O_WRONLY | constants3.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs3.fchmod(fd, mode, function(err2) {
                fs3.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs3.lchmodSync = function(path8, mode) {
          var fd = fs3.openSync(path8, constants3.O_WRONLY | constants3.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs3.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs3) {
        if (constants3.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
          fs3.lutimes = function(path8, at, mt, cb) {
            fs3.open(path8, constants3.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs3.futimes(fd, at, mt, function(er2) {
                fs3.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs3.lutimesSync = function(path8, at, mt) {
            var fd = fs3.openSync(path8, constants3.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs3.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs3.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs3.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs3.futimes) {
          fs3.lutimes = function(_a2, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs3.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options3, cb) {
          if (typeof options3 === "function") {
            cb = options3;
            options3 = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options3 ? orig.call(fs2, target, options3, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options3) {
          var stats = options3 ? orig.call(fs2, target, options3) : orig.call(fs2, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path8, options3) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path8, options3);
        Stream.call(this);
        var self2 = this;
        this.path = path8;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options3 = options3 || {};
        var keys = Object.keys(options3);
        for (var index2 = 0, length2 = keys.length; index2 < length2; index2++) {
          var key = keys[index2];
          this[key] = options3[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path8, options3) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path8, options3);
        Stream.call(this);
        this.path = path8;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options3 = options3 || {};
        var keys = Object.keys(options3);
        for (var index2 = 0, length2 = keys.length; index2 < length2; index2++) {
          var key = keys[index2];
          this[key] = options3[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy2 = { __proto__: getPrototypeOf(obj) };
      else
        var copy2 = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy2;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs2 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop3() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop3;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m4 = util.format.apply(util, arguments);
        m4 = "GFS4: " + m4.split(/\n/).join("\nGFS4: ");
        console.error(m4);
      };
    if (!fs2[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs2, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs2[gracefulQueue]);
          require("assert").equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module2.exports = patch(clone(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module2.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs3) {
      polyfills(fs3);
      fs3.gracefulify = patch;
      fs3.createReadStream = createReadStream2;
      fs3.createWriteStream = createWriteStream2;
      var fs$readFile = fs3.readFile;
      fs3.readFile = readFile;
      function readFile(path8, options3, cb) {
        if (typeof options3 === "function")
          cb = options3, options3 = null;
        return go$readFile(path8, options3, cb);
        function go$readFile(path9, options4, cb2, startTime) {
          return fs$readFile(path9, options4, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path9, options4, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs3.writeFile;
      fs3.writeFile = writeFile;
      function writeFile(path8, data, options3, cb) {
        if (typeof options3 === "function")
          cb = options3, options3 = null;
        return go$writeFile(path8, data, options3, cb);
        function go$writeFile(path9, data2, options4, cb2, startTime) {
          return fs$writeFile(path9, data2, options4, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path9, data2, options4, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs3.appendFile;
      if (fs$appendFile)
        fs3.appendFile = appendFile;
      function appendFile(path8, data, options3, cb) {
        if (typeof options3 === "function")
          cb = options3, options3 = null;
        return go$appendFile(path8, data, options3, cb);
        function go$appendFile(path9, data2, options4, cb2, startTime) {
          return fs$appendFile(path9, data2, options4, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path9, data2, options4, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs3.copyFile;
      if (fs$copyFile)
        fs3.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs3.readdir;
      fs3.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path8, options3, cb) {
        if (typeof options3 === "function")
          cb = options3, options3 = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path9, options4, cb2, startTime) {
          return fs$readdir(path9, fs$readdirCallback(
            path9,
            options4,
            cb2,
            startTime
          ));
        } : function go$readdir2(path9, options4, cb2, startTime) {
          return fs$readdir(path9, options4, fs$readdirCallback(
            path9,
            options4,
            cb2,
            startTime
          ));
        };
        return go$readdir(path8, options3, cb);
        function fs$readdirCallback(path9, options4, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path9, options4, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs3);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs3.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs3.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs3, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs3, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs3, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs3, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path8, options3) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path8, options3) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream2(path8, options3) {
        return new fs3.ReadStream(path8, options3);
      }
      function createWriteStream2(path8, options3) {
        return new fs3.WriteStream(path8, options3);
      }
      var fs$open = fs3.open;
      fs3.open = open;
      function open(path8, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path8, flags, mode, cb);
        function go$open(path9, flags2, mode2, cb2, startTime) {
          return fs$open(path9, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path9, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs3;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i4 = 0; i4 < fs2[gracefulQueue].length; ++i4) {
        if (fs2[gracefulQueue][i4].length > 2) {
          fs2[gracefulQueue][i4][3] = now;
          fs2[gracefulQueue][i4][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs2[gracefulQueue].length === 0)
        return;
      var elem = fs2[gracefulQueue].shift();
      var fn2 = elem[0];
      var args2 = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn2.name, args2);
        fn2.apply(null, args2);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn2.name, args2);
        var cb = args2.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn2.name, args2);
          fn2.apply(null, args2.concat([startTime]));
        } else {
          fs2[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/file-type/index.js
var require_file_type2 = __commonJS({
  "node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (input) => {
      const buf = new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, opts) => {
        opts = Object.assign({
          offset: 0
        }, opts);
        for (let i4 = 0; i4 < header.length; i4++) {
          if (header[i4] !== buf[i4 + opts.offset]) {
            return false;
          }
        }
        return true;
      };
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4]) && check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
        return {
          ext: "epub",
          mime: "application/epub+zip"
        };
      }
      if (check([80, 75, 3, 4]) && check([77, 69, 84, 65, 45, 73, 78, 70, 47, 109, 111, 122, 105, 108, 108, 97, 46, 114, 115, 97], { offset: 30 })) {
        return {
          ext: "xpi",
          mime: "application/x-xpinstall"
        };
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([0, 0, 0]) && (buf[3] === 24 || buf[3] === 32) && check([102, 116, 121, 112], { offset: 4 }) || check([51, 103, 112, 53]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50]) && check([109, 112, 52, 49, 109, 112, 52, 50, 105, 115, 111, 109], { offset: 16 }) || check([0, 0, 0, 28, 102, 116, 121, 112, 105, 115, 111, 109]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50, 0, 0, 0, 0])) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([0, 0, 0, 28, 102, 116, 121, 112, 77, 52, 86])) {
        return {
          ext: "m4v",
          mime: "video/x-m4v"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i4, arr) => arr[i4] === 66 && arr[i4 + 1] === 130);
        if (idPos >= 0) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => Array.from(type).every((c4, i4) => sliced[docTypePos + i4] === c4.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || // MJPEG
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70]) && check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/x-msvideo"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (check([0, 0, 1, 186])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([73, 68, 51]) || check([255, 251])) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 }) || check([77, 52, 65, 32])) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([82, 73, 70, 70]) && check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/x-wav"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      return null;
    };
  }
});

// node_modules/is-stream/index.js
var require_is_stream2 = __commonJS({
  "node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream2 = module2.exports = function(stream2) {
      return stream2 !== null && typeof stream2 === "object" && typeof stream2.pipe === "function";
    };
    isStream2.writable = function(stream2) {
      return isStream2(stream2) && stream2.writable !== false && typeof stream2._write === "function" && typeof stream2._writableState === "object";
    };
    isStream2.readable = function(stream2) {
      return isStream2(stream2) && stream2.readable !== false && typeof stream2._read === "function" && typeof stream2._readableState === "object";
    };
    isStream2.duplex = function(stream2) {
      return isStream2.writable(stream2) && isStream2.readable(stream2);
    };
    isStream2.transform = function(stream2) {
      return isStream2.duplex(stream2) && typeof stream2._transform === "function" && typeof stream2._transformState === "object";
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn2, arg1, arg2, arg3) {
      if (typeof fn2 !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args2, i4;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn2);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn2.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn2.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn2.call(null, arg1, arg2, arg3);
          });
        default:
          args2 = new Array(len - 1);
          i4 = 0;
          while (i4 < args2.length) {
            args2[i4++] = arguments[i4];
          }
          return process.nextTick(function afterTick() {
            fn2.apply(null, args2);
          });
      }
    }
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray3(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray3;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean2;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber2(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber2;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString2;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d5) {
      return objectToString(d5) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e3) {
      return objectToString(e3) === "[object Error]" || e3 instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o4) {
      return Object.prototype.toString.call(o4);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString2 = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    module2.exports = require("events").EventEmitter;
  }
});

// node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length2) {
      return Buffer4(arg, encodingOrOffset, length2);
    }
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length2);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer4 = require_safe_buffer2().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck2(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v4) {
        var entry = { data: v4, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v4) {
        var entry = { data: v4, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s5) {
        if (this.length === 0)
          return "";
        var p5 = this.head;
        var ret = "" + p5.data;
        while (p5 = p5.next) {
          ret += s5 + p5.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n3) {
        if (this.length === 0)
          return Buffer4.alloc(0);
        var ret = Buffer4.allocUnsafe(n3 >>> 0);
        var p5 = this.head;
        var i4 = 0;
        while (p5) {
          copyBuffer(p5.data, ret, i4);
          i4 += p5.data.length;
          p5 = p5.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray3 = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer4 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (isArray3(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState(options3, stream2) {
      Duplex = Duplex || require_stream_duplex();
      options3 = options3 || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options3.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options3.readableObjectMode;
      var hwm = options3.highWaterMark;
      var readableHwm = options3.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options3.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options3.encoding) {
        if (!StringDecoder)
          StringDecoder = require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options3.encoding);
        this.encoding = options3.encoding;
      }
    }
    function Readable(options3) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options3);
      this._readableState = new ReadableState(options3, this);
      this.readable = true;
      if (options3) {
        if (typeof options3.read === "function")
          this._read = options3.read;
        if (typeof options3.destroy === "function")
          this._destroy = options3.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer4.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream2._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream2, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream2.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream2.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream2, state, chunk, true);
          } else if (state.ended) {
            stream2.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream2, state, chunk, false);
              else
                maybeReadMore(stream2, state);
            } else {
              addChunk(stream2, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream2, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream2.emit("data", chunk);
        stream2.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream2);
      }
      maybeReadMore(stream2, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n3) {
      if (n3 >= MAX_HWM) {
        n3 = MAX_HWM;
      } else {
        n3--;
        n3 |= n3 >>> 1;
        n3 |= n3 >>> 2;
        n3 |= n3 >>> 4;
        n3 |= n3 >>> 8;
        n3 |= n3 >>> 16;
        n3++;
      }
      return n3;
    }
    function howMuchToRead(n3, state) {
      if (n3 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n3 !== n3) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n3 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n3);
      if (n3 <= state.length)
        return n3;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n3) {
      debug("read", n3);
      n3 = parseInt(n3, 10);
      var state = this._readableState;
      var nOrig = n3;
      if (n3 !== 0)
        state.emittedReadable = false;
      if (n3 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n3 = howMuchToRead(n3, state);
      if (n3 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n3 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n3 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n3 > 0)
        ret = fromList(n3, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n3 = 0;
      } else {
        state.length -= n3;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n3 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream2, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream2);
    }
    function emitReadable(stream2) {
      var state = stream2._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream2);
        else
          emitReadable_(stream2);
      }
    }
    function emitReadable_(stream2) {
      debug("emit readable");
      stream2.emit("readable");
      flow(stream2);
    }
    function maybeReadMore(stream2, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream2, state);
      }
    }
    function maybeReadMore_(stream2, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream2.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n3) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i4 = 0; i4 < len; i4++) {
          dests[i4].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1)
        return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn2) {
      var res = Stream.prototype.on.call(this, ev, fn2);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream2, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream2, state);
      }
    }
    function resume_(stream2, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream2.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream2.emit("resume");
      flow(stream2);
      if (state.flowing && !state.reading)
        stream2.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream2) {
      var state = stream2._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream2.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream2) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream2.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream2.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream2.pause();
        }
      });
      for (var i4 in stream2) {
        if (this[i4] === void 0 && typeof stream2[i4] === "function") {
          this[i4] = function(method) {
            return function() {
              return stream2[method].apply(stream2, arguments);
            };
          }(i4);
        }
      }
      for (var n3 = 0; n3 < kProxyEvents.length; n3++) {
        stream2.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
      }
      this._read = function(n4) {
        debug("wrapped _read", n4);
        if (paused) {
          paused = false;
          stream2.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n3, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n3 || n3 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n3, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n3, list, hasStrings) {
      var ret;
      if (n3 < list.head.data.length) {
        ret = list.head.data.slice(0, n3);
        list.head.data = list.head.data.slice(n3);
      } else if (n3 === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n3, list) : copyFromBuffer(n3, list);
      }
      return ret;
    }
    function copyFromBufferString(n3, list) {
      var p5 = list.head;
      var c4 = 1;
      var ret = p5.data;
      n3 -= ret.length;
      while (p5 = p5.next) {
        var str = p5.data;
        var nb = n3 > str.length ? str.length : n3;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n3);
        n3 -= nb;
        if (n3 === 0) {
          if (nb === str.length) {
            ++c4;
            if (p5.next)
              list.head = p5.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p5;
            p5.data = str.slice(nb);
          }
          break;
        }
        ++c4;
      }
      list.length -= c4;
      return ret;
    }
    function copyFromBuffer(n3, list) {
      var ret = Buffer4.allocUnsafe(n3);
      var p5 = list.head;
      var c4 = 1;
      p5.data.copy(ret);
      n3 -= p5.data.length;
      while (p5 = p5.next) {
        var buf = p5.data;
        var nb = n3 > buf.length ? buf.length : n3;
        buf.copy(ret, ret.length - n3, 0, nb);
        n3 -= nb;
        if (n3 === 0) {
          if (nb === buf.length) {
            ++c4;
            if (p5.next)
              list.head = p5.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p5;
            p5.data = buf.slice(nb);
          }
          break;
        }
        ++c4;
      }
      list.length -= c4;
      return ret;
    }
    function endReadable(stream2) {
      var state = stream2._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream2);
      }
    }
    function endReadableNT(state, stream2) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream2.readable = false;
        stream2.emit("end");
      }
    }
    function indexOf(xs, x5) {
      for (var i4 = 0, l4 = xs.length; i4 < l4; i4++) {
        if (xs[i4] === x5)
          return i4;
      }
      return -1;
    }
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    module2.exports = deprecate;
    function deprecate(fn2, msg) {
      if (config("noDeprecation")) {
        return fn2;
      }
      var warned2 = false;
      function deprecated() {
        if (!warned2) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned2 = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_3) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer4 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options3, stream2) {
      Duplex = Duplex || require_stream_duplex();
      options3 = options3 || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options3.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options3.writableObjectMode;
      var hwm = options3.highWaterMark;
      var writableHwm = options3.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options3.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options3.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream2, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_3) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options3) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options3);
      }
      this._writableState = new WritableState(options3, this);
      this.writable = true;
      if (options3) {
        if (typeof options3.write === "function")
          this._write = options3.write;
        if (typeof options3.writev === "function")
          this._writev = options3.writev;
        if (typeof options3.destroy === "function")
          this._destroy = options3.destroy;
        if (typeof options3.final === "function")
          this._final = options3.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream2, cb) {
      var er = new Error("write after end");
      stream2.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream2, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream2.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer4.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer4.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream2, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream2._writev(chunk, state.onwrite);
      else
        stream2._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream2, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream2, state);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
      } else {
        cb(er);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
        finishMaybe(stream2, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream2, er) {
      var state = stream2._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream2, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream2, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream2, state, finished, cb);
        } else {
          afterWrite(stream2, state, finished, cb);
        }
      }
    }
    function afterWrite(stream2, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream2, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream2, state);
    }
    function onwriteDrain(stream2, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream2.emit("drain");
      }
    }
    function clearBuffer(stream2, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream2._writev && entry && entry.next) {
        var l4 = state.bufferedRequestCount;
        var buffer = new Array(l4);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream2, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream2, state) {
      stream2._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream2.emit("error", err);
        }
        state.prefinished = true;
        stream2.emit("prefinish");
        finishMaybe(stream2, state);
      });
    }
    function prefinish(stream2, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream2._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream2, state);
        } else {
          state.prefinished = true;
          stream2.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream2, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream2, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream2.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream2, state, cb) {
      state.ending = true;
      finishMaybe(stream2, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream2.once("finish", cb);
      }
      state.ended = true;
      stream2.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v4 = 0; v4 < keys.length; v4++) {
        method = keys[v4];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v4;
    function Duplex(options3) {
      if (!(this instanceof Duplex))
        return new Duplex(options3);
      Readable.call(this, options3);
      Writable.call(this, options3);
      if (options3 && options3.readable === false)
        this.readable = false;
      if (options3 && options3.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options3 && options3.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/readable-stream/duplex-browser.js
var require_duplex_browser = __commonJS({
  "node_modules/readable-stream/duplex-browser.js"(exports2, module2) {
    module2.exports = require_stream_duplex();
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    var DuplexStream = require_duplex_browser();
    var util = require("util");
    var Buffer4 = require_safe_buffer().Buffer;
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
      } else {
        this.append(callback);
      }
      DuplexStream.call(this);
    }
    util.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function _offset(offset) {
      var tot = 0, i4 = 0, _t;
      if (offset === 0)
        return [0, 0];
      for (; i4 < this._bufs.length; i4++) {
        _t = tot + this._bufs[i4].length;
        if (offset < _t || i4 == this._bufs.length - 1)
          return [i4, offset - tot];
        tot = _t;
      }
    };
    BufferList.prototype.append = function append2(buf) {
      var i4 = 0;
      if (Buffer4.isBuffer(buf)) {
        this._appendBuffer(buf);
      } else if (Array.isArray(buf)) {
        for (; i4 < buf.length; i4++)
          this.append(buf[i4]);
      } else if (buf instanceof BufferList) {
        for (; i4 < buf._bufs.length; i4++)
          this.append(buf._bufs[i4]);
      } else if (buf != null) {
        if (typeof buf == "number")
          buf = buf.toString();
        this._appendBuffer(Buffer4.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback == "function")
        callback();
    };
    BufferList.prototype._read = function _read(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function get2(index2) {
      return this.slice(index2, index2 + 1)[0];
    };
    BufferList.prototype.slice = function slice2(start, end) {
      if (typeof start == "number" && start < 0)
        start += this.length;
      if (typeof end == "number" && end < 0)
        end += this.length;
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy2(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || Buffer4.alloc(0);
      if (srcEnd <= 0)
        return dst || Buffer4.alloc(0);
      var copy3 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy3 && dstStart || 0, start = off[1], l4, i4;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy3) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer4.concat(this._bufs, this.length);
        }
        for (i4 = 0; i4 < this._bufs.length; i4++) {
          this._bufs[i4].copy(dst, bufoff);
          bufoff += this._bufs[i4].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy3 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy3)
        dst = Buffer4.allocUnsafe(len);
      for (i4 = off[0]; i4 < this._bufs.length; i4++) {
        l4 = this._bufs[i4].length - start;
        if (bytes > l4) {
          this._bufs[i4].copy(dst, bufoff, start);
          bufoff += l4;
        } else {
          this._bufs[i4].copy(dst, bufoff, start, start + bytes);
          bufoff += l4;
          break;
        }
        bytes -= l4;
        if (start)
          start = 0;
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = end || this.length;
      if (start < 0)
        start += this.length;
      if (end < 0)
        end += this.length;
      var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] == 0)
        buffers.pop();
      else
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      if (startOffset[1] != 0)
        buffers[0] = buffers[0].slice(startOffset[1]);
      return new BufferList(buffers);
    };
    BufferList.prototype.toString = function toString2(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      var i4 = 0, copy2 = new BufferList();
      for (; i4 < this._bufs.length; i4++)
        copy2.append(this._bufs[i4]);
      return copy2;
    };
    BufferList.prototype.destroy = function destroy() {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    };
    (function() {
      var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1
      };
      for (var m4 in methods) {
        (function(m5) {
          BufferList.prototype[m5] = function(offset) {
            return this.slice(offset, offset + methods[m5])[m5](0);
          };
        })(m4);
      }
    })();
    module2.exports = BufferList;
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports2, module2) {
    module2.exports = extend;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i4 = 0; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/to-buffer/index.js
var require_to_buffer = __commonJS({
  "node_modules/to-buffer/index.js"(exports2, module2) {
    module2.exports = toBuffer;
    var makeBuffer = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from : bufferFrom;
    function bufferFrom(buf, enc) {
      return new Buffer(buf, enc);
    }
    function toBuffer(buf, enc) {
      if (Buffer.isBuffer(buf))
        return buf;
      if (typeof buf === "string")
        return makeBuffer(buf, enc);
      if (Array.isArray(buf))
        return makeBuffer(buf);
      throw new Error("Input should be a buffer or a string");
    }
  }
});

// node_modules/buffer-fill/index.js
var require_buffer_fill = __commonJS({
  "node_modules/buffer-fill/index.js"(exports2, module2) {
    var hasFullSupport = function() {
      try {
        if (!Buffer.isEncoding("latin1")) {
          return false;
        }
        var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
        buf.fill("ab", "ucs2");
        return buf.toString("hex") === "61006200";
      } catch (_3) {
        return false;
      }
    }();
    function isSingleByte(val) {
      return val.length === 1 && val.charCodeAt(0) < 256;
    }
    function fillWithNumber(buffer, val, start, end) {
      if (start < 0 || end > buffer.length) {
        throw new RangeError("Out of range index");
      }
      start = start >>> 0;
      end = end === void 0 ? buffer.length : end >>> 0;
      if (end > start) {
        buffer.fill(val, start, end);
      }
      return buffer;
    }
    function fillWithBuffer(buffer, val, start, end) {
      if (start < 0 || end > buffer.length) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return buffer;
      }
      start = start >>> 0;
      end = end === void 0 ? buffer.length : end >>> 0;
      var pos = start;
      var len = val.length;
      while (pos <= end - len) {
        val.copy(buffer, pos);
        pos += len;
      }
      if (pos !== end) {
        val.copy(buffer, pos, 0, end - pos);
      }
      return buffer;
    }
    function fill(buffer, val, start, end, encoding) {
      if (hasFullSupport) {
        return buffer.fill(val, start, end, encoding);
      }
      if (typeof val === "number") {
        return fillWithNumber(buffer, val, start, end);
      }
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = buffer.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = buffer.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (encoding === "latin1") {
          encoding = "binary";
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val === "") {
          return fillWithNumber(buffer, 0, start, end);
        }
        if (isSingleByte(val)) {
          return fillWithNumber(buffer, val.charCodeAt(0), start, end);
        }
        val = new Buffer(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        return fillWithBuffer(buffer, val, start, end);
      }
      return fillWithNumber(buffer, 0, start, end);
    }
    module2.exports = fill;
  }
});

// node_modules/buffer-alloc-unsafe/index.js
var require_buffer_alloc_unsafe = __commonJS({
  "node_modules/buffer-alloc-unsafe/index.js"(exports2, module2) {
    function allocUnsafe(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      }
      if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
      if (Buffer.allocUnsafe) {
        return Buffer.allocUnsafe(size);
      } else {
        return new Buffer(size);
      }
    }
    module2.exports = allocUnsafe;
  }
});

// node_modules/buffer-alloc/index.js
var require_buffer_alloc = __commonJS({
  "node_modules/buffer-alloc/index.js"(exports2, module2) {
    var bufferFill = require_buffer_fill();
    var allocUnsafe = require_buffer_alloc_unsafe();
    module2.exports = function alloc2(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      }
      if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
      if (Buffer.alloc) {
        return Buffer.alloc(size, fill, encoding);
      }
      var buffer = allocUnsafe(size);
      if (size === 0) {
        return buffer;
      }
      if (fill === void 0) {
        return bufferFill(buffer, 0);
      }
      if (typeof encoding !== "string") {
        encoding = void 0;
      }
      return bufferFill(buffer, fill, encoding);
    };
  }
});

// node_modules/tar-stream/headers.js
var require_headers = __commonJS({
  "node_modules/tar-stream/headers.js"(exports2) {
    var toBuffer = require_to_buffer();
    var alloc2 = require_buffer_alloc();
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR = "ustar\x0000";
    var MASK = parseInt("7777", 8);
    var clamp = function(index2, len, defaultValue) {
      if (typeof index2 !== "number")
        return defaultValue;
      index2 = ~~index2;
      if (index2 >= len)
        return len;
      if (index2 >= 0)
        return index2;
      index2 += len;
      if (index2 >= 0)
        return index2;
      return 0;
    };
    var toType = function(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    };
    var toTypeflag = function(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    };
    var indexOf = function(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num)
          return offset;
      }
      return end;
    };
    var cksum = function(block) {
      var sum = 8 * 32;
      for (var i4 = 0; i4 < 148; i4++)
        sum += block[i4];
      for (var j4 = 156; j4 < 512; j4++)
        sum += block[j4];
      return sum;
    };
    var encodeOct = function(val, n3) {
      val = val.toString(8);
      if (val.length > n3)
        return SEVENS.slice(0, n3) + " ";
      else
        return ZEROS.slice(0, n3 - val.length) + val + " ";
    };
    function parse256(buf) {
      var positive;
      if (buf[0] === 128)
        positive = true;
      else if (buf[0] === 255)
        positive = false;
      else
        return null;
      var zero = false;
      var tuple = [];
      for (var i4 = buf.length - 1; i4 > 0; i4--) {
        var byte = buf[i4];
        if (positive)
          tuple.push(byte);
        else if (zero && byte === 0)
          tuple.push(0);
        else if (zero) {
          zero = false;
          tuple.push(256 - byte);
        } else
          tuple.push(255 - byte);
      }
      var sum = 0;
      var l4 = tuple.length;
      for (i4 = 0; i4 < l4; i4++) {
        sum += tuple[i4] * Math.pow(256, i4);
      }
      return positive ? sum : -1 * sum;
    }
    var decodeOct = function(val, offset, length2) {
      val = val.slice(offset, offset + length2);
      offset = 0;
      if (val[offset] & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val[offset] === 32)
          offset++;
        var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val[offset] === 0)
          offset++;
        if (end === offset)
          return 0;
        return parseInt(val.slice(offset, end).toString(), 8);
      }
    };
    var decodeStr = function(val, offset, length2, encoding) {
      return val.slice(offset, indexOf(val, 0, offset, offset + length2)).toString(encoding);
    };
    var addLength = function(str) {
      var len = Buffer.byteLength(str);
      var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits))
        digits++;
      return len + digits + str;
    };
    exports2.decodeLongPath = function(buf, encoding) {
      return decodeStr(buf, 0, buf.length, encoding);
    };
    exports2.encodePax = function(opts) {
      var result = "";
      if (opts.name)
        result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname)
        result += addLength(" linkpath=" + opts.linkname + "\n");
      var pax = opts.pax;
      if (pax) {
        for (var key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return toBuffer(result);
    };
    exports2.decodePax = function(buf) {
      var result = {};
      while (buf.length) {
        var i4 = 0;
        while (i4 < buf.length && buf[i4] !== 32)
          i4++;
        var len = parseInt(buf.slice(0, i4).toString(), 10);
        if (!len)
          return result;
        var b4 = buf.slice(i4 + 1, len - 1).toString();
        var keyIndex = b4.indexOf("=");
        if (keyIndex === -1)
          return result;
        result[b4.slice(0, keyIndex)] = b4.slice(keyIndex + 1);
        buf = buf.slice(len);
      }
      return result;
    };
    exports2.encode = function(opts) {
      var buf = alloc2(512);
      var name = opts.name;
      var prefix2 = "";
      if (opts.typeflag === 5 && name[name.length - 1] !== "/")
        name += "/";
      if (Buffer.byteLength(name) !== name.length)
        return null;
      while (Buffer.byteLength(name) > 100) {
        var i4 = name.indexOf("/");
        if (i4 === -1)
          return null;
        prefix2 += prefix2 ? "/" + name.slice(0, i4) : name.slice(0, i4);
        name = name.slice(i4 + 1);
      }
      if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix2) > 155)
        return null;
      if (opts.linkname && Buffer.byteLength(opts.linkname) > 100)
        return null;
      buf.write(name);
      buf.write(encodeOct(opts.mode & MASK, 6), 100);
      buf.write(encodeOct(opts.uid, 6), 108);
      buf.write(encodeOct(opts.gid, 6), 116);
      buf.write(encodeOct(opts.size, 11), 124);
      buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname)
        buf.write(opts.linkname, 157);
      buf.write(USTAR, 257);
      if (opts.uname)
        buf.write(opts.uname, 265);
      if (opts.gname)
        buf.write(opts.gname, 297);
      buf.write(encodeOct(opts.devmajor || 0, 6), 329);
      buf.write(encodeOct(opts.devminor || 0, 6), 337);
      if (prefix2)
        buf.write(prefix2, 345);
      buf.write(encodeOct(cksum(buf), 6), 148);
      return buf;
    };
    exports2.decode = function(buf, filenameEncoding) {
      var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
      var name = decodeStr(buf, 0, 100, filenameEncoding);
      var mode = decodeOct(buf, 100, 8);
      var uid = decodeOct(buf, 108, 8);
      var gid = decodeOct(buf, 116, 8);
      var size = decodeOct(buf, 124, 12);
      var mtime = decodeOct(buf, 136, 12);
      var type = toType(typeflag);
      var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
      var uname = decodeStr(buf, 265, 32);
      var gname = decodeStr(buf, 297, 32);
      var devmajor = decodeOct(buf, 329, 8);
      var devminor = decodeOct(buf, 337, 8);
      if (buf[345])
        name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
      if (typeflag === 0 && name && name[name.length - 1] === "/")
        typeflag = 5;
      var c4 = cksum(buf);
      if (c4 === 8 * 32)
        return null;
      if (c4 !== decodeOct(buf, 148, 8))
        throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
      };
    };
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options3) {
      if (!(this instanceof Transform))
        return new Transform(options3);
      Duplex.call(this, options3);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options3) {
        if (typeof options3.transform === "function")
          this._transform = options3.transform;
        if (typeof options3.flush === "function")
          this._flush = options3.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n3) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream2, er, data) {
      if (er)
        return stream2.emit("error", er);
      if (data != null)
        stream2.push(data);
      if (stream2._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream2._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream2.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options3) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options3);
      Transform.call(this, options3);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
  }
});

// node_modules/tar-stream/extract.js
var require_extract = __commonJS({
  "node_modules/tar-stream/extract.js"(exports2, module2) {
    var util = require("util");
    var bl = require_bl();
    var xtend = require_immutable();
    var headers = require_headers();
    var Writable = require_readable_browser().Writable;
    var PassThrough = require_readable_browser().PassThrough;
    var noop3 = function() {
    };
    var overflow = function(size) {
      size &= 511;
      return size && 512 - size;
    };
    var emptyStream = function(self2, offset) {
      var s5 = new Source(self2, offset);
      s5.end();
      return s5;
    };
    var mixinPax = function(header, pax) {
      if (pax.path)
        header.name = pax.path;
      if (pax.linkpath)
        header.linkname = pax.linkpath;
      if (pax.size)
        header.size = parseInt(pax.size, 10);
      header.pax = pax;
      return header;
    };
    var Source = function(self2, offset) {
      this._parent = self2;
      this.offset = offset;
      PassThrough.call(this);
    };
    util.inherits(Source, PassThrough);
    Source.prototype.destroy = function(err) {
      this._parent.destroy(err);
    };
    var Extract = function(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Writable.call(this, opts);
      opts = opts || {};
      this._offset = 0;
      this._buffer = bl();
      this._missing = 0;
      this._partial = false;
      this._onparse = noop3;
      this._header = null;
      this._stream = null;
      this._overflow = null;
      this._cb = null;
      this._locked = false;
      this._destroyed = false;
      this._pax = null;
      this._paxGlobal = null;
      this._gnuLongPath = null;
      this._gnuLongLinkPath = null;
      var self2 = this;
      var b4 = self2._buffer;
      var oncontinue = function() {
        self2._continue();
      };
      var onunlock = function(err) {
        self2._locked = false;
        if (err)
          return self2.destroy(err);
        if (!self2._stream)
          oncontinue();
      };
      var onstreamend = function() {
        self2._stream = null;
        var drain = overflow(self2._header.size);
        if (drain)
          self2._parse(drain, ondrain);
        else
          self2._parse(512, onheader);
        if (!self2._locked)
          oncontinue();
      };
      var ondrain = function() {
        self2._buffer.consume(overflow(self2._header.size));
        self2._parse(512, onheader);
        oncontinue();
      };
      var onpaxglobalheader = function() {
        var size = self2._header.size;
        self2._paxGlobal = headers.decodePax(b4.slice(0, size));
        b4.consume(size);
        onstreamend();
      };
      var onpaxheader = function() {
        var size = self2._header.size;
        self2._pax = headers.decodePax(b4.slice(0, size));
        if (self2._paxGlobal)
          self2._pax = xtend(self2._paxGlobal, self2._pax);
        b4.consume(size);
        onstreamend();
      };
      var ongnulongpath = function() {
        var size = self2._header.size;
        this._gnuLongPath = headers.decodeLongPath(b4.slice(0, size), opts.filenameEncoding);
        b4.consume(size);
        onstreamend();
      };
      var ongnulonglinkpath = function() {
        var size = self2._header.size;
        this._gnuLongLinkPath = headers.decodeLongPath(b4.slice(0, size), opts.filenameEncoding);
        b4.consume(size);
        onstreamend();
      };
      var onheader = function() {
        var offset = self2._offset;
        var header;
        try {
          header = self2._header = headers.decode(b4.slice(0, 512), opts.filenameEncoding);
        } catch (err) {
          self2.emit("error", err);
        }
        b4.consume(512);
        if (!header) {
          self2._parse(512, onheader);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-path") {
          self2._parse(header.size, ongnulongpath);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-link-path") {
          self2._parse(header.size, ongnulonglinkpath);
          oncontinue();
          return;
        }
        if (header.type === "pax-global-header") {
          self2._parse(header.size, onpaxglobalheader);
          oncontinue();
          return;
        }
        if (header.type === "pax-header") {
          self2._parse(header.size, onpaxheader);
          oncontinue();
          return;
        }
        if (self2._gnuLongPath) {
          header.name = self2._gnuLongPath;
          self2._gnuLongPath = null;
        }
        if (self2._gnuLongLinkPath) {
          header.linkname = self2._gnuLongLinkPath;
          self2._gnuLongLinkPath = null;
        }
        if (self2._pax) {
          self2._header = header = mixinPax(header, self2._pax);
          self2._pax = null;
        }
        self2._locked = true;
        if (!header.size || header.type === "directory") {
          self2._parse(512, onheader);
          self2.emit("entry", header, emptyStream(self2, offset), onunlock);
          return;
        }
        self2._stream = new Source(self2, offset);
        self2.emit("entry", header, self2._stream, onunlock);
        self2._parse(header.size, onstreamend);
        oncontinue();
      };
      this._onheader = onheader;
      this._parse(512, onheader);
    };
    util.inherits(Extract, Writable);
    Extract.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream)
        this._stream.emit("close");
    };
    Extract.prototype._parse = function(size, onparse) {
      if (this._destroyed)
        return;
      this._offset += size;
      this._missing = size;
      if (onparse === this._onheader)
        this._partial = false;
      this._onparse = onparse;
    };
    Extract.prototype._continue = function() {
      if (this._destroyed)
        return;
      var cb = this._cb;
      this._cb = noop3;
      if (this._overflow)
        this._write(this._overflow, void 0, cb);
      else
        cb();
    };
    Extract.prototype._write = function(data, enc, cb) {
      if (this._destroyed)
        return;
      var s5 = this._stream;
      var b4 = this._buffer;
      var missing = this._missing;
      if (data.length)
        this._partial = true;
      if (data.length < missing) {
        this._missing -= data.length;
        this._overflow = null;
        if (s5)
          return s5.write(data, cb);
        b4.append(data);
        return cb();
      }
      this._cb = cb;
      this._missing = 0;
      var overflow2 = null;
      if (data.length > missing) {
        overflow2 = data.slice(missing);
        data = data.slice(0, missing);
      }
      if (s5)
        s5.end(data);
      else
        b4.append(data);
      this._overflow = overflow2;
      this._onparse();
    };
    Extract.prototype._final = function(cb) {
      if (this._partial)
        return this.destroy(new Error("Unexpected end of data"));
      cb();
    };
    module2.exports = Extract;
  }
});

// node_modules/fs-constants/browser.js
var require_browser2 = __commonJS({
  "node_modules/fs-constants/browser.js"(exports2, module2) {
    module2.exports = require("constants");
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn2, cb) {
      if (fn2 && cb)
        return wrappy(fn2)(cb);
      if (typeof fn2 !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn2).forEach(function(k4) {
        wrapper[k4] = fn2[k4];
      });
      return wrapper;
      function wrapper() {
        var args2 = new Array(arguments.length);
        for (var i4 = 0; i4 < args2.length; i4++) {
          args2[i4] = arguments[i4];
        }
        var ret = fn2.apply(this, args2);
        var cb2 = args2[args2.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k4) {
            ret[k4] = cb2[k4];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn2) {
      var f4 = function() {
        if (f4.called)
          return f4.value;
        f4.called = true;
        return f4.value = fn2.apply(this, arguments);
      };
      f4.called = false;
      return f4;
    }
    function onceStrict(fn2) {
      var f4 = function() {
        if (f4.called)
          throw new Error(f4.onceError);
        f4.called = true;
        return f4.value = fn2.apply(this, arguments);
      };
      var name = fn2.name || "Function wrapped with `once`";
      f4.onceError = name + " shouldn't be called more than once";
      f4.called = false;
      return f4;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop3 = function() {
    };
    var isRequest = function(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    };
    var isChildProcess = function(stream2) {
      return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
    };
    var eos = function(stream2, opts, callback) {
      if (typeof opts === "function")
        return eos(stream2, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop3);
      var ws = stream2._writableState;
      var rs = stream2._readableState;
      var readable = opts.readable || opts.readable !== false && stream2.readable;
      var writable = opts.writable || opts.writable !== false && stream2.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream2.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream2);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream2);
      };
      var onexit = function(exitCode) {
        callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream2, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream2, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream2, new Error("premature close"));
      };
      var onrequest = function() {
        stream2.req.on("finish", onfinish);
      };
      if (isRequest(stream2)) {
        stream2.on("complete", onfinish);
        stream2.on("abort", onclose);
        if (stream2.req)
          onrequest();
        else
          stream2.on("request", onrequest);
      } else if (writable && !ws) {
        stream2.on("end", onlegacyfinish);
        stream2.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream2))
        stream2.on("exit", onexit);
      stream2.on("end", onend);
      stream2.on("finish", onfinish);
      if (opts.error !== false)
        stream2.on("error", onerror);
      stream2.on("close", onclose);
      return function() {
        cancelled = true;
        stream2.removeListener("complete", onfinish);
        stream2.removeListener("abort", onclose);
        stream2.removeListener("request", onrequest);
        if (stream2.req)
          stream2.req.removeListener("finish", onfinish);
        stream2.removeListener("end", onlegacyfinish);
        stream2.removeListener("close", onlegacyfinish);
        stream2.removeListener("finish", onfinish);
        stream2.removeListener("exit", onexit);
        stream2.removeListener("end", onend);
        stream2.removeListener("error", onerror);
        stream2.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// node_modules/tar-stream/pack.js
var require_pack = __commonJS({
  "node_modules/tar-stream/pack.js"(exports2, module2) {
    var constants3 = require_browser2();
    var eos = require_end_of_stream();
    var util = require("util");
    var alloc2 = require_buffer_alloc();
    var toBuffer = require_to_buffer();
    var Readable = require_readable_browser().Readable;
    var Writable = require_readable_browser().Writable;
    var StringDecoder = require("string_decoder").StringDecoder;
    var headers = require_headers();
    var DMODE = parseInt("755", 8);
    var FMODE = parseInt("644", 8);
    var END_OF_TAR = alloc2(1024);
    var noop3 = function() {
    };
    var overflow = function(self2, size) {
      size &= 511;
      if (size)
        self2.push(END_OF_TAR.slice(0, 512 - size));
    };
    function modeToType(mode) {
      switch (mode & constants3.S_IFMT) {
        case constants3.S_IFBLK:
          return "block-device";
        case constants3.S_IFCHR:
          return "character-device";
        case constants3.S_IFDIR:
          return "directory";
        case constants3.S_IFIFO:
          return "fifo";
        case constants3.S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    var Sink = function(to) {
      Writable.call(this);
      this.written = 0;
      this._to = to;
      this._destroyed = false;
    };
    util.inherits(Sink, Writable);
    Sink.prototype._write = function(data, enc, cb) {
      this.written += data.length;
      if (this._to.push(data))
        return cb();
      this._to._drain = cb;
    };
    Sink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var LinkSink = function() {
      Writable.call(this);
      this.linkname = "";
      this._decoder = new StringDecoder("utf-8");
      this._destroyed = false;
    };
    util.inherits(LinkSink, Writable);
    LinkSink.prototype._write = function(data, enc, cb) {
      this.linkname += this._decoder.write(data);
      cb();
    };
    LinkSink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Void = function() {
      Writable.call(this);
      this._destroyed = false;
    };
    util.inherits(Void, Writable);
    Void.prototype._write = function(data, enc, cb) {
      cb(new Error("No body allowed for this entry"));
    };
    Void.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Pack = function(opts) {
      if (!(this instanceof Pack))
        return new Pack(opts);
      Readable.call(this, opts);
      this._drain = noop3;
      this._finalized = false;
      this._finalizing = false;
      this._destroyed = false;
      this._stream = null;
    };
    util.inherits(Pack, Readable);
    Pack.prototype.entry = function(header, buffer, callback) {
      if (this._stream)
        throw new Error("already piping an entry");
      if (this._finalized || this._destroyed)
        return;
      if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
      }
      if (!callback)
        callback = noop3;
      var self2 = this;
      if (!header.size || header.type === "symlink")
        header.size = 0;
      if (!header.type)
        header.type = modeToType(header.mode);
      if (!header.mode)
        header.mode = header.type === "directory" ? DMODE : FMODE;
      if (!header.uid)
        header.uid = 0;
      if (!header.gid)
        header.gid = 0;
      if (!header.mtime)
        header.mtime = /* @__PURE__ */ new Date();
      if (typeof buffer === "string")
        buffer = toBuffer(buffer);
      if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length;
        this._encode(header);
        this.push(buffer);
        overflow(self2, header.size);
        process.nextTick(callback);
        return new Void();
      }
      if (header.type === "symlink" && !header.linkname) {
        var linkSink = new LinkSink();
        eos(linkSink, function(err) {
          if (err) {
            self2.destroy();
            return callback(err);
          }
          header.linkname = linkSink.linkname;
          self2._encode(header);
          callback();
        });
        return linkSink;
      }
      this._encode(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        process.nextTick(callback);
        return new Void();
      }
      var sink = new Sink(this);
      this._stream = sink;
      eos(sink, function(err) {
        self2._stream = null;
        if (err) {
          self2.destroy();
          return callback(err);
        }
        if (sink.written !== header.size) {
          self2.destroy();
          return callback(new Error("size mismatch"));
        }
        overflow(self2, header.size);
        if (self2._finalizing)
          self2.finalize();
        callback();
      });
      return sink;
    };
    Pack.prototype.finalize = function() {
      if (this._stream) {
        this._finalizing = true;
        return;
      }
      if (this._finalized)
        return;
      this._finalized = true;
      this.push(END_OF_TAR);
      this.push(null);
    };
    Pack.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream && this._stream.destroy)
        this._stream.destroy();
    };
    Pack.prototype._encode = function(header) {
      if (!header.pax) {
        var buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    };
    Pack.prototype._encodePax = function(header) {
      var paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      var newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader));
      this.push(paxHeader);
      overflow(this, paxHeader.length);
      newHeader.size = header.size;
      newHeader.type = header.type;
      this.push(headers.encode(newHeader));
    };
    Pack.prototype._read = function(n3) {
      var drain = this._drain;
      this._drain = noop3;
      drain();
    };
    module2.exports = Pack;
  }
});

// node_modules/tar-stream/index.js
var require_tar_stream = __commonJS({
  "node_modules/tar-stream/index.js"(exports2) {
    exports2.extract = require_extract();
    exports2.pack = require_pack();
  }
});

// node_modules/decompress-tar/index.js
var require_decompress_tar = __commonJS({
  "node_modules/decompress-tar/index.js"(exports2, module2) {
    "use strict";
    var fileType2 = require_file_type2();
    var isStream2 = require_is_stream2();
    var tarStream = require_tar_stream();
    module2.exports = () => (input) => {
      if (!Buffer.isBuffer(input) && !isStream2(input)) {
        return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
      }
      if (Buffer.isBuffer(input) && (!fileType2(input) || fileType2(input).ext !== "tar")) {
        return Promise.resolve([]);
      }
      const extract = tarStream.extract();
      const files = [];
      extract.on("entry", (header, stream2, cb) => {
        const chunk = [];
        stream2.on("data", (data) => chunk.push(data));
        stream2.on("end", () => {
          const file = {
            data: Buffer.concat(chunk),
            mode: header.mode,
            mtime: header.mtime,
            path: header.name,
            type: header.type
          };
          if (header.type === "symlink" || header.type === "link") {
            file.linkname = header.linkname;
          }
          files.push(file);
          cb();
        });
      });
      const promise = new Promise((resolve2, reject2) => {
        if (!Buffer.isBuffer(input)) {
          input.on("error", reject2);
        }
        extract.on("finish", () => resolve2(files));
        extract.on("error", reject2);
      });
      extract.then = promise.then.bind(promise);
      extract.catch = promise.catch.bind(promise);
      if (Buffer.isBuffer(input)) {
        extract.end(input);
      } else {
        input.pipe(extract);
      }
      return extract;
    };
  }
});

// node_modules/decompress-tarbz2/node_modules/file-type/index.js
var require_file_type3 = __commonJS({
  "node_modules/decompress-tarbz2/node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    var toBytes = (s5) => Array.from(s5).map((c4) => c4.charCodeAt(0));
    var xpiZipFilename2 = toBytes("META-INF/mozilla.rsa");
    var oxmlContentTypes2 = toBytes("[Content_Types].xml");
    var oxmlRels2 = toBytes("_rels/.rels");
    module2.exports = (input) => {
      const buf = new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, opts) => {
        opts = Object.assign({
          offset: 0
        }, opts);
        for (let i4 = 0; i4 < header.length; i4++) {
          if (opts.mask) {
            if (header[i4] !== (opts.mask[i4] & buf[i4 + opts.offset])) {
              return false;
            }
          } else if (header[i4] !== buf[i4 + opts.offset]) {
            return false;
          }
        }
        return true;
      };
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4])) {
        if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
          return {
            ext: "epub",
            mime: "application/epub+zip"
          };
        }
        if (check(xpiZipFilename2, { offset: 30 })) {
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        }
        if (check(oxmlContentTypes2, { offset: 30 }) || check(oxmlRels2, { offset: 30 })) {
          const sliced = buf.subarray(4, 4 + 2e3);
          const nextZipHeaderIndex = (arr) => arr.findIndex((el, i4, arr2) => arr2[i4] === 80 && arr2[i4 + 1] === 75 && arr2[i4 + 2] === 3 && arr2[i4 + 3] === 4);
          const header2Pos = nextZipHeaderIndex(sliced);
          if (header2Pos !== -1) {
            const slicedAgain = buf.subarray(header2Pos + 8, header2Pos + 8 + 1e3);
            const header3Pos = nextZipHeaderIndex(slicedAgain);
            if (header3Pos !== -1) {
              const offset = 8 + header2Pos + header3Pos + 30;
              if (check(toBytes("word/"), { offset })) {
                return {
                  ext: "docx",
                  mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                };
              }
              if (check(toBytes("ppt/"), { offset })) {
                return {
                  ext: "pptx",
                  mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                };
              }
              if (check(toBytes("xl/"), { offset })) {
                return {
                  ext: "xlsx",
                  mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                };
              }
            }
          }
        }
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([51, 103, 112, 53]) || // 3gp5
      check([0, 0, 0]) && check([102, 116, 121, 112], { offset: 4 }) && (check([109, 112, 52, 49], { offset: 8 }) || // MP41
      check([109, 112, 52, 50], { offset: 8 }) || // MP42
      check([105, 115, 111, 109], { offset: 8 }) || // ISOM
      check([105, 115, 111, 50], { offset: 8 }) || // ISO2
      check([109, 109, 112, 52], { offset: 8 }) || // MMP4
      check([77, 52, 86], { offset: 8 }) || // M4V
      check([100, 97, 115, 104], { offset: 8 }))) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i4, arr) => arr[i4] === 66 && arr[i4 + 1] === 130);
        if (idPos !== -1) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => Array.from(type).every((c4, i4) => sliced[docTypePos + i4] === c4.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || // MJPEG
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70]) && check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/x-msvideo"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (check([0, 0, 1, 186])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      for (let start = 0; start < 2 && start < buf.length - 16; start++) {
        if (check([73, 68, 51], { offset: start }) || // ID3 header
        check([255, 226], { offset: start, mask: [255, 226] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 }) || check([77, 52, 65, 32])) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([82, 73, 70, 70]) && check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/x-wav"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      return null;
    };
  }
});

// node_modules/seek-bzip/lib/bitreader.js
var require_bitreader = __commonJS({
  "node_modules/seek-bzip/lib/bitreader.js"(exports2, module2) {
    var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
    var BitReader = function(stream2) {
      this.stream = stream2;
      this.bitOffset = 0;
      this.curByte = 0;
      this.hasByte = false;
    };
    BitReader.prototype._ensureByte = function() {
      if (!this.hasByte) {
        this.curByte = this.stream.readByte();
        this.hasByte = true;
      }
    };
    BitReader.prototype.read = function(bits) {
      var result = 0;
      while (bits > 0) {
        this._ensureByte();
        var remaining = 8 - this.bitOffset;
        if (bits >= remaining) {
          result <<= remaining;
          result |= BITMASK[remaining] & this.curByte;
          this.hasByte = false;
          this.bitOffset = 0;
          bits -= remaining;
        } else {
          result <<= bits;
          var shift = remaining - bits;
          result |= (this.curByte & BITMASK[bits] << shift) >> shift;
          this.bitOffset += bits;
          bits = 0;
        }
      }
      return result;
    };
    BitReader.prototype.seek = function(pos) {
      var n_bit = pos % 8;
      var n_byte = (pos - n_bit) / 8;
      this.bitOffset = n_bit;
      this.stream.seek(n_byte);
      this.hasByte = false;
    };
    BitReader.prototype.pi = function() {
      var buf = new Buffer(6), i4;
      for (i4 = 0; i4 < buf.length; i4++) {
        buf[i4] = this.read(8);
      }
      return buf.toString("hex");
    };
    module2.exports = BitReader;
  }
});

// node_modules/seek-bzip/lib/stream.js
var require_stream2 = __commonJS({
  "node_modules/seek-bzip/lib/stream.js"(exports2, module2) {
    var Stream = function() {
    };
    Stream.prototype.readByte = function() {
      throw new Error("abstract method readByte() not implemented");
    };
    Stream.prototype.read = function(buffer, bufOffset, length2) {
      var bytesRead = 0;
      while (bytesRead < length2) {
        var c4 = this.readByte();
        if (c4 < 0) {
          return bytesRead === 0 ? -1 : bytesRead;
        }
        buffer[bufOffset++] = c4;
        bytesRead++;
      }
      return bytesRead;
    };
    Stream.prototype.seek = function(new_pos) {
      throw new Error("abstract method seek() not implemented");
    };
    Stream.prototype.writeByte = function(_byte) {
      throw new Error("abstract method readByte() not implemented");
    };
    Stream.prototype.write = function(buffer, bufOffset, length2) {
      var i4;
      for (i4 = 0; i4 < length2; i4++) {
        this.writeByte(buffer[bufOffset++]);
      }
      return length2;
    };
    Stream.prototype.flush = function() {
    };
    module2.exports = Stream;
  }
});

// node_modules/seek-bzip/lib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/seek-bzip/lib/crc32.js"(exports2, module2) {
    module2.exports = function() {
      var crc32Lookup = new Uint32Array([
        0,
        79764919,
        159529838,
        222504665,
        319059676,
        398814059,
        445009330,
        507990021,
        638119352,
        583659535,
        797628118,
        726387553,
        890018660,
        835552979,
        1015980042,
        944750013,
        1276238704,
        1221641927,
        1167319070,
        1095957929,
        1595256236,
        1540665371,
        1452775106,
        1381403509,
        1780037320,
        1859660671,
        1671105958,
        1733955601,
        2031960084,
        2111593891,
        1889500026,
        1952343757,
        2552477408,
        2632100695,
        2443283854,
        2506133561,
        2334638140,
        2414271883,
        2191915858,
        2254759653,
        3190512472,
        3135915759,
        3081330742,
        3009969537,
        2905550212,
        2850959411,
        2762807018,
        2691435357,
        3560074640,
        3505614887,
        3719321342,
        3648080713,
        3342211916,
        3287746299,
        3467911202,
        3396681109,
        4063920168,
        4143685023,
        4223187782,
        4286162673,
        3779000052,
        3858754371,
        3904687514,
        3967668269,
        881225847,
        809987520,
        1023691545,
        969234094,
        662832811,
        591600412,
        771767749,
        717299826,
        311336399,
        374308984,
        453813921,
        533576470,
        25881363,
        88864420,
        134795389,
        214552010,
        2023205639,
        2086057648,
        1897238633,
        1976864222,
        1804852699,
        1867694188,
        1645340341,
        1724971778,
        1587496639,
        1516133128,
        1461550545,
        1406951526,
        1302016099,
        1230646740,
        1142491917,
        1087903418,
        2896545431,
        2825181984,
        2770861561,
        2716262478,
        3215044683,
        3143675388,
        3055782693,
        3001194130,
        2326604591,
        2389456536,
        2200899649,
        2280525302,
        2578013683,
        2640855108,
        2418763421,
        2498394922,
        3769900519,
        3832873040,
        3912640137,
        3992402750,
        4088425275,
        4151408268,
        4197601365,
        4277358050,
        3334271071,
        3263032808,
        3476998961,
        3422541446,
        3585640067,
        3514407732,
        3694837229,
        3640369242,
        1762451694,
        1842216281,
        1619975040,
        1682949687,
        2047383090,
        2127137669,
        1938468188,
        2001449195,
        1325665622,
        1271206113,
        1183200824,
        1111960463,
        1543535498,
        1489069629,
        1434599652,
        1363369299,
        622672798,
        568075817,
        748617968,
        677256519,
        907627842,
        853037301,
        1067152940,
        995781531,
        51762726,
        131386257,
        177728840,
        240578815,
        269590778,
        349224269,
        429104020,
        491947555,
        4046411278,
        4126034873,
        4172115296,
        4234965207,
        3794477266,
        3874110821,
        3953728444,
        4016571915,
        3609705398,
        3555108353,
        3735388376,
        3664026991,
        3290680682,
        3236090077,
        3449943556,
        3378572211,
        3174993278,
        3120533705,
        3032266256,
        2961025959,
        2923101090,
        2868635157,
        2813903052,
        2742672763,
        2604032198,
        2683796849,
        2461293480,
        2524268063,
        2284983834,
        2364738477,
        2175806836,
        2238787779,
        1569362073,
        1498123566,
        1409854455,
        1355396672,
        1317987909,
        1246755826,
        1192025387,
        1137557660,
        2072149281,
        2135122070,
        1912620623,
        1992383480,
        1753615357,
        1816598090,
        1627664531,
        1707420964,
        295390185,
        358241886,
        404320391,
        483945776,
        43990325,
        106832002,
        186451547,
        266083308,
        932423249,
        861060070,
        1041341759,
        986742920,
        613929101,
        542559546,
        756411363,
        701822548,
        3316196985,
        3244833742,
        3425377559,
        3370778784,
        3601682597,
        3530312978,
        3744426955,
        3689838204,
        3819031489,
        3881883254,
        3928223919,
        4007849240,
        4037393693,
        4100235434,
        4180117107,
        4259748804,
        2310601993,
        2373574846,
        2151335527,
        2231098320,
        2596047829,
        2659030626,
        2470359227,
        2550115596,
        2947551409,
        2876312838,
        2788305887,
        2733848168,
        3165939309,
        3094707162,
        3040238851,
        2985771188
      ]);
      var CRC32 = function() {
        var crc = 4294967295;
        this.getCRC = function() {
          return ~crc >>> 0;
        };
        this.updateCRC = function(value) {
          crc = crc << 8 ^ crc32Lookup[(crc >>> 24 ^ value) & 255];
        };
        this.updateCRCRun = function(value, count) {
          while (count-- > 0) {
            crc = crc << 8 ^ crc32Lookup[(crc >>> 24 ^ value) & 255];
          }
        };
      };
      return CRC32;
    }();
  }
});

// node_modules/seek-bzip/package.json
var require_package = __commonJS({
  "node_modules/seek-bzip/package.json"(exports2, module2) {
    module2.exports = {
      name: "seek-bzip",
      version: "1.0.6",
      contributors: [
        "C. Scott Ananian (http://cscott.net)",
        "Eli Skeggs",
        "Kevin Kwok",
        "Rob Landley (http://landley.net)"
      ],
      description: "a pure-JavaScript Node.JS module for random-access decoding bzip2 data",
      main: "./lib/index.js",
      repository: {
        type: "git",
        url: "https://github.com/cscott/seek-bzip.git"
      },
      license: "MIT",
      bin: {
        "seek-bunzip": "./bin/seek-bunzip",
        "seek-table": "./bin/seek-bzip-table"
      },
      directories: {
        test: "test"
      },
      dependencies: {
        commander: "^2.8.1"
      },
      devDependencies: {
        fibers: "~1.0.6",
        mocha: "~2.2.5"
      },
      scripts: {
        test: "mocha"
      }
    };
  }
});

// node_modules/seek-bzip/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/seek-bzip/lib/index.js"(exports2, module2) {
    var BitReader = require_bitreader();
    var Stream = require_stream2();
    var CRC32 = require_crc32();
    var pjson = require_package();
    var MAX_HUFCODE_BITS = 20;
    var MAX_SYMBOLS = 258;
    var SYMBOL_RUNA = 0;
    var SYMBOL_RUNB = 1;
    var MIN_GROUPS = 2;
    var MAX_GROUPS = 6;
    var GROUP_SIZE = 50;
    var WHOLEPI = "314159265359";
    var SQRTPI = "177245385090";
    var mtf = function(array, index2) {
      var src = array[index2], i4;
      for (i4 = index2; i4 > 0; i4--) {
        array[i4] = array[i4 - 1];
      }
      array[0] = src;
      return src;
    };
    var Err = {
      OK: 0,
      LAST_BLOCK: -1,
      NOT_BZIP_DATA: -2,
      UNEXPECTED_INPUT_EOF: -3,
      UNEXPECTED_OUTPUT_EOF: -4,
      DATA_ERROR: -5,
      OUT_OF_MEMORY: -6,
      OBSOLETE_INPUT: -7,
      END_OF_BLOCK: -8
    };
    var ErrorMessages = {};
    ErrorMessages[Err.LAST_BLOCK] = "Bad file checksum";
    ErrorMessages[Err.NOT_BZIP_DATA] = "Not bzip data";
    ErrorMessages[Err.UNEXPECTED_INPUT_EOF] = "Unexpected input EOF";
    ErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF";
    ErrorMessages[Err.DATA_ERROR] = "Data error";
    ErrorMessages[Err.OUT_OF_MEMORY] = "Out of memory";
    ErrorMessages[Err.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";
    var _throw = function(status, optDetail) {
      var msg = ErrorMessages[status] || "unknown error";
      if (optDetail) {
        msg += ": " + optDetail;
      }
      var e3 = new TypeError(msg);
      e3.errorCode = status;
      throw e3;
    };
    var Bunzip = function(inputStream, outputStream) {
      this.writePos = this.writeCurrent = this.writeCount = 0;
      this._start_bunzip(inputStream, outputStream);
    };
    Bunzip.prototype._init_block = function() {
      var moreBlocks = this._get_next_block();
      if (!moreBlocks) {
        this.writeCount = -1;
        return false;
      }
      this.blockCRC = new CRC32();
      return true;
    };
    Bunzip.prototype._start_bunzip = function(inputStream, outputStream) {
      var buf = new Buffer(4);
      if (inputStream.read(buf, 0, 4) !== 4 || String.fromCharCode(buf[0], buf[1], buf[2]) !== "BZh")
        _throw(Err.NOT_BZIP_DATA, "bad magic");
      var level = buf[3] - 48;
      if (level < 1 || level > 9)
        _throw(Err.NOT_BZIP_DATA, "level out of range");
      this.reader = new BitReader(inputStream);
      this.dbufSize = 1e5 * level;
      this.nextoutput = 0;
      this.outputStream = outputStream;
      this.streamCRC = 0;
    };
    Bunzip.prototype._get_next_block = function() {
      var i4, j4, k4;
      var reader = this.reader;
      var h4 = reader.pi();
      if (h4 === SQRTPI) {
        return false;
      }
      if (h4 !== WHOLEPI)
        _throw(Err.NOT_BZIP_DATA);
      this.targetBlockCRC = reader.read(32) >>> 0;
      this.streamCRC = (this.targetBlockCRC ^ (this.streamCRC << 1 | this.streamCRC >>> 31)) >>> 0;
      if (reader.read(1))
        _throw(Err.OBSOLETE_INPUT);
      var origPointer = reader.read(24);
      if (origPointer > this.dbufSize)
        _throw(Err.DATA_ERROR, "initial position out of bounds");
      var t3 = reader.read(16);
      var symToByte = new Buffer(256), symTotal = 0;
      for (i4 = 0; i4 < 16; i4++) {
        if (t3 & 1 << 15 - i4) {
          var o4 = i4 * 16;
          k4 = reader.read(16);
          for (j4 = 0; j4 < 16; j4++)
            if (k4 & 1 << 15 - j4)
              symToByte[symTotal++] = o4 + j4;
        }
      }
      var groupCount = reader.read(3);
      if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS)
        _throw(Err.DATA_ERROR);
      var nSelectors = reader.read(15);
      if (nSelectors === 0)
        _throw(Err.DATA_ERROR);
      var mtfSymbol = new Buffer(256);
      for (i4 = 0; i4 < groupCount; i4++)
        mtfSymbol[i4] = i4;
      var selectors = new Buffer(nSelectors);
      for (i4 = 0; i4 < nSelectors; i4++) {
        for (j4 = 0; reader.read(1); j4++)
          if (j4 >= groupCount)
            _throw(Err.DATA_ERROR);
        selectors[i4] = mtf(mtfSymbol, j4);
      }
      var symCount = symTotal + 2;
      var groups = [], hufGroup;
      for (j4 = 0; j4 < groupCount; j4++) {
        var length2 = new Buffer(symCount), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);
        t3 = reader.read(5);
        for (i4 = 0; i4 < symCount; i4++) {
          for (; ; ) {
            if (t3 < 1 || t3 > MAX_HUFCODE_BITS)
              _throw(Err.DATA_ERROR);
            if (!reader.read(1))
              break;
            if (!reader.read(1))
              t3++;
            else
              t3--;
          }
          length2[i4] = t3;
        }
        var minLen, maxLen;
        minLen = maxLen = length2[0];
        for (i4 = 1; i4 < symCount; i4++) {
          if (length2[i4] > maxLen)
            maxLen = length2[i4];
          else if (length2[i4] < minLen)
            minLen = length2[i4];
        }
        hufGroup = {};
        groups.push(hufGroup);
        hufGroup.permute = new Uint16Array(MAX_SYMBOLS);
        hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 2);
        hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.minLen = minLen;
        hufGroup.maxLen = maxLen;
        var pp = 0;
        for (i4 = minLen; i4 <= maxLen; i4++) {
          temp[i4] = hufGroup.limit[i4] = 0;
          for (t3 = 0; t3 < symCount; t3++)
            if (length2[t3] === i4)
              hufGroup.permute[pp++] = t3;
        }
        for (i4 = 0; i4 < symCount; i4++)
          temp[length2[i4]]++;
        pp = t3 = 0;
        for (i4 = minLen; i4 < maxLen; i4++) {
          pp += temp[i4];
          hufGroup.limit[i4] = pp - 1;
          pp <<= 1;
          t3 += temp[i4];
          hufGroup.base[i4 + 1] = pp - t3;
        }
        hufGroup.limit[maxLen + 1] = Number.MAX_VALUE;
        hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;
        hufGroup.base[minLen] = 0;
      }
      var byteCount = new Uint32Array(256);
      for (i4 = 0; i4 < 256; i4++)
        mtfSymbol[i4] = i4;
      var runPos = 0, dbufCount = 0, selector = 0, uc;
      var dbuf = this.dbuf = new Uint32Array(this.dbufSize);
      symCount = 0;
      for (; ; ) {
        if (!symCount--) {
          symCount = GROUP_SIZE - 1;
          if (selector >= nSelectors) {
            _throw(Err.DATA_ERROR);
          }
          hufGroup = groups[selectors[selector++]];
        }
        i4 = hufGroup.minLen;
        j4 = reader.read(i4);
        for (; ; i4++) {
          if (i4 > hufGroup.maxLen) {
            _throw(Err.DATA_ERROR);
          }
          if (j4 <= hufGroup.limit[i4])
            break;
          j4 = j4 << 1 | reader.read(1);
        }
        j4 -= hufGroup.base[i4];
        if (j4 < 0 || j4 >= MAX_SYMBOLS) {
          _throw(Err.DATA_ERROR);
        }
        var nextSym = hufGroup.permute[j4];
        if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {
          if (!runPos) {
            runPos = 1;
            t3 = 0;
          }
          if (nextSym === SYMBOL_RUNA)
            t3 += runPos;
          else
            t3 += 2 * runPos;
          runPos <<= 1;
          continue;
        }
        if (runPos) {
          runPos = 0;
          if (dbufCount + t3 > this.dbufSize) {
            _throw(Err.DATA_ERROR);
          }
          uc = symToByte[mtfSymbol[0]];
          byteCount[uc] += t3;
          while (t3--)
            dbuf[dbufCount++] = uc;
        }
        if (nextSym > symTotal)
          break;
        if (dbufCount >= this.dbufSize) {
          _throw(Err.DATA_ERROR);
        }
        i4 = nextSym - 1;
        uc = mtf(mtfSymbol, i4);
        uc = symToByte[uc];
        byteCount[uc]++;
        dbuf[dbufCount++] = uc;
      }
      if (origPointer < 0 || origPointer >= dbufCount) {
        _throw(Err.DATA_ERROR);
      }
      j4 = 0;
      for (i4 = 0; i4 < 256; i4++) {
        k4 = j4 + byteCount[i4];
        byteCount[i4] = j4;
        j4 = k4;
      }
      for (i4 = 0; i4 < dbufCount; i4++) {
        uc = dbuf[i4] & 255;
        dbuf[byteCount[uc]] |= i4 << 8;
        byteCount[uc]++;
      }
      var pos = 0, current = 0, run = 0;
      if (dbufCount) {
        pos = dbuf[origPointer];
        current = pos & 255;
        pos >>= 8;
        run = -1;
      }
      this.writePos = pos;
      this.writeCurrent = current;
      this.writeCount = dbufCount;
      this.writeRun = run;
      return true;
    };
    Bunzip.prototype._read_bunzip = function(outputBuffer, len) {
      var copies, previous, outbyte;
      if (this.writeCount < 0) {
        return 0;
      }
      var gotcount = 0;
      var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;
      var dbufCount = this.writeCount, outputsize = this.outputsize;
      var run = this.writeRun;
      while (dbufCount) {
        dbufCount--;
        previous = current;
        pos = dbuf[pos];
        current = pos & 255;
        pos >>= 8;
        if (run++ === 3) {
          copies = current;
          outbyte = previous;
          current = -1;
        } else {
          copies = 1;
          outbyte = current;
        }
        this.blockCRC.updateCRCRun(outbyte, copies);
        while (copies--) {
          this.outputStream.writeByte(outbyte);
          this.nextoutput++;
        }
        if (current != previous)
          run = 0;
      }
      this.writeCount = dbufCount;
      if (this.blockCRC.getCRC() !== this.targetBlockCRC) {
        _throw(Err.DATA_ERROR, "Bad block CRC (got " + this.blockCRC.getCRC().toString(16) + " expected " + this.targetBlockCRC.toString(16) + ")");
      }
      return this.nextoutput;
    };
    var coerceInputStream = function(input) {
      if ("readByte" in input) {
        return input;
      }
      var inputStream = new Stream();
      inputStream.pos = 0;
      inputStream.readByte = function() {
        return input[this.pos++];
      };
      inputStream.seek = function(pos) {
        this.pos = pos;
      };
      inputStream.eof = function() {
        return this.pos >= input.length;
      };
      return inputStream;
    };
    var coerceOutputStream = function(output) {
      var outputStream = new Stream();
      var resizeOk = true;
      if (output) {
        if (typeof output === "number") {
          outputStream.buffer = new Buffer(output);
          resizeOk = false;
        } else if ("writeByte" in output) {
          return output;
        } else {
          outputStream.buffer = output;
          resizeOk = false;
        }
      } else {
        outputStream.buffer = new Buffer(16384);
      }
      outputStream.pos = 0;
      outputStream.writeByte = function(_byte) {
        if (resizeOk && this.pos >= this.buffer.length) {
          var newBuffer = new Buffer(this.buffer.length * 2);
          this.buffer.copy(newBuffer);
          this.buffer = newBuffer;
        }
        this.buffer[this.pos++] = _byte;
      };
      outputStream.getBuffer = function() {
        if (this.pos !== this.buffer.length) {
          if (!resizeOk)
            throw new TypeError("outputsize does not match decoded input");
          var newBuffer = new Buffer(this.pos);
          this.buffer.copy(newBuffer, 0, 0, this.pos);
          this.buffer = newBuffer;
        }
        return this.buffer;
      };
      outputStream._coerced = true;
      return outputStream;
    };
    Bunzip.Err = Err;
    Bunzip.decode = function(input, output, multistream) {
      var inputStream = coerceInputStream(input);
      var outputStream = coerceOutputStream(output);
      var bz = new Bunzip(inputStream, outputStream);
      while (true) {
        if ("eof" in inputStream && inputStream.eof())
          break;
        if (bz._init_block()) {
          bz._read_bunzip();
        } else {
          var targetStreamCRC = bz.reader.read(32) >>> 0;
          if (targetStreamCRC !== bz.streamCRC) {
            _throw(Err.DATA_ERROR, "Bad stream CRC (got " + bz.streamCRC.toString(16) + " expected " + targetStreamCRC.toString(16) + ")");
          }
          if (multistream && "eof" in inputStream && !inputStream.eof()) {
            bz._start_bunzip(inputStream, outputStream);
          } else
            break;
        }
      }
      if ("getBuffer" in outputStream)
        return outputStream.getBuffer();
    };
    Bunzip.decodeBlock = function(input, pos, output) {
      var inputStream = coerceInputStream(input);
      var outputStream = coerceOutputStream(output);
      var bz = new Bunzip(inputStream, outputStream);
      bz.reader.seek(pos);
      var moreBlocks = bz._get_next_block();
      if (moreBlocks) {
        bz.blockCRC = new CRC32();
        bz.writeCopies = 0;
        bz._read_bunzip();
      }
      if ("getBuffer" in outputStream)
        return outputStream.getBuffer();
    };
    Bunzip.table = function(input, callback, multistream) {
      var inputStream = new Stream();
      inputStream.delegate = coerceInputStream(input);
      inputStream.pos = 0;
      inputStream.readByte = function() {
        this.pos++;
        return this.delegate.readByte();
      };
      if (inputStream.delegate.eof) {
        inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);
      }
      var outputStream = new Stream();
      outputStream.pos = 0;
      outputStream.writeByte = function() {
        this.pos++;
      };
      var bz = new Bunzip(inputStream, outputStream);
      var blockSize = bz.dbufSize;
      while (true) {
        if ("eof" in inputStream && inputStream.eof())
          break;
        var position2 = inputStream.pos * 8 + bz.reader.bitOffset;
        if (bz.reader.hasByte) {
          position2 -= 8;
        }
        if (bz._init_block()) {
          var start = outputStream.pos;
          bz._read_bunzip();
          callback(position2, outputStream.pos - start);
        } else {
          var crc = bz.reader.read(32);
          if (multistream && "eof" in inputStream && !inputStream.eof()) {
            bz._start_bunzip(inputStream, outputStream);
            console.assert(
              bz.dbufSize === blockSize,
              "shouldn't change block size within multistream file"
            );
          } else
            break;
        }
      }
    };
    Bunzip.Stream = Stream;
    Bunzip.version = pjson.version;
    Bunzip.license = pjson.license;
    module2.exports = Bunzip;
  }
});

// node_modules/through/index.js
var require_through = __commonJS({
  "node_modules/through/index.js"(exports2, module2) {
    var Stream = require("stream");
    exports2 = module2.exports = through;
    through.through = through;
    function through(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      };
      end = end || function() {
        this.queue(null);
      };
      var ended = false, destroyed = false, buffer = [], _ended = false;
      var stream2 = new Stream();
      stream2.readable = stream2.writable = true;
      stream2.paused = false;
      stream2.autoDestroy = !(opts && opts.autoDestroy === false);
      stream2.write = function(data) {
        write.call(this, data);
        return !stream2.paused;
      };
      function drain() {
        while (buffer.length && !stream2.paused) {
          var data = buffer.shift();
          if (null === data)
            return stream2.emit("end");
          else
            stream2.emit("data", data);
        }
      }
      stream2.queue = stream2.push = function(data) {
        if (_ended)
          return stream2;
        if (data === null)
          _ended = true;
        buffer.push(data);
        drain();
        return stream2;
      };
      stream2.on("end", function() {
        stream2.readable = false;
        if (!stream2.writable && stream2.autoDestroy)
          process.nextTick(function() {
            stream2.destroy();
          });
      });
      function _end() {
        stream2.writable = false;
        end.call(stream2);
        if (!stream2.readable && stream2.autoDestroy)
          stream2.destroy();
      }
      stream2.end = function(data) {
        if (ended)
          return;
        ended = true;
        if (arguments.length)
          stream2.write(data);
        _end();
        return stream2;
      };
      stream2.destroy = function() {
        if (destroyed)
          return;
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream2.writable = stream2.readable = false;
        stream2.emit("close");
        return stream2;
      };
      stream2.pause = function() {
        if (stream2.paused)
          return;
        stream2.paused = true;
        return stream2;
      };
      stream2.resume = function() {
        if (stream2.paused) {
          stream2.paused = false;
          stream2.emit("resume");
        }
        drain();
        if (!stream2.paused)
          stream2.emit("drain");
        return stream2;
      };
      return stream2;
    }
  }
});

// node_modules/unbzip2-stream/lib/bzip2.js
var require_bzip2 = __commonJS({
  "node_modules/unbzip2-stream/lib/bzip2.js"(exports2, module2) {
    function Bzip2Error(message2) {
      this.name = "Bzip2Error";
      this.message = message2;
      this.stack = new Error().stack;
    }
    Bzip2Error.prototype = new Error();
    var message = {
      Error: function(message2) {
        throw new Bzip2Error(message2);
      }
    };
    var bzip2 = {};
    bzip2.Bzip2Error = Bzip2Error;
    bzip2.crcTable = [
      0,
      79764919,
      159529838,
      222504665,
      319059676,
      398814059,
      445009330,
      507990021,
      638119352,
      583659535,
      797628118,
      726387553,
      890018660,
      835552979,
      1015980042,
      944750013,
      1276238704,
      1221641927,
      1167319070,
      1095957929,
      1595256236,
      1540665371,
      1452775106,
      1381403509,
      1780037320,
      1859660671,
      1671105958,
      1733955601,
      2031960084,
      2111593891,
      1889500026,
      1952343757,
      2552477408,
      2632100695,
      2443283854,
      2506133561,
      2334638140,
      2414271883,
      2191915858,
      2254759653,
      3190512472,
      3135915759,
      3081330742,
      3009969537,
      2905550212,
      2850959411,
      2762807018,
      2691435357,
      3560074640,
      3505614887,
      3719321342,
      3648080713,
      3342211916,
      3287746299,
      3467911202,
      3396681109,
      4063920168,
      4143685023,
      4223187782,
      4286162673,
      3779000052,
      3858754371,
      3904687514,
      3967668269,
      881225847,
      809987520,
      1023691545,
      969234094,
      662832811,
      591600412,
      771767749,
      717299826,
      311336399,
      374308984,
      453813921,
      533576470,
      25881363,
      88864420,
      134795389,
      214552010,
      2023205639,
      2086057648,
      1897238633,
      1976864222,
      1804852699,
      1867694188,
      1645340341,
      1724971778,
      1587496639,
      1516133128,
      1461550545,
      1406951526,
      1302016099,
      1230646740,
      1142491917,
      1087903418,
      2896545431,
      2825181984,
      2770861561,
      2716262478,
      3215044683,
      3143675388,
      3055782693,
      3001194130,
      2326604591,
      2389456536,
      2200899649,
      2280525302,
      2578013683,
      2640855108,
      2418763421,
      2498394922,
      3769900519,
      3832873040,
      3912640137,
      3992402750,
      4088425275,
      4151408268,
      4197601365,
      4277358050,
      3334271071,
      3263032808,
      3476998961,
      3422541446,
      3585640067,
      3514407732,
      3694837229,
      3640369242,
      1762451694,
      1842216281,
      1619975040,
      1682949687,
      2047383090,
      2127137669,
      1938468188,
      2001449195,
      1325665622,
      1271206113,
      1183200824,
      1111960463,
      1543535498,
      1489069629,
      1434599652,
      1363369299,
      622672798,
      568075817,
      748617968,
      677256519,
      907627842,
      853037301,
      1067152940,
      995781531,
      51762726,
      131386257,
      177728840,
      240578815,
      269590778,
      349224269,
      429104020,
      491947555,
      4046411278,
      4126034873,
      4172115296,
      4234965207,
      3794477266,
      3874110821,
      3953728444,
      4016571915,
      3609705398,
      3555108353,
      3735388376,
      3664026991,
      3290680682,
      3236090077,
      3449943556,
      3378572211,
      3174993278,
      3120533705,
      3032266256,
      2961025959,
      2923101090,
      2868635157,
      2813903052,
      2742672763,
      2604032198,
      2683796849,
      2461293480,
      2524268063,
      2284983834,
      2364738477,
      2175806836,
      2238787779,
      1569362073,
      1498123566,
      1409854455,
      1355396672,
      1317987909,
      1246755826,
      1192025387,
      1137557660,
      2072149281,
      2135122070,
      1912620623,
      1992383480,
      1753615357,
      1816598090,
      1627664531,
      1707420964,
      295390185,
      358241886,
      404320391,
      483945776,
      43990325,
      106832002,
      186451547,
      266083308,
      932423249,
      861060070,
      1041341759,
      986742920,
      613929101,
      542559546,
      756411363,
      701822548,
      3316196985,
      3244833742,
      3425377559,
      3370778784,
      3601682597,
      3530312978,
      3744426955,
      3689838204,
      3819031489,
      3881883254,
      3928223919,
      4007849240,
      4037393693,
      4100235434,
      4180117107,
      4259748804,
      2310601993,
      2373574846,
      2151335527,
      2231098320,
      2596047829,
      2659030626,
      2470359227,
      2550115596,
      2947551409,
      2876312838,
      2788305887,
      2733848168,
      3165939309,
      3094707162,
      3040238851,
      2985771188
    ];
    bzip2.array = function(bytes) {
      var bit = 0, byte = 0;
      var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
      return function(n3) {
        var result = 0;
        while (n3 > 0) {
          var left = 8 - bit;
          if (n3 >= left) {
            result <<= left;
            result |= BITMASK[left] & bytes[byte++];
            bit = 0;
            n3 -= left;
          } else {
            result <<= n3;
            result |= (bytes[byte] & BITMASK[n3] << 8 - n3 - bit) >> 8 - n3 - bit;
            bit += n3;
            n3 = 0;
          }
        }
        return result;
      };
    };
    bzip2.simple = function(srcbuffer, stream2) {
      var bits = bzip2.array(srcbuffer);
      var size = bzip2.header(bits);
      var ret = false;
      var bufsize = 1e5 * size;
      var buf = new Int32Array(bufsize);
      do {
        ret = bzip2.decompress(bits, stream2, buf, bufsize);
      } while (!ret);
    };
    bzip2.header = function(bits) {
      this.byteCount = new Int32Array(256);
      this.symToByte = new Uint8Array(256);
      this.mtfSymbol = new Int32Array(256);
      this.selectors = new Uint8Array(32768);
      if (bits(8 * 3) != 4348520)
        message.Error("No magic number found");
      var i4 = bits(8) - 48;
      if (i4 < 1 || i4 > 9)
        message.Error("Not a BZIP archive");
      return i4;
    };
    bzip2.decompress = function(bits, stream2, buf, bufsize, streamCRC) {
      var MAX_HUFCODE_BITS = 20;
      var MAX_SYMBOLS = 258;
      var SYMBOL_RUNA = 0;
      var SYMBOL_RUNB = 1;
      var GROUP_SIZE = 50;
      var crc = 0 ^ -1;
      for (var h4 = "", i4 = 0; i4 < 6; i4++)
        h4 += bits(8).toString(16);
      if (h4 == "177245385090") {
        var finalCRC = bits(32) | 0;
        if (finalCRC !== streamCRC)
          message.Error("Error in bzip2: crc32 do not match");
        bits(null);
        return null;
      }
      if (h4 != "314159265359")
        message.Error("eek not valid bzip data");
      var crcblock = bits(32) | 0;
      if (bits(1))
        message.Error("unsupported obsolete version");
      var origPtr = bits(24);
      if (origPtr > bufsize)
        message.Error("Initial position larger than buffer size");
      var t3 = bits(16);
      var symTotal = 0;
      for (i4 = 0; i4 < 16; i4++) {
        if (t3 & 1 << 15 - i4) {
          var k4 = bits(16);
          for (j4 = 0; j4 < 16; j4++) {
            if (k4 & 1 << 15 - j4) {
              this.symToByte[symTotal++] = 16 * i4 + j4;
            }
          }
        }
      }
      var groupCount = bits(3);
      if (groupCount < 2 || groupCount > 6)
        message.Error("another error");
      var nSelectors = bits(15);
      if (nSelectors == 0)
        message.Error("meh");
      for (var i4 = 0; i4 < groupCount; i4++)
        this.mtfSymbol[i4] = i4;
      for (var i4 = 0; i4 < nSelectors; i4++) {
        for (var j4 = 0; bits(1); j4++)
          if (j4 >= groupCount)
            message.Error("whoops another error");
        var uc = this.mtfSymbol[j4];
        for (var k4 = j4 - 1; k4 >= 0; k4--) {
          this.mtfSymbol[k4 + 1] = this.mtfSymbol[k4];
        }
        this.mtfSymbol[0] = uc;
        this.selectors[i4] = uc;
      }
      var symCount = symTotal + 2;
      var groups = [];
      var length2 = new Uint8Array(MAX_SYMBOLS), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);
      var hufGroup;
      for (var j4 = 0; j4 < groupCount; j4++) {
        t3 = bits(5);
        for (var i4 = 0; i4 < symCount; i4++) {
          while (true) {
            if (t3 < 1 || t3 > MAX_HUFCODE_BITS)
              message.Error("I gave up a while ago on writing error messages");
            if (!bits(1))
              break;
            if (!bits(1))
              t3++;
            else
              t3--;
          }
          length2[i4] = t3;
        }
        var minLen, maxLen;
        minLen = maxLen = length2[0];
        for (var i4 = 1; i4 < symCount; i4++) {
          if (length2[i4] > maxLen)
            maxLen = length2[i4];
          else if (length2[i4] < minLen)
            minLen = length2[i4];
        }
        hufGroup = groups[j4] = {};
        hufGroup.permute = new Int32Array(MAX_SYMBOLS);
        hufGroup.limit = new Int32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.base = new Int32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.minLen = minLen;
        hufGroup.maxLen = maxLen;
        var base = hufGroup.base;
        var limit = hufGroup.limit;
        var pp = 0;
        for (var i4 = minLen; i4 <= maxLen; i4++)
          for (var t3 = 0; t3 < symCount; t3++)
            if (length2[t3] == i4)
              hufGroup.permute[pp++] = t3;
        for (i4 = minLen; i4 <= maxLen; i4++)
          temp[i4] = limit[i4] = 0;
        for (i4 = 0; i4 < symCount; i4++)
          temp[length2[i4]]++;
        pp = t3 = 0;
        for (i4 = minLen; i4 < maxLen; i4++) {
          pp += temp[i4];
          limit[i4] = pp - 1;
          pp <<= 1;
          base[i4 + 1] = pp - (t3 += temp[i4]);
        }
        limit[maxLen] = pp + temp[maxLen] - 1;
        base[minLen] = 0;
      }
      for (var i4 = 0; i4 < 256; i4++) {
        this.mtfSymbol[i4] = i4;
        this.byteCount[i4] = 0;
      }
      var runPos, count, symCount, selector;
      runPos = count = symCount = selector = 0;
      while (true) {
        if (!symCount--) {
          symCount = GROUP_SIZE - 1;
          if (selector >= nSelectors)
            message.Error("meow i'm a kitty, that's an error");
          hufGroup = groups[this.selectors[selector++]];
          base = hufGroup.base;
          limit = hufGroup.limit;
        }
        i4 = hufGroup.minLen;
        j4 = bits(i4);
        while (true) {
          if (i4 > hufGroup.maxLen)
            message.Error("rawr i'm a dinosaur");
          if (j4 <= limit[i4])
            break;
          i4++;
          j4 = j4 << 1 | bits(1);
        }
        j4 -= base[i4];
        if (j4 < 0 || j4 >= MAX_SYMBOLS)
          message.Error("moo i'm a cow");
        var nextSym = hufGroup.permute[j4];
        if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
          if (!runPos) {
            runPos = 1;
            t3 = 0;
          }
          if (nextSym == SYMBOL_RUNA)
            t3 += runPos;
          else
            t3 += 2 * runPos;
          runPos <<= 1;
          continue;
        }
        if (runPos) {
          runPos = 0;
          if (count + t3 > bufsize)
            message.Error("Boom.");
          uc = this.symToByte[this.mtfSymbol[0]];
          this.byteCount[uc] += t3;
          while (t3--)
            buf[count++] = uc;
        }
        if (nextSym > symTotal)
          break;
        if (count >= bufsize)
          message.Error("I can't think of anything. Error");
        i4 = nextSym - 1;
        uc = this.mtfSymbol[i4];
        for (var k4 = i4 - 1; k4 >= 0; k4--) {
          this.mtfSymbol[k4 + 1] = this.mtfSymbol[k4];
        }
        this.mtfSymbol[0] = uc;
        uc = this.symToByte[uc];
        this.byteCount[uc]++;
        buf[count++] = uc;
      }
      if (origPtr < 0 || origPtr >= count)
        message.Error("I'm a monkey and I'm throwing something at someone, namely you");
      var j4 = 0;
      for (var i4 = 0; i4 < 256; i4++) {
        k4 = j4 + this.byteCount[i4];
        this.byteCount[i4] = j4;
        j4 = k4;
      }
      for (var i4 = 0; i4 < count; i4++) {
        uc = buf[i4] & 255;
        buf[this.byteCount[uc]] |= i4 << 8;
        this.byteCount[uc]++;
      }
      var pos = 0, current = 0, run = 0;
      if (count) {
        pos = buf[origPtr];
        current = pos & 255;
        pos >>= 8;
        run = -1;
      }
      count = count;
      var copies, previous, outbyte;
      while (count) {
        count--;
        previous = current;
        pos = buf[pos];
        current = pos & 255;
        pos >>= 8;
        if (run++ == 3) {
          copies = current;
          outbyte = previous;
          current = -1;
        } else {
          copies = 1;
          outbyte = current;
        }
        while (copies--) {
          crc = (crc << 8 ^ this.crcTable[(crc >> 24 ^ outbyte) & 255]) & 4294967295;
          stream2(outbyte);
        }
        if (current != previous)
          run = 0;
      }
      crc = (crc ^ -1) >>> 0;
      if ((crc | 0) != (crcblock | 0))
        message.Error("Error in bzip2: crc32 do not match");
      streamCRC = (crc ^ (streamCRC << 1 | streamCRC >>> 31)) & 4294967295;
      return streamCRC;
    };
    module2.exports = bzip2;
  }
});

// node_modules/unbzip2-stream/lib/bit_iterator.js
var require_bit_iterator = __commonJS({
  "node_modules/unbzip2-stream/lib/bit_iterator.js"(exports2, module2) {
    var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
    module2.exports = function bitIterator(nextBuffer) {
      var bit = 0, byte = 0;
      var bytes = nextBuffer();
      var f4 = function(n3) {
        if (n3 === null && bit != 0) {
          bit = 0;
          byte++;
          return;
        }
        var result = 0;
        while (n3 > 0) {
          if (byte >= bytes.length) {
            byte = 0;
            bytes = nextBuffer();
          }
          var left = 8 - bit;
          if (bit === 0 && n3 > 0)
            f4.bytesRead++;
          if (n3 >= left) {
            result <<= left;
            result |= BITMASK[left] & bytes[byte++];
            bit = 0;
            n3 -= left;
          } else {
            result <<= n3;
            result |= (bytes[byte] & BITMASK[n3] << 8 - n3 - bit) >> 8 - n3 - bit;
            bit += n3;
            n3 = 0;
          }
        }
        return result;
      };
      f4.bytesRead = 0;
      return f4;
    };
  }
});

// node_modules/unbzip2-stream/index.js
var require_unbzip2_stream = __commonJS({
  "node_modules/unbzip2-stream/index.js"(exports2, module2) {
    var through = require_through();
    var bz2 = require_bzip2();
    var bitIterator = require_bit_iterator();
    module2.exports = unbzip2Stream;
    function unbzip2Stream() {
      var bufferQueue = [];
      var hasBytes = 0;
      var blockSize = 0;
      var broken = false;
      var done = false;
      var bitReader = null;
      var streamCRC = null;
      function decompressBlock(push) {
        if (!blockSize) {
          blockSize = bz2.header(bitReader);
          streamCRC = 0;
          return true;
        } else {
          var bufsize = 1e5 * blockSize;
          var buf = new Int32Array(bufsize);
          var chunk = [];
          var f4 = function(b4) {
            chunk.push(b4);
          };
          streamCRC = bz2.decompress(bitReader, f4, buf, bufsize, streamCRC);
          if (streamCRC === null) {
            blockSize = 0;
            return false;
          } else {
            push(Buffer.from(chunk));
            return true;
          }
        }
      }
      var outlength = 0;
      function decompressAndQueue(stream2) {
        if (broken)
          return;
        try {
          return decompressBlock(function(d5) {
            stream2.queue(d5);
            if (d5 !== null) {
              outlength += d5.length;
            } else {
            }
          });
        } catch (e3) {
          stream2.emit("error", e3);
          broken = true;
          return false;
        }
      }
      return through(
        function write(data) {
          bufferQueue.push(data);
          hasBytes += data.length;
          if (bitReader === null) {
            bitReader = bitIterator(function() {
              return bufferQueue.shift();
            });
          }
          while (!broken && hasBytes - bitReader.bytesRead + 1 >= (25e3 + 1e5 * blockSize || 4)) {
            decompressAndQueue(this);
          }
        },
        function end(x5) {
          while (!broken && bitReader && hasBytes > bitReader.bytesRead) {
            decompressAndQueue(this);
          }
          if (!broken) {
            if (streamCRC !== null)
              this.emit("error", new Error("input stream ended prematurely"));
            this.queue(null);
          }
        }
      );
    }
  }
});

// node_modules/decompress-tarbz2/index.js
var require_decompress_tarbz2 = __commonJS({
  "node_modules/decompress-tarbz2/index.js"(exports2, module2) {
    "use strict";
    var decompressTar = require_decompress_tar();
    var fileType2 = require_file_type3();
    var isStream2 = require_is_stream2();
    var seekBzip = require_lib2();
    var unbzip2Stream = require_unbzip2_stream();
    module2.exports = () => (input) => {
      if (!Buffer.isBuffer(input) && !isStream2(input)) {
        return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
      }
      if (Buffer.isBuffer(input) && (!fileType2(input) || fileType2(input).ext !== "bz2")) {
        return Promise.resolve([]);
      }
      if (Buffer.isBuffer(input)) {
        return decompressTar()(seekBzip.decode(input));
      }
      return decompressTar()(input.pipe(unbzip2Stream()));
    };
  }
});

// node_modules/decompress-targz/index.js
var require_decompress_targz = __commonJS({
  "node_modules/decompress-targz/index.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var decompressTar = require_decompress_tar();
    var fileType2 = require_file_type2();
    var isStream2 = require_is_stream2();
    module2.exports = () => (input) => {
      if (!Buffer.isBuffer(input) && !isStream2(input)) {
        return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
      }
      if (Buffer.isBuffer(input) && (!fileType2(input) || fileType2(input).ext !== "gz")) {
        return Promise.resolve([]);
      }
      const unzip = zlib.createGunzip();
      const result = decompressTar()(unzip);
      if (Buffer.isBuffer(input)) {
        unzip.end(input);
      } else {
        input.pipe(unzip);
      }
      return result;
    };
  }
});

// node_modules/decompress-unzip/node_modules/file-type/index.js
var require_file_type4 = __commonJS({
  "node_modules/decompress-unzip/node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(buf) {
      if (!(buf && buf.length > 1)) {
        return null;
      }
      if (buf[0] === 255 && buf[1] === 216 && buf[2] === 255) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (buf[0] === 137 && buf[1] === 80 && buf[2] === 78 && buf[3] === 71) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (buf[0] === 71 && buf[1] === 73 && buf[2] === 70) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (buf[8] === 87 && buf[9] === 69 && buf[10] === 66 && buf[11] === 80) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (buf[0] === 70 && buf[1] === 76 && buf[2] === 73 && buf[3] === 70) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((buf[0] === 73 && buf[1] === 73 && buf[2] === 42 && buf[3] === 0 || buf[0] === 77 && buf[1] === 77 && buf[2] === 0 && buf[3] === 42) && buf[8] === 67 && buf[9] === 82) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (buf[0] === 73 && buf[1] === 73 && buf[2] === 42 && buf[3] === 0 || buf[0] === 77 && buf[1] === 77 && buf[2] === 0 && buf[3] === 42) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (buf[0] === 66 && buf[1] === 77) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (buf[0] === 73 && buf[1] === 73 && buf[2] === 188) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (buf[0] === 56 && buf[1] === 66 && buf[2] === 80 && buf[3] === 83) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (buf[0] === 80 && buf[1] === 75 && buf[2] === 3 && buf[3] === 4 && buf[30] === 109 && buf[31] === 105 && buf[32] === 109 && buf[33] === 101 && buf[34] === 116 && buf[35] === 121 && buf[36] === 112 && buf[37] === 101 && buf[38] === 97 && buf[39] === 112 && buf[40] === 112 && buf[41] === 108 && buf[42] === 105 && buf[43] === 99 && buf[44] === 97 && buf[45] === 116 && buf[46] === 105 && buf[47] === 111 && buf[48] === 110 && buf[49] === 47 && buf[50] === 101 && buf[51] === 112 && buf[52] === 117 && buf[53] === 98 && buf[54] === 43 && buf[55] === 122 && buf[56] === 105 && buf[57] === 112) {
        return {
          ext: "epub",
          mime: "application/epub+zip"
        };
      }
      if (buf[0] === 80 && buf[1] === 75 && buf[2] === 3 && buf[3] === 4 && buf[30] === 77 && buf[31] === 69 && buf[32] === 84 && buf[33] === 65 && buf[34] === 45 && buf[35] === 73 && buf[36] === 78 && buf[37] === 70 && buf[38] === 47 && buf[39] === 109 && buf[40] === 111 && buf[41] === 122 && buf[42] === 105 && buf[43] === 108 && buf[44] === 108 && buf[45] === 97 && buf[46] === 46 && buf[47] === 114 && buf[48] === 115 && buf[49] === 97) {
        return {
          ext: "xpi",
          mime: "application/x-xpinstall"
        };
      }
      if (buf[0] === 80 && buf[1] === 75 && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (buf[257] === 117 && buf[258] === 115 && buf[259] === 116 && buf[260] === 97 && buf[261] === 114) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (buf[0] === 82 && buf[1] === 97 && buf[2] === 114 && buf[3] === 33 && buf[4] === 26 && buf[5] === 7 && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (buf[0] === 31 && buf[1] === 139 && buf[2] === 8) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (buf[0] === 66 && buf[1] === 90 && buf[2] === 104) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (buf[0] === 55 && buf[1] === 122 && buf[2] === 188 && buf[3] === 175 && buf[4] === 39 && buf[5] === 28) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (buf[0] === 120 && buf[1] === 1) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && (buf[3] === 24 || buf[3] === 32) && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 || buf[0] === 51 && buf[1] === 103 && buf[2] === 112 && buf[3] === 53 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 109 && buf[9] === 112 && buf[10] === 52 && buf[11] === 50 && buf[16] === 109 && buf[17] === 112 && buf[18] === 52 && buf[19] === 49 && buf[20] === 109 && buf[21] === 112 && buf[22] === 52 && buf[23] === 50 && buf[24] === 105 && buf[25] === 115 && buf[26] === 111 && buf[27] === 109 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 105 && buf[9] === 115 && buf[10] === 111 && buf[11] === 109 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 109 && buf[9] === 112 && buf[10] === 52 && buf[11] === 50 && buf[12] === 0 && buf[13] === 0 && buf[14] === 0 && buf[15] === 0) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 77 && buf[9] === 52 && buf[10] === 86) {
        return {
          ext: "m4v",
          mime: "video/x-m4v"
        };
      }
      if (buf[0] === 77 && buf[1] === 84 && buf[2] === 104 && buf[3] === 100) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (buf[31] === 109 && buf[32] === 97 && buf[33] === 116 && buf[34] === 114 && buf[35] === 111 && buf[36] === 115 && buf[37] === 107 && buf[38] === 97) {
        return {
          ext: "mkv",
          mime: "video/x-matroska"
        };
      }
      if (buf[0] === 26 && buf[1] === 69 && buf[2] === 223 && buf[3] === 163) {
        return {
          ext: "webm",
          mime: "video/webm"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 20 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (buf[0] === 82 && buf[1] === 73 && buf[2] === 70 && buf[3] === 70 && buf[8] === 65 && buf[9] === 86 && buf[10] === 73) {
        return {
          ext: "avi",
          mime: "video/x-msvideo"
        };
      }
      if (buf[0] === 48 && buf[1] === 38 && buf[2] === 178 && buf[3] === 117 && buf[4] === 142 && buf[5] === 102 && buf[6] === 207 && buf[7] === 17 && buf[8] === 166 && buf[9] === 217) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 1 && buf[3].toString(16)[0] === "b") {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (buf[0] === 73 && buf[1] === 68 && buf[2] === 51 || buf[0] === 255 && buf[1] === 251) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 77 && buf[9] === 52 && buf[10] === 65 || buf[0] === 77 && buf[1] === 52 && buf[2] === 65 && buf[3] === 32) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (buf[28] === 79 && buf[29] === 112 && buf[30] === 117 && buf[31] === 115 && buf[32] === 72 && buf[33] === 101 && buf[34] === 97 && buf[35] === 100) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (buf[0] === 79 && buf[1] === 103 && buf[2] === 103 && buf[3] === 83) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      if (buf[0] === 102 && buf[1] === 76 && buf[2] === 97 && buf[3] === 67) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (buf[0] === 82 && buf[1] === 73 && buf[2] === 70 && buf[3] === 70 && buf[8] === 87 && buf[9] === 65 && buf[10] === 86 && buf[11] === 69) {
        return {
          ext: "wav",
          mime: "audio/x-wav"
        };
      }
      if (buf[0] === 35 && buf[1] === 33 && buf[2] === 65 && buf[3] === 77 && buf[4] === 82 && buf[5] === 10) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (buf[0] === 37 && buf[1] === 80 && buf[2] === 68 && buf[3] === 70) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (buf[0] === 77 && buf[1] === 90) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && buf[1] === 87 && buf[2] === 83) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (buf[0] === 123 && buf[1] === 92 && buf[2] === 114 && buf[3] === 116 && buf[4] === 102) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (buf[0] === 119 && buf[1] === 79 && buf[2] === 70 && buf[3] === 70 && (buf[4] === 0 && buf[5] === 1 && buf[6] === 0 && buf[7] === 0 || buf[4] === 79 && buf[5] === 84 && buf[6] === 84 && buf[7] === 79)) {
        return {
          ext: "woff",
          mime: "application/font-woff"
        };
      }
      if (buf[0] === 119 && buf[1] === 79 && buf[2] === 70 && buf[3] === 50 && (buf[4] === 0 && buf[5] === 1 && buf[6] === 0 && buf[7] === 0 || buf[4] === 79 && buf[5] === 84 && buf[6] === 84 && buf[7] === 79)) {
        return {
          ext: "woff2",
          mime: "application/font-woff"
        };
      }
      if (buf[34] === 76 && buf[35] === 80 && (buf[8] === 0 && buf[9] === 0 && buf[10] === 1 || buf[8] === 1 && buf[9] === 0 && buf[10] === 2 || buf[8] === 2 && buf[9] === 0 && buf[10] === 2)) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (buf[0] === 0 && buf[1] === 1 && buf[2] === 0 && buf[3] === 0 && buf[4] === 0) {
        return {
          ext: "ttf",
          mime: "application/font-sfnt"
        };
      }
      if (buf[0] === 79 && buf[1] === 84 && buf[2] === 84 && buf[3] === 79 && buf[4] === 0) {
        return {
          ext: "otf",
          mime: "application/font-sfnt"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 1 && buf[3] === 0) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (buf[0] === 70 && buf[1] === 76 && buf[2] === 86 && buf[3] === 1) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (buf[0] === 37 && buf[1] === 33) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (buf[0] === 253 && buf[1] === 55 && buf[2] === 122 && buf[3] === 88 && buf[4] === 90 && buf[5] === 0) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (buf[0] === 83 && buf[1] === 81 && buf[2] === 76 && buf[3] === 105) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (buf[0] === 78 && buf[1] === 69 && buf[2] === 83 && buf[3] === 26) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (buf[0] === 67 && buf[1] === 114 && buf[2] === 50 && buf[3] === 52) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (buf[0] === 77 && buf[1] === 83 && buf[2] === 67 && buf[3] === 70 || buf[0] === 73 && buf[1] === 83 && buf[2] === 99 && buf[3] === 40) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (buf[0] === 33 && buf[1] === 60 && buf[2] === 97 && buf[3] === 114 && buf[4] === 99 && buf[5] === 104 && buf[6] === 62 && buf[7] === 10 && buf[8] === 100 && buf[9] === 101 && buf[10] === 98 && buf[11] === 105 && buf[12] === 97 && buf[13] === 110 && buf[14] === 45 && buf[15] === 98 && buf[16] === 105 && buf[17] === 110 && buf[18] === 97 && buf[19] === 114 && buf[20] === 121) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (buf[0] === 33 && buf[1] === 60 && buf[2] === 97 && buf[3] === 114 && buf[4] === 99 && buf[5] === 104 && buf[6] === 62) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (buf[0] === 237 && buf[1] === 171 && buf[2] === 238 && buf[3] === 219) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (buf[0] === 31 && buf[1] === 160 || buf[0] === 31 && buf[1] === 157) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (buf[0] === 76 && buf[1] === 90 && buf[2] === 73 && buf[3] === 80) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (buf[0] === 208 && buf[1] === 207 && buf[2] === 17 && buf[3] === 224 && buf[4] === 161 && buf[5] === 177 && buf[6] === 26 && buf[7] === 225) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      return null;
    };
  }
});

// node_modules/pinkie/index.js
var require_pinkie = __commonJS({
  "node_modules/pinkie/index.js"(exports2, module2) {
    "use strict";
    var PENDING = "pending";
    var SETTLED = "settled";
    var FULFILLED = "fulfilled";
    var REJECTED = "rejected";
    var NOOP = function() {
    };
    var isNode = typeof global !== "undefined" && typeof global.process !== "undefined" && typeof global.process.emit === "function";
    var asyncSetTimer = typeof setImmediate === "undefined" ? setTimeout : setImmediate;
    var asyncQueue = [];
    var asyncTimer;
    function asyncFlush() {
      for (var i4 = 0; i4 < asyncQueue.length; i4++) {
        asyncQueue[i4][0](asyncQueue[i4][1]);
      }
      asyncQueue = [];
      asyncTimer = false;
    }
    function asyncCall(callback, arg) {
      asyncQueue.push([callback, arg]);
      if (!asyncTimer) {
        asyncTimer = true;
        asyncSetTimer(asyncFlush, 0);
      }
    }
    function invokeResolver(resolver, promise) {
      function resolvePromise(value) {
        resolve2(promise, value);
      }
      function rejectPromise(reason) {
        reject2(promise, reason);
      }
      try {
        resolver(resolvePromise, rejectPromise);
      } catch (e3) {
        rejectPromise(e3);
      }
    }
    function invokeCallback(subscriber) {
      var owner = subscriber.owner;
      var settled = owner._state;
      var value = owner._data;
      var callback = subscriber[settled];
      var promise = subscriber.then;
      if (typeof callback === "function") {
        settled = FULFILLED;
        try {
          value = callback(value);
        } catch (e3) {
          reject2(promise, e3);
        }
      }
      if (!handleThenable(promise, value)) {
        if (settled === FULFILLED) {
          resolve2(promise, value);
        }
        if (settled === REJECTED) {
          reject2(promise, value);
        }
      }
    }
    function handleThenable(promise, value) {
      var resolved;
      try {
        if (promise === value) {
          throw new TypeError("A promises callback cannot return that same promise.");
        }
        if (value && (typeof value === "function" || typeof value === "object")) {
          var then = value.then;
          if (typeof then === "function") {
            then.call(value, function(val) {
              if (!resolved) {
                resolved = true;
                if (value === val) {
                  fulfill(promise, val);
                } else {
                  resolve2(promise, val);
                }
              }
            }, function(reason) {
              if (!resolved) {
                resolved = true;
                reject2(promise, reason);
              }
            });
            return true;
          }
        }
      } catch (e3) {
        if (!resolved) {
          reject2(promise, e3);
        }
        return true;
      }
      return false;
    }
    function resolve2(promise, value) {
      if (promise === value || !handleThenable(promise, value)) {
        fulfill(promise, value);
      }
    }
    function fulfill(promise, value) {
      if (promise._state === PENDING) {
        promise._state = SETTLED;
        promise._data = value;
        asyncCall(publishFulfillment, promise);
      }
    }
    function reject2(promise, reason) {
      if (promise._state === PENDING) {
        promise._state = SETTLED;
        promise._data = reason;
        asyncCall(publishRejection, promise);
      }
    }
    function publish(promise) {
      promise._then = promise._then.forEach(invokeCallback);
    }
    function publishFulfillment(promise) {
      promise._state = FULFILLED;
      publish(promise);
    }
    function publishRejection(promise) {
      promise._state = REJECTED;
      publish(promise);
      if (!promise._handled && isNode) {
        global.process.emit("unhandledRejection", promise._data, promise);
      }
    }
    function notifyRejectionHandled(promise) {
      global.process.emit("rejectionHandled", promise);
    }
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("Promise resolver " + resolver + " is not a function");
      }
      if (this instanceof Promise2 === false) {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      this._then = [];
      invokeResolver(resolver, this);
    }
    Promise2.prototype = {
      constructor: Promise2,
      _state: PENDING,
      _then: null,
      _data: void 0,
      _handled: false,
      then: function(onFulfillment, onRejection) {
        var subscriber = {
          owner: this,
          then: new this.constructor(NOOP),
          fulfilled: onFulfillment,
          rejected: onRejection
        };
        if ((onRejection || onFulfillment) && !this._handled) {
          this._handled = true;
          if (this._state === REJECTED && isNode) {
            asyncCall(notifyRejectionHandled, this);
          }
        }
        if (this._state === FULFILLED || this._state === REJECTED) {
          asyncCall(invokeCallback, subscriber);
        } else {
          this._then.push(subscriber);
        }
        return subscriber.then;
      },
      catch: function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    Promise2.all = function(promises) {
      if (!Array.isArray(promises)) {
        throw new TypeError("You must pass an array to Promise.all().");
      }
      return new Promise2(function(resolve3, reject3) {
        var results = [];
        var remaining = 0;
        function resolver(index2) {
          remaining++;
          return function(value) {
            results[index2] = value;
            if (!--remaining) {
              resolve3(results);
            }
          };
        }
        for (var i4 = 0, promise; i4 < promises.length; i4++) {
          promise = promises[i4];
          if (promise && typeof promise.then === "function") {
            promise.then(resolver(i4), reject3);
          } else {
            results[i4] = promise;
          }
        }
        if (!remaining) {
          resolve3(results);
        }
      });
    };
    Promise2.race = function(promises) {
      if (!Array.isArray(promises)) {
        throw new TypeError("You must pass an array to Promise.race().");
      }
      return new Promise2(function(resolve3, reject3) {
        for (var i4 = 0, promise; i4 < promises.length; i4++) {
          promise = promises[i4];
          if (promise && typeof promise.then === "function") {
            promise.then(resolve3, reject3);
          } else {
            resolve3(promise);
          }
        }
      });
    };
    Promise2.resolve = function(value) {
      if (value && typeof value === "object" && value.constructor === Promise2) {
        return value;
      }
      return new Promise2(function(resolve3) {
        resolve3(value);
      });
    };
    Promise2.reject = function(reason) {
      return new Promise2(function(resolve3, reject3) {
        reject3(reason);
      });
    };
    module2.exports = Promise2;
  }
});

// node_modules/pinkie-promise/index.js
var require_pinkie_promise = __commonJS({
  "node_modules/pinkie-promise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Promise === "function" ? Promise : require_pinkie();
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i4 = 0; i4 < 10; i4++) {
          test2["_" + String.fromCharCode(i4)] = i4;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n3) {
          return test2[n3];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s5 = 1; s5 < arguments.length; s5++) {
        from2 = Object(arguments[s5]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i4 = 0; i4 < symbols.length; i4++) {
            if (propIsEnumerable.call(from2, symbols[i4])) {
              to[symbols[i4]] = from2[symbols[i4]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/decompress-unzip/node_modules/get-stream/buffer-stream.js
var require_buffer_stream3 = __commonJS({
  "node_modules/decompress-unzip/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    var PassThrough = require("stream").PassThrough;
    var objectAssign = require_object_assign();
    module2.exports = function(opts) {
      opts = objectAssign({}, opts);
      var array = opts.array;
      var encoding = opts.encoding;
      var buffer = encoding === "buffer";
      var objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      var len = 0;
      var ret = [];
      var stream2 = new PassThrough({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      stream2.on("data", function(chunk) {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream2.getBufferedValue = function() {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream2.getBufferedLength = function() {
        return len;
      };
      return stream2;
    };
  }
});

// node_modules/decompress-unzip/node_modules/get-stream/index.js
var require_get_stream3 = __commonJS({
  "node_modules/decompress-unzip/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var Promise2 = require_pinkie_promise();
    var objectAssign = require_object_assign();
    var bufferStream = require_buffer_stream3();
    function getStream2(inputStream, opts) {
      if (!inputStream) {
        return Promise2.reject(new Error("Expected a stream"));
      }
      opts = objectAssign({ maxBuffer: Infinity }, opts);
      var maxBuffer = opts.maxBuffer;
      var stream2;
      var clean;
      var p5 = new Promise2(function(resolve2, reject2) {
        stream2 = bufferStream(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream2);
        stream2.on("data", function() {
          if (stream2.getBufferedLength() > maxBuffer) {
            reject2(new Error("maxBuffer exceeded"));
          }
        });
        stream2.once("error", error);
        stream2.on("end", resolve2);
        clean = function() {
          if (inputStream.unpipe) {
            inputStream.unpipe(stream2);
          }
        };
        function error(err) {
          if (err) {
            err.bufferedData = stream2.getBufferedValue();
          }
          reject2(err);
        }
      });
      p5.then(clean, clean);
      return p5.then(function() {
        return stream2.getBufferedValue();
      });
    }
    module2.exports = getStream2;
    module2.exports.buffer = function(stream2, opts) {
      return getStream2(stream2, objectAssign({}, opts, { encoding: "buffer" }));
    };
    module2.exports.array = function(stream2, opts) {
      return getStream2(stream2, objectAssign({}, opts, { array: true }));
    };
  }
});

// node_modules/decompress-unzip/node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/decompress-unzip/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = function(fn2, P3, opts) {
      return function() {
        var that = this;
        var args2 = new Array(arguments.length);
        for (var i4 = 0; i4 < arguments.length; i4++) {
          args2[i4] = arguments[i4];
        }
        return new P3(function(resolve2, reject2) {
          args2.push(function(err, result) {
            if (err) {
              reject2(err);
            } else if (opts.multiArgs) {
              var results = new Array(arguments.length - 1);
              for (var i5 = 1; i5 < arguments.length; i5++) {
                results[i5 - 1] = arguments[i5];
              }
              resolve2(results);
            } else {
              resolve2(result);
            }
          });
          fn2.apply(that, args2);
        });
      };
    };
    var pify = module2.exports = function(obj, P3, opts) {
      if (typeof P3 !== "function") {
        opts = P3;
        P3 = Promise;
      }
      opts = opts || {};
      opts.exclude = opts.exclude || [/.+Sync$/];
      var filter = function(key) {
        var match2 = function(pattern) {
          return typeof pattern === "string" ? key === pattern : pattern.test(key);
        };
        return opts.include ? opts.include.some(match2) : !opts.exclude.some(match2);
      };
      var ret = typeof obj === "function" ? function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, P3, opts).apply(this, arguments);
      } : {};
      return Object.keys(obj).reduce(function(ret2, key) {
        var x5 = obj[key];
        ret2[key] = typeof x5 === "function" && filter(key) ? processFn(x5, P3, opts) : x5;
        return ret2;
      }, ret);
    };
    pify.all = pify;
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports2, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn2) {
      if (this.pending < this.max) {
        pendGo(this, fn2);
      } else {
        this.waiting.push(fn2);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn2) {
      fn2(pendHold(self2));
    }
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/fd-slicer/index.js"(exports2) {
    var fs2 = require("fs");
    var util = require("util");
    var stream2 = require("stream");
    var Readable = stream2.Readable;
    var Writable = stream2.Writable;
    var PassThrough = stream2.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options3) {
      options3 = options3 || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options3.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length2, position2, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs2.read(self2.fd, buffer, offset, length2, position2, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length2, position2, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs2.write(self2.fd, buffer, offset, length2, position2, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options3) {
      return new ReadStream(this, options3);
    };
    FdSlicer.prototype.createWriteStream = function(options3) {
      return new WriteStream(this, options3);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs2.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options3) {
      options3 = options3 || {};
      Readable.call(this, options3);
      this.context = context;
      this.context.ref();
      this.start = options3.start || 0;
      this.endOffset = options3.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n3) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n3);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs2.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options3) {
      options3 = options3 || {};
      Writable.call(this, options3);
      this.context = context;
      this.context.ref();
      this.start = options3.start || 0;
      this.endOffset = options3.end == null ? Infinity : +options3.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs2.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options3) {
      EventEmitter.call(this);
      options3 = options3 || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options3.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length2, position2, callback) {
      var end = position2 + length2;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length2;
      this.buffer.copy(buffer, offset, position2, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length2, position2, callback) {
      buffer.copy(this.buffer, position2, offset, offset + length2);
      setImmediate(function() {
        callback(null, length2, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options3) {
      options3 = options3 || {};
      var readStream = new PassThrough(options3);
      readStream.destroyed = false;
      readStream.start = options3.start || 0;
      readStream.endOffset = options3.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options3) {
      var bufferSlicer = this;
      options3 = options3 || {};
      var writeStream = new Writable(options3);
      writeStream.start = options3.start || 0;
      writeStream.endOffset = options3.end == null ? this.buffer.length : +options3.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options3) {
      return new BufferSlicer(buffer, options3);
    }
    function createFromFd(fd, options3) {
      return new FdSlicer(fd, options3);
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer4 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer4.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer4.alloc === "function" && typeof Buffer4.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer4.alloc(input) : new Buffer4(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer4.from(input) : new Buffer4(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer4.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n3 = 0; n3 < buf.length; n3++) {
        crc = CRC_TABLE[(crc ^ buf[n3]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports2) {
    var fs2 = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.validateFileName = validateFileName;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path8, options3, callback) {
      if (typeof options3 === "function") {
        callback = options3;
        options3 = null;
      }
      if (options3 == null)
        options3 = {};
      if (options3.autoClose == null)
        options3.autoClose = true;
      if (options3.lazyEntries == null)
        options3.lazyEntries = false;
      if (options3.decodeStrings == null)
        options3.decodeStrings = true;
      if (options3.validateEntrySizes == null)
        options3.validateEntrySizes = true;
      if (options3.strictFileNames == null)
        options3.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs2.open(path8, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options3, function(err2, zipfile) {
          if (err2)
            fs2.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options3, callback) {
      if (typeof options3 === "function") {
        callback = options3;
        options3 = null;
      }
      if (options3 == null)
        options3 = {};
      if (options3.autoClose == null)
        options3.autoClose = false;
      if (options3.lazyEntries == null)
        options3.lazyEntries = false;
      if (options3.decodeStrings == null)
        options3.decodeStrings = true;
      if (options3.validateEntrySizes == null)
        options3.validateEntrySizes = true;
      if (options3.strictFileNames == null)
        options3.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs2.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options3, callback);
      });
    }
    function fromBuffer(buffer, options3, callback) {
      if (typeof options3 === "function") {
        callback = options3;
        options3 = null;
      }
      if (options3 == null)
        options3 = {};
      options3.autoClose = false;
      if (options3.lazyEntries == null)
        options3.lazyEntries = false;
      if (options3.decodeStrings == null)
        options3.decodeStrings = true;
      if (options3.validateEntrySizes == null)
        options3.validateEntrySizes = true;
      if (options3.strictFileNames == null)
        options3.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options3, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options3, callback) {
      if (typeof options3 === "function") {
        callback = options3;
        options3 = null;
      }
      if (options3 == null)
        options3 = {};
      if (options3.autoClose == null)
        options3.autoClose = true;
      if (options3.lazyEntries == null)
        options3.lazyEntries = false;
      if (options3.decodeStrings == null)
        options3.decodeStrings = true;
      var decodeStrings = !!options3.decodeStrings;
      if (options3.validateEntrySizes == null)
        options3.validateEntrySizes = true;
      if (options3.strictFileNames == null)
        options3.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i4 = bufferSize - eocdrWithoutCommentSize; i4 >= 0; i4 -= 1) {
          if (buffer.readUInt32LE(i4) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i4);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment2 = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment2, options3.autoClose, options3.lazyEntries, decodeStrings, options3.validateEntrySizes, options3.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i4 - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE2(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE2(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE2(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment2, options3.autoClose, options3.lazyEntries, decodeStrings, options3.validateEntrySizes, options3.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment2, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment2;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i4 = 0;
          while (i4 < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i4 + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i4 + 2);
            var dataStart = i4 + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i4 = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i4 = 0; i4 < entry.extraFields.length; i4++) {
              var extraField = entry.extraFields[i4];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index2 = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index2 + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE2(zip64EiefBuffer, index2);
              index2 += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index2 + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE2(zip64EiefBuffer, index2);
              index2 += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index2 + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE2(zip64EiefBuffer, index2);
              index2 += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i4 = 0; i4 < entry.extraFields.length; i4++) {
              var extraField = entry.extraFields[i4];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options3, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options3;
        options3 = {};
      } else {
        if (options3.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options3.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options3.decrypt);
          if (entry.isCompressed()) {
            if (options3.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options3.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options3.decompress === false || options3.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options3.decompress);
          }
        }
        if (options3.start != null || options3.end != null) {
          if (entry.isCompressed() && options3.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options3.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options3.start != null) {
          relativeStart = options3.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options3.end != null) {
          relativeEnd = options3.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options3.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options3.decompress != null ? options3.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length2, position2, callback) {
      if (length2 === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length2, position2, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length2) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options3) {
      var start = options3.start;
      var end = options3.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream2 = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream2.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream2.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream2.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream2.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length2, position2, callback) {
      var readStream = this.createReadStream({ start: position2, end: position2 + length2 });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i4 = start; i4 < end; i4++) {
          result += cp437[buffer[i4]];
        }
        return result;
      }
    }
    function readUInt64LE2(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// node_modules/decompress-unzip/index.js
var require_decompress_unzip = __commonJS({
  "node_modules/decompress-unzip/index.js"(exports2, module2) {
    "use strict";
    var fileType2 = require_file_type4();
    var getStream2 = require_get_stream3();
    var pify = require_pify();
    var yauzl = require_yauzl();
    var getType = (entry, mode) => {
      const IFMT = 61440;
      const IFDIR = 16384;
      const IFLNK = 40960;
      const madeBy = entry.versionMadeBy >> 8;
      if ((mode & IFMT) === IFLNK) {
        return "symlink";
      }
      if ((mode & IFMT) === IFDIR || madeBy === 0 && entry.externalFileAttributes === 16) {
        return "directory";
      }
      return "file";
    };
    var extractEntry = (entry, zip) => {
      const file = {
        mode: entry.externalFileAttributes >> 16 & 65535,
        mtime: entry.getLastModDate(),
        path: entry.fileName
      };
      file.type = getType(entry, file.mode);
      if (file.mode === 0 && file.type === "directory") {
        file.mode = 493;
      }
      if (file.mode === 0) {
        file.mode = 420;
      }
      return pify(zip.openReadStream.bind(zip))(entry).then(getStream2.buffer).then((buf) => {
        file.data = buf;
        if (file.type === "symlink") {
          file.linkname = buf.toString();
        }
        return file;
      }).catch((err) => {
        zip.close();
        throw err;
      });
    };
    var extractFile = (zip) => new Promise((resolve2, reject2) => {
      const files = [];
      zip.readEntry();
      zip.on("entry", (entry) => {
        extractEntry(entry, zip).catch(reject2).then((file) => {
          files.push(file);
          zip.readEntry();
        });
      });
      zip.on("error", reject2);
      zip.on("end", () => resolve2(files));
    });
    module2.exports = () => (buf) => {
      if (!Buffer.isBuffer(buf)) {
        return Promise.reject(new TypeError(`Expected a Buffer, got ${typeof buf}`));
      }
      if (!fileType2(buf) || fileType2(buf).ext !== "zip") {
        return Promise.resolve([]);
      }
      return pify(yauzl.fromBuffer)(buf, { lazyEntries: true }).then(extractFile);
    };
  }
});

// node_modules/decompress/node_modules/make-dir/node_modules/pify/index.js
var require_pify2 = __commonJS({
  "node_modules/decompress/node_modules/make-dir/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn2, opts) => function() {
      const P3 = opts.promiseModule;
      const args2 = new Array(arguments.length);
      for (let i4 = 0; i4 < arguments.length; i4++) {
        args2[i4] = arguments[i4];
      }
      return new P3((resolve2, reject2) => {
        if (opts.errorFirst) {
          args2.push(function(err, result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i4 = 1; i4 < arguments.length; i4++) {
                results[i4 - 1] = arguments[i4];
              }
              if (err) {
                results.unshift(err);
                reject2(results);
              } else {
                resolve2(results);
              }
            } else if (err) {
              reject2(err);
            } else {
              resolve2(result);
            }
          });
        } else {
          args2.push(function(result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i4 = 0; i4 < arguments.length; i4++) {
                results[i4] = arguments[i4];
              }
              resolve2(results);
            } else {
              resolve2(result);
            }
          });
        }
        fn2.apply(this, args2);
      });
    };
    module2.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter = (key) => {
        const match2 = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return opts.include ? opts.include.some(match2) : !opts.exclude.some(match2);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key in obj) {
        const x5 = obj[key];
        ret[key] = typeof x5 === "function" && filter(key) ? processFn(x5, opts) : x5;
      }
      return ret;
    };
  }
});

// node_modules/decompress/node_modules/make-dir/index.js
var require_make_dir = __commonJS({
  "node_modules/decompress/node_modules/make-dir/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path8 = require("path");
    var pify = require_pify2();
    var defaults = {
      mode: 511 & ~process.umask(),
      fs: fs2
    };
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path8.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const err = new Error(`Path contains invalid characters: ${pth}`);
          err.code = "EINVAL";
          throw err;
        }
      }
    };
    module2.exports = (input, opts) => Promise.resolve().then(() => {
      checkPath(input);
      opts = Object.assign({}, defaults, opts);
      const mkdir = pify(opts.fs.mkdir);
      const stat = pify(opts.fs.stat);
      const make = (pth) => {
        return mkdir(pth, opts.mode).then(() => pth).catch((err) => {
          if (err.code === "ENOENT") {
            if (err.message.includes("null bytes") || path8.dirname(pth) === pth) {
              throw err;
            }
            return make(path8.dirname(pth)).then(() => make(pth));
          }
          return stat(pth).then((stats) => stats.isDirectory() ? pth : Promise.reject()).catch(() => {
            throw err;
          });
        });
      };
      return make(path8.resolve(input));
    });
    module2.exports.sync = (input, opts) => {
      checkPath(input);
      opts = Object.assign({}, defaults, opts);
      const make = (pth) => {
        try {
          opts.fs.mkdirSync(pth, opts.mode);
        } catch (err) {
          if (err.code === "ENOENT") {
            if (err.message.includes("null bytes") || path8.dirname(pth) === pth) {
              throw err;
            }
            make(path8.dirname(pth));
            return make(pth);
          }
          try {
            if (!opts.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_3) {
            throw err;
          }
        }
        return pth;
      };
      return make(path8.resolve(input));
    };
  }
});

// node_modules/decompress/node_modules/pify/index.js
var require_pify3 = __commonJS({
  "node_modules/decompress/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = function(fn2, P3, opts) {
      return function() {
        var that = this;
        var args2 = new Array(arguments.length);
        for (var i4 = 0; i4 < arguments.length; i4++) {
          args2[i4] = arguments[i4];
        }
        return new P3(function(resolve2, reject2) {
          args2.push(function(err, result) {
            if (err) {
              reject2(err);
            } else if (opts.multiArgs) {
              var results = new Array(arguments.length - 1);
              for (var i5 = 1; i5 < arguments.length; i5++) {
                results[i5 - 1] = arguments[i5];
              }
              resolve2(results);
            } else {
              resolve2(result);
            }
          });
          fn2.apply(that, args2);
        });
      };
    };
    var pify = module2.exports = function(obj, P3, opts) {
      if (typeof P3 !== "function") {
        opts = P3;
        P3 = Promise;
      }
      opts = opts || {};
      opts.exclude = opts.exclude || [/.+Sync$/];
      var filter = function(key) {
        var match2 = function(pattern) {
          return typeof pattern === "string" ? key === pattern : pattern.test(key);
        };
        return opts.include ? opts.include.some(match2) : !opts.exclude.some(match2);
      };
      var ret = typeof obj === "function" ? function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, P3, opts).apply(this, arguments);
      } : {};
      return Object.keys(obj).reduce(function(ret2, key) {
        var x5 = obj[key];
        ret2[key] = typeof x5 === "function" && filter(key) ? processFn(x5, P3, opts) : x5;
        return ret2;
      }, ret);
    };
    pify.all = pify;
  }
});

// node_modules/is-natural-number/index.js
var require_is_natural_number = __commonJS({
  "node_modules/is-natural-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isNaturalNumber(val, option) {
      if (option) {
        if (typeof option !== "object") {
          throw new TypeError(
            String(option) + " is not an object. Expected an object that has boolean `includeZero` property."
          );
        }
        if ("includeZero" in option) {
          if (typeof option.includeZero !== "boolean") {
            throw new TypeError(
              String(option.includeZero) + " is neither true nor false. `includeZero` option must be a Boolean value."
            );
          }
          if (option.includeZero && val === 0) {
            return true;
          }
        }
      }
      return Number.isSafeInteger(val) && val >= 1;
    };
  }
});

// node_modules/strip-dirs/index.js
var require_strip_dirs = __commonJS({
  "node_modules/strip-dirs/index.js"(exports2, module2) {
    "use strict";
    var path8 = require("path");
    var util = require("util");
    var isNaturalNumber = require_is_natural_number();
    module2.exports = function stripDirs(pathStr, count, option) {
      if (typeof pathStr !== "string") {
        throw new TypeError(
          util.inspect(pathStr) + " is not a string. First argument to strip-dirs must be a path string."
        );
      }
      if (path8.posix.isAbsolute(pathStr) || path8.win32.isAbsolute(pathStr)) {
        throw new Error(`${pathStr} is an absolute path. strip-dirs requires a relative path.`);
      }
      if (!isNaturalNumber(count, { includeZero: true })) {
        throw new Error(
          "The Second argument of strip-dirs must be a natural number or 0, but received " + util.inspect(count) + "."
        );
      }
      if (option) {
        if (typeof option !== "object") {
          throw new TypeError(
            util.inspect(option) + " is not an object. Expected an object with a boolean `disallowOverflow` property."
          );
        }
        if (Array.isArray(option)) {
          throw new TypeError(
            util.inspect(option) + " is an array. Expected an object with a boolean `disallowOverflow` property."
          );
        }
        if ("disallowOverflow" in option && typeof option.disallowOverflow !== "boolean") {
          throw new TypeError(
            util.inspect(option.disallowOverflow) + " is neither true nor false. `disallowOverflow` option must be a Boolean value."
          );
        }
      } else {
        option = { disallowOverflow: false };
      }
      const pathComponents = path8.normalize(pathStr).split(path8.sep);
      if (pathComponents.length > 1 && pathComponents[0] === ".") {
        pathComponents.shift();
      }
      if (count > pathComponents.length - 1) {
        if (option.disallowOverflow) {
          throw new RangeError("Cannot strip more directories than there are.");
        }
        count = pathComponents.length - 1;
      }
      return path8.join.apply(null, pathComponents.slice(count));
    };
  }
});

// node_modules/decompress/index.js
var require_decompress = __commonJS({
  "node_modules/decompress/index.js"(exports2, module2) {
    "use strict";
    var path8 = require("path");
    var fs2 = require_graceful_fs();
    var decompressTar = require_decompress_tar();
    var decompressTarbz2 = require_decompress_tarbz2();
    var decompressTargz = require_decompress_targz();
    var decompressUnzip = require_decompress_unzip();
    var makeDir = require_make_dir();
    var pify = require_pify3();
    var stripDirs = require_strip_dirs();
    var fsP = pify(fs2);
    var runPlugins = (input, opts) => {
      if (opts.plugins.length === 0) {
        return Promise.resolve([]);
      }
      return Promise.all(opts.plugins.map((x5) => x5(input, opts))).then((files) => files.reduce((a3, b4) => a3.concat(b4)));
    };
    var safeMakeDir = (dir, realOutputPath) => {
      return fsP.realpath(dir).catch((_3) => {
        const parent = path8.dirname(dir);
        return safeMakeDir(parent, realOutputPath);
      }).then((realParentPath) => {
        if (realParentPath.indexOf(realOutputPath) !== 0) {
          throw new Error("Refusing to create a directory outside the output path.");
        }
        return makeDir(dir).then(fsP.realpath);
      });
    };
    var preventWritingThroughSymlink = (destination, realOutputPath) => {
      return fsP.readlink(destination).catch((_3) => {
        return null;
      }).then((symlinkPointsTo) => {
        if (symlinkPointsTo) {
          throw new Error("Refusing to write into a symlink");
        }
        return realOutputPath;
      });
    };
    var extractFile = (input, output, opts) => runPlugins(input, opts).then((files) => {
      if (opts.strip > 0) {
        files = files.map((x5) => {
          x5.path = stripDirs(x5.path, opts.strip);
          return x5;
        }).filter((x5) => x5.path !== ".");
      }
      if (typeof opts.filter === "function") {
        files = files.filter(opts.filter);
      }
      if (typeof opts.map === "function") {
        files = files.map(opts.map);
      }
      if (!output) {
        return files;
      }
      return Promise.all(files.map((x5) => {
        const dest = path8.join(output, x5.path);
        const mode = x5.mode & ~process.umask();
        const now = /* @__PURE__ */ new Date();
        if (x5.type === "directory") {
          return makeDir(output).then((outputPath) => fsP.realpath(outputPath)).then((realOutputPath) => safeMakeDir(dest, realOutputPath)).then(() => fsP.utimes(dest, now, x5.mtime)).then(() => x5);
        }
        return makeDir(output).then((outputPath) => fsP.realpath(outputPath)).then((realOutputPath) => {
          return safeMakeDir(path8.dirname(dest), realOutputPath).then(() => realOutputPath);
        }).then((realOutputPath) => {
          if (x5.type === "file") {
            return preventWritingThroughSymlink(dest, realOutputPath);
          }
          return realOutputPath;
        }).then((realOutputPath) => {
          return fsP.realpath(path8.dirname(dest)).then((realDestinationDir) => {
            if (realDestinationDir.indexOf(realOutputPath) !== 0) {
              throw new Error("Refusing to write outside output directory: " + realDestinationDir);
            }
          });
        }).then(() => {
          if (x5.type === "link") {
            return fsP.link(x5.linkname, dest);
          }
          if (x5.type === "symlink" && process.platform === "win32") {
            return fsP.link(x5.linkname, dest);
          }
          if (x5.type === "symlink") {
            return fsP.symlink(x5.linkname, dest);
          }
          return fsP.writeFile(dest, x5.data, { mode });
        }).then(() => x5.type === "file" && fsP.utimes(dest, now, x5.mtime)).then(() => x5);
      }));
    });
    module2.exports = (input, output, opts) => {
      if (typeof input !== "string" && !Buffer.isBuffer(input)) {
        return Promise.reject(new TypeError("Input file required"));
      }
      if (typeof output === "object") {
        opts = output;
        output = null;
      }
      opts = Object.assign({ plugins: [
        decompressTar(),
        decompressTarbz2(),
        decompressTargz(),
        decompressUnzip()
      ] }, opts);
      const read = typeof input === "string" ? fsP.readFile(input) : Promise.resolve(input);
      return read.then((buf) => extractFile(buf, output, opts));
    };
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/trim-repeated/index.js
var require_trim_repeated = __commonJS({
  "node_modules/trim-repeated/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    module2.exports = function(str, target) {
      if (typeof str !== "string" || typeof target !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(new RegExp("(?:" + escapeStringRegexp(target) + "){2,}", "g"), target);
    };
  }
});

// node_modules/filename-reserved-regex/index.js
var require_filename_reserved_regex = __commonJS({
  "node_modules/filename-reserved-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = () => /[<>:"\/\\|?*\x00-\x1F]/g;
    module2.exports.windowsNames = () => /^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i;
  }
});

// node_modules/strip-outer/index.js
var require_strip_outer = __commonJS({
  "node_modules/strip-outer/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    module2.exports = function(str, sub) {
      if (typeof str !== "string" || typeof sub !== "string") {
        throw new TypeError();
      }
      sub = escapeStringRegexp(sub);
      return str.replace(new RegExp("^" + sub + "|" + sub + "$", "g"), "");
    };
  }
});

// node_modules/filenamify/index.js
var require_filenamify = __commonJS({
  "node_modules/filenamify/index.js"(exports2, module2) {
    "use strict";
    var path8 = require("path");
    var trimRepeated = require_trim_repeated();
    var filenameReservedRegex = require_filename_reserved_regex();
    var stripOuter = require_strip_outer();
    var MAX_FILENAME_LENGTH = 100;
    var reControlChars = /[\u0000-\u001f\u0080-\u009f]/g;
    var reRelativePath = /^\.+/;
    var filenamify = (string, options3 = {}) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      const replacement = options3.replacement === void 0 ? "!" : options3.replacement;
      if (filenameReservedRegex().test(replacement) && reControlChars.test(replacement)) {
        throw new Error("Replacement string cannot contain reserved filename characters");
      }
      string = string.replace(filenameReservedRegex(), replacement);
      string = string.replace(reControlChars, replacement);
      string = string.replace(reRelativePath, replacement);
      if (replacement.length > 0) {
        string = trimRepeated(string, replacement);
        string = string.length > 1 ? stripOuter(string, replacement) : string;
      }
      string = filenameReservedRegex.windowsNames().test(string) ? string + replacement : string;
      string = string.slice(0, MAX_FILENAME_LENGTH);
      return string;
    };
    filenamify.path = (filePath, options3) => {
      filePath = path8.resolve(filePath);
      return path8.join(path8.dirname(filePath), filenamify(path8.basename(filePath), options3));
    };
    module2.exports = filenamify;
    module2.exports.default = filenamify;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports2, module2) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs2 = require("fs");
    var noop3 = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn2) {
      return typeof fn2 === "function";
    };
    var isFS = function(stream2) {
      if (!ancient)
        return false;
      if (!fs2)
        return false;
      return (stream2 instanceof (fs2.ReadStream || noop3) || stream2 instanceof (fs2.WriteStream || noop3)) && isFn(stream2.close);
    };
    var isRequest = function(stream2) {
      return stream2.setHeader && isFn(stream2.abort);
    };
    var destroyer = function(stream2, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream2.on("close", function() {
        closed = true;
      });
      eos(stream2, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream2))
          return stream2.close(noop3);
        if (isRequest(stream2))
          return stream2.abort();
        if (isFn(stream2.destroy))
          return stream2.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn2) {
      fn2();
    };
    var pipe = function(from2, to) {
      return from2.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop3) && streams.pop() || noop3;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream2, i4) {
        var reading = i4 < streams.length - 1;
        var writing = i4 > 0;
        return destroyer(stream2, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  }
});

// node_modules/download/node_modules/get-stream/buffer-stream.js
var require_buffer_stream4 = __commonJS({
  "node_modules/download/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    module2.exports = (options3) => {
      options3 = Object.assign({}, options3);
      const { array } = options3;
      let { encoding } = options3;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream2 = new PassThrough({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      stream2.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream2.getBufferedLength = () => len;
      return stream2;
    };
  }
});

// node_modules/download/node_modules/get-stream/index.js
var require_get_stream4 = __commonJS({
  "node_modules/download/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var pump = require_pump();
    var bufferStream = require_buffer_stream4();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    function getStream2(inputStream, options3) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options3 = Object.assign({ maxBuffer: Infinity }, options3);
      const { maxBuffer } = options3;
      let stream2;
      return new Promise((resolve2, reject2) => {
        const rejectPromise = (error) => {
          if (error) {
            error.bufferedData = stream2.getBufferedValue();
          }
          reject2(error);
        };
        stream2 = pump(inputStream, bufferStream(options3), (error) => {
          if (error) {
            rejectPromise(error);
            return;
          }
          resolve2();
        });
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      }).then(() => stream2.getBufferedValue());
    }
    module2.exports = getStream2;
    module2.exports.buffer = (stream2, options3) => getStream2(stream2, Object.assign({}, options3, { encoding: "buffer" }));
    module2.exports.array = (stream2, options3) => getStream2(stream2, Object.assign({}, options3, { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, function(c4) {
        return "%" + c4.charCodeAt(0).toString(16).toUpperCase();
      });
    };
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    var token2 = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token2 + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token2 + ")+", "gi");
    function decodeComponents(components2, split) {
      try {
        return [decodeURIComponent(components2.join(""))];
      } catch (err) {
      }
      if (components2.length === 1) {
        return components2;
      }
      split = split || 1;
      var left = components2.slice(0, split);
      var right = components2.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i4 = 1; i4 < tokens.length; i4++) {
          input = decodeComponents(tokens, i4).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match2 = multiMatcher.exec(input);
      while (match2) {
        try {
          replaceMap[match2[0]] = decodeURIComponent(match2[0]);
        } catch (err) {
          var result = decode(match2[0]);
          if (result !== match2[0]) {
            replaceMap[match2[0]] = result;
          }
        }
        match2 = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i4 = 0; i4 < entries.length; i4++) {
        var key = entries[i4];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module2.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports2) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var objectAssign = require_object_assign();
    var decodeComponent = require_decode_uri_component();
    function encoderForArrayFormat(opts) {
      switch (opts.arrayFormat) {
        case "index":
          return function(key, value, index2) {
            return value === null ? [
              encode(key, opts),
              "[",
              index2,
              "]"
            ].join("") : [
              encode(key, opts),
              "[",
              encode(index2, opts),
              "]=",
              encode(value, opts)
            ].join("");
          };
        case "bracket":
          return function(key, value) {
            return value === null ? encode(key, opts) : [
              encode(key, opts),
              "[]=",
              encode(value, opts)
            ].join("");
          };
        default:
          return function(key, value) {
            return value === null ? encode(key, opts) : [
              encode(key, opts),
              "=",
              encode(value, opts)
            ].join("");
          };
      }
    }
    function parserForArrayFormat(opts) {
      var result;
      switch (opts.arrayFormat) {
        case "index":
          return function(key, value, accumulator) {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return function(key, value, accumulator) {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            } else if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        default:
          return function(key, value, accumulator) {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function encode(value, opts) {
      if (opts.encode) {
        return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      } else if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort(function(a3, b4) {
          return Number(a3) - Number(b4);
        }).map(function(key) {
          return input[key];
        });
      }
      return input;
    }
    function extract(str) {
      var queryStart = str.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return str.slice(queryStart + 1);
    }
    function parse3(str, opts) {
      opts = objectAssign({ arrayFormat: "none" }, opts);
      var formatter = parserForArrayFormat(opts);
      var ret = /* @__PURE__ */ Object.create(null);
      if (typeof str !== "string") {
        return ret;
      }
      str = str.trim().replace(/^[?#&]/, "");
      if (!str) {
        return ret;
      }
      str.split("&").forEach(function(param) {
        var parts = param.replace(/\+/g, " ").split("=");
        var key = parts.shift();
        var val = parts.length > 0 ? parts.join("=") : void 0;
        val = val === void 0 ? null : decodeComponent(val);
        formatter(decodeComponent(key), val, ret);
      });
      return Object.keys(ret).sort().reduce(function(result, key) {
        var val = ret[key];
        if (Boolean(val) && typeof val === "object" && !Array.isArray(val)) {
          result[key] = keysSorter(val);
        } else {
          result[key] = val;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports2.extract = extract;
    exports2.parse = parse3;
    exports2.stringify = function(obj, opts) {
      var defaults = {
        encode: true,
        strict: true,
        arrayFormat: "none"
      };
      opts = objectAssign(defaults, opts);
      if (opts.sort === false) {
        opts.sort = function() {
        };
      }
      var formatter = encoderForArrayFormat(opts);
      return obj ? Object.keys(obj).sort(opts.sort).map(function(key) {
        var val = obj[key];
        if (val === void 0) {
          return "";
        }
        if (val === null) {
          return encode(key, opts);
        }
        if (Array.isArray(val)) {
          var result = [];
          val.slice().forEach(function(val2) {
            if (val2 === void 0) {
              return;
            }
            result.push(formatter(key, val2, result.length));
          });
          return result.join("&");
        }
        return encode(key, opts) + "=" + encode(val, opts);
      }).filter(function(x5) {
        return x5.length > 0;
      }).join("&") : "";
    };
    exports2.parseUrl = function(str, opts) {
      return {
        url: str.split("?")[0] || "",
        query: parse3(extract(str), opts)
      };
    };
  }
});

// node_modules/prepend-http/index.js
var require_prepend_http = __commonJS({
  "node_modules/prepend-http/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (url2, opts) => {
      if (typeof url2 !== "string") {
        throw new TypeError(`Expected \`url\` to be of type \`string\`, got \`${typeof url2}\``);
      }
      url2 = url2.trim();
      opts = Object.assign({ https: false }, opts);
      if (/^\.*\/|^(?!localhost)\w+:/.test(url2)) {
        return url2;
      }
      return url2.replace(/^(?!(?:\w+:)?\/\/)/, opts.https ? "https://" : "http://");
    };
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    var toString2 = Object.prototype.toString;
    module2.exports = function(x5) {
      var prototype;
      return toString2.call(x5) === "[object Object]" && (prototype = Object.getPrototypeOf(x5), prototype === null || prototype === Object.getPrototypeOf({}));
    };
  }
});

// node_modules/normalize-url/node_modules/sort-keys/index.js
var require_sort_keys = __commonJS({
  "node_modules/normalize-url/node_modules/sort-keys/index.js"(exports2, module2) {
    "use strict";
    var isPlainObj = require_is_plain_obj();
    module2.exports = (obj, opts) => {
      if (!isPlainObj(obj)) {
        throw new TypeError("Expected a plain object");
      }
      opts = opts || {};
      if (typeof opts === "function") {
        throw new TypeError("Specify the compare function as an option instead");
      }
      const deep = opts.deep;
      const seenInput = [];
      const seenOutput = [];
      const sortKeys = (x5) => {
        const seenIndex = seenInput.indexOf(x5);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        const ret = {};
        const keys = Object.keys(x5).sort(opts.compare);
        seenInput.push(x5);
        seenOutput.push(ret);
        for (let i4 = 0; i4 < keys.length; i4++) {
          const key = keys[i4];
          const val = x5[key];
          if (deep && Array.isArray(val)) {
            const retArr = [];
            for (let j4 = 0; j4 < val.length; j4++) {
              retArr[j4] = isPlainObj(val[j4]) ? sortKeys(val[j4]) : val[j4];
            }
            ret[key] = retArr;
            continue;
          }
          ret[key] = deep && isPlainObj(val) ? sortKeys(val) : val;
        }
        return ret;
      };
      return sortKeys(obj);
    };
  }
});

// node_modules/normalize-url/index.js
var require_normalize_url = __commonJS({
  "node_modules/normalize-url/index.js"(exports2, module2) {
    "use strict";
    var url2 = require("url");
    var punycode = require("punycode");
    var queryString = require_query_string();
    var prependHttp = require_prepend_http();
    var sortKeys = require_sort_keys();
    var DEFAULT_PORTS = {
      "http:": 80,
      "https:": 443,
      "ftp:": 21
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function testParameter(name, filters) {
      return filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
    }
    module2.exports = (str, opts) => {
      opts = Object.assign({
        normalizeProtocol: true,
        normalizeHttps: false,
        stripFragment: true,
        stripWWW: true,
        removeQueryParameters: [/^utm_\w+/i],
        removeTrailingSlash: true,
        removeDirectoryIndex: false,
        sortQueryParameters: true
      }, opts);
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      const hasRelativeProtocol = str.startsWith("//");
      str = prependHttp(str.trim()).replace(/^\/\//, "http://");
      const urlObj = url2.parse(str);
      if (opts.normalizeHttps && urlObj.protocol === "https:") {
        urlObj.protocol = "http:";
      }
      if (!urlObj.hostname && !urlObj.pathname) {
        throw new Error("Invalid URL");
      }
      delete urlObj.host;
      delete urlObj.query;
      if (opts.stripFragment) {
        delete urlObj.hash;
      }
      const port = DEFAULT_PORTS[urlObj.protocol];
      if (Number(urlObj.port) === port) {
        delete urlObj.port;
      }
      if (urlObj.pathname) {
        urlObj.pathname = urlObj.pathname.replace(/\/{2,}/g, "/");
      }
      if (urlObj.pathname) {
        urlObj.pathname = decodeURI(urlObj.pathname);
      }
      if (opts.removeDirectoryIndex === true) {
        opts.removeDirectoryIndex = [/^index\.[a-z]+$/];
      }
      if (Array.isArray(opts.removeDirectoryIndex) && opts.removeDirectoryIndex.length > 0) {
        let pathComponents = urlObj.pathname.split("/");
        const lastComponent = pathComponents[pathComponents.length - 1];
        if (testParameter(lastComponent, opts.removeDirectoryIndex)) {
          pathComponents = pathComponents.slice(0, pathComponents.length - 1);
          urlObj.pathname = pathComponents.slice(1).join("/") + "/";
        }
      }
      if (slashedProtocol[urlObj.protocol]) {
        const domain = urlObj.protocol + "//" + urlObj.hostname;
        const relative = url2.resolve(domain, urlObj.pathname);
        urlObj.pathname = relative.replace(domain, "");
      }
      if (urlObj.hostname) {
        urlObj.hostname = punycode.toUnicode(urlObj.hostname).toLowerCase();
        urlObj.hostname = urlObj.hostname.replace(/\.$/, "");
        if (opts.stripWWW) {
          urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
        }
      }
      if (urlObj.search === "?") {
        delete urlObj.search;
      }
      const queryParameters = queryString.parse(urlObj.search);
      if (Array.isArray(opts.removeQueryParameters)) {
        for (const key in queryParameters) {
          if (testParameter(key, opts.removeQueryParameters)) {
            delete queryParameters[key];
          }
        }
      }
      if (opts.sortQueryParameters) {
        urlObj.search = queryString.stringify(sortKeys(queryParameters));
      }
      if (urlObj.search !== null) {
        urlObj.search = decodeURIComponent(urlObj.search);
      }
      str = url2.format(urlObj);
      if (opts.removeTrailingSlash || urlObj.pathname === "/") {
        str = str.replace(/\/$/, "");
      }
      if (hasRelativeProtocol && !opts.normalizeProtocol) {
        str = str.replace(/^http:\/\//, "//");
      }
      return str;
    };
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream5 = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    module2.exports = (opts) => {
      opts = Object.assign({}, opts);
      const array = opts.array;
      let encoding = opts.encoding;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream2 = new PassThrough({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      stream2.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream2.getBufferedLength = () => len;
      return stream2;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream5 = __commonJS({
  "node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var bufferStream = require_buffer_stream5();
    function getStream2(inputStream, opts) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      opts = Object.assign({ maxBuffer: Infinity }, opts);
      const maxBuffer = opts.maxBuffer;
      let stream2;
      let clean;
      const p5 = new Promise((resolve2, reject2) => {
        const error = (err) => {
          if (err) {
            err.bufferedData = stream2.getBufferedValue();
          }
          reject2(err);
        };
        stream2 = bufferStream(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream2);
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            reject2(new Error("maxBuffer exceeded"));
          }
        });
        stream2.once("error", error);
        stream2.on("end", resolve2);
        clean = () => {
          if (inputStream.unpipe) {
            inputStream.unpipe(stream2);
          }
        };
      });
      p5.then(clean, clean);
      return p5.then(() => stream2.getBufferedValue());
    }
    module2.exports = getStream2;
    module2.exports.buffer = (stream2, opts) => getStream2(stream2, Object.assign({}, opts, { encoding: "buffer" }));
    module2.exports.array = (stream2, opts) => getStream2(stream2, Object.assign({}, opts, { array: true }));
  }
});

// node_modules/http-cache-semantics/node4/index.js
var require_node4 = __commonJS({
  "node_modules/http-cache-semantics/node4/index.js"(exports2, module2) {
    "use strict";
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var statusCodeCacheableByDefault = [200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501];
    var understoodStatuses = [200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501];
    var hopByHopHeaders = { "connection": true, "keep-alive": true, "proxy-authenticate": true, "proxy-authorization": true, "te": true, "trailer": true, "transfer-encoding": true, "upgrade": true };
    var excludedFromRevalidationUpdate = {
      // Since the old body is reused, it doesn't make sense to change properties of the body
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function parseCacheControl(header) {
      var cc = {};
      if (!header)
        return cc;
      var parts = header.trim().split(/\s*,\s*/);
      for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
        var _ref3;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref3 = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref3 = _i.value;
        }
        var part = _ref3;
        var _part$split = part.split(/\s*=\s*/, 2), k4 = _part$split[0], v4 = _part$split[1];
        cc[k4] = v4 === void 0 ? true : v4.replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      var parts = [];
      for (var k4 in cc) {
        var v4 = cc[k4];
        parts.push(v4 === true ? k4 : k4 + "=" + v4);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module2.exports = function() {
      function CachePolicy(req, res) {
        var _ref23 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, shared = _ref23.shared, cacheHeuristic = _ref23.cacheHeuristic, immutableMinTimeToLive = _ref23.immutableMinTimeToLive, ignoreCargoCult = _ref23.ignoreCargoCult, _fromObject = _ref23._fromObject;
        _classCallCheck2(this, CachePolicy);
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic = void 0 !== cacheHeuristic ? cacheHeuristic : 0.1;
        this._immutableMinTtl = void 0 !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, { "cache-control": formatCacheControl(this._rescc) });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (!res.headers["cache-control"] && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      CachePolicy.prototype.now = function now() {
        return Date.now();
      };
      CachePolicy.prototype.storable = function storable() {
        return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
        // The request method is understood by the cache and defined as being cacheable, and
        ("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
        understoodStatuses.indexOf(this._status) !== -1 && // the "no-store" cache directive does not appear in request or response header fields, and
        !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
        (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
        // contains an Expires header field, or
        (this._resHeaders.expires || // contains a max-age response directive, or
        // contains a s-maxage response directive and the cache is shared, or
        // contains a public response directive.
        this._rescc.public || this._rescc["max-age"] || this._rescc["s-maxage"] || // has a status code that is defined as cacheable by default
        statusCodeCacheableByDefault.indexOf(this._status) !== -1));
      };
      CachePolicy.prototype._hasExplicitExpiration = function _hasExplicitExpiration() {
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
      };
      CachePolicy.prototype._assertRequestHasHeaders = function _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      };
      CachePolicy.prototype.satisfiesWithoutRevalidation = function satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        var requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return false;
        }
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
          return false;
        }
        if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
          return false;
        }
        if (this.stale()) {
          var allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (true === requestCC["max-stale"] || requestCC["max-stale"] > this.age() - this.maxAge());
          if (!allowsStale) {
            return false;
          }
        }
        return this._requestMatches(req, false);
      };
      CachePolicy.prototype._requestMatches = function _requestMatches(req, allowHeadMethod) {
        return (!this._url || this._url === req.url) && this._host === req.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
        (!req.method || this._method === req.method || allowHeadMethod && "HEAD" === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and
        this._varyMatches(req);
      };
      CachePolicy.prototype._allowsStoringAuthenticated = function _allowsStoringAuthenticated() {
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
      };
      CachePolicy.prototype._varyMatches = function _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        var fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
          var _ref3;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref3 = _i2.value;
          }
          var name = _ref3;
          if (req.headers[name] !== this._reqHeaders[name])
            return false;
        }
        return true;
      };
      CachePolicy.prototype._copyWithoutHopByHopHeaders = function _copyWithoutHopByHopHeaders(inHeaders) {
        var headers = {};
        for (var name in inHeaders) {
          if (hopByHopHeaders[name])
            continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          var tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (var _iterator3 = tokens, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ; ) {
            var _ref4;
            if (_isArray3) {
              if (_i3 >= _iterator3.length)
                break;
              _ref4 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done)
                break;
              _ref4 = _i3.value;
            }
            var _name = _ref4;
            delete headers[_name];
          }
        }
        if (headers.warning) {
          var warnings = headers.warning.split(/,/).filter(function(warning) {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      };
      CachePolicy.prototype.responseHeaders = function responseHeaders() {
        var headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        var age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        return headers;
      };
      CachePolicy.prototype.date = function date() {
        var dateValue = Date.parse(this._resHeaders.date);
        var maxClockDrift = 8 * 3600 * 1e3;
        if (Number.isNaN(dateValue) || dateValue < this._responseTime - maxClockDrift || dateValue > this._responseTime + maxClockDrift) {
          return this._responseTime;
        }
        return dateValue;
      };
      CachePolicy.prototype.age = function age() {
        var age2 = Math.max(0, (this._responseTime - this.date()) / 1e3);
        if (this._resHeaders.age) {
          var ageValue = this._ageValue();
          if (ageValue > age2)
            age2 = ageValue;
        }
        var residentTime = (this.now() - this._responseTime) / 1e3;
        return age2 + residentTime;
      };
      CachePolicy.prototype._ageValue = function _ageValue() {
        var ageValue = parseInt(this._resHeaders.age);
        return isFinite(ageValue) ? ageValue : 0;
      };
      CachePolicy.prototype.maxAge = function maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return parseInt(this._rescc["s-maxage"], 10);
          }
        }
        if (this._rescc["max-age"]) {
          return parseInt(this._rescc["max-age"], 10);
        }
        var defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        var dateValue = this.date();
        if (this._resHeaders.expires) {
          var expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < dateValue) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - dateValue) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          var lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && dateValue > lastModified) {
            return Math.max(defaultMinTtl, (dateValue - lastModified) / 1e3 * this._cacheHeuristic);
          }
        }
        return defaultMinTtl;
      };
      CachePolicy.prototype.timeToLive = function timeToLive() {
        return Math.max(0, this.maxAge() - this.age()) * 1e3;
      };
      CachePolicy.prototype.stale = function stale() {
        return this.maxAge() <= this.age();
      };
      CachePolicy.fromObject = function fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      };
      CachePolicy.prototype._fromObject = function _fromObject(obj) {
        if (this._responseTime)
          throw Error("Reinitialized");
        if (!obj || obj.v !== 1)
          throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      };
      CachePolicy.prototype.toObject = function toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      };
      CachePolicy.prototype.revalidationHeaders = function revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        var headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        var forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            var etags = headers["if-none-match"].split(/,/).filter(function(etag) {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      };
      CachePolicy.prototype.revalidatedPolicy = function revalidatedPolicy(request3, response) {
        this._assertRequestHasHeaders(request3);
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        var matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        if (!matches) {
          return {
            policy: new this.constructor(request3, response),
            modified: true
          };
        }
        var headers = {};
        for (var k4 in this._resHeaders) {
          headers[k4] = k4 in response.headers && !excludedFromRevalidationUpdate[k4] ? response.headers[k4] : this._resHeaders[k4];
        }
        var newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request3, newResponse),
          modified: false
        };
      };
      return CachePolicy;
    }();
  }
});

// node_modules/lowercase-keys/index.js
var require_lowercase_keys = __commonJS({
  "node_modules/lowercase-keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      var ret = {};
      var keys = Object.keys(Object(obj));
      for (var i4 = 0; i4 < keys.length; i4++) {
        ret[keys[i4].toLowerCase()] = obj[keys[i4]];
      }
      return ret;
    };
  }
});

// node_modules/responselike/src/index.js
var require_src = __commonJS({
  "node_modules/responselike/src/index.js"(exports2, module2) {
    "use strict";
    var Readable = require("stream").Readable;
    var lowercaseKeys = require_lowercase_keys();
    var Response = class extends Readable {
      constructor(statusCode, headers, body, url2) {
        if (typeof statusCode !== "number") {
          throw new TypeError("Argument `statusCode` should be a number");
        }
        if (typeof headers !== "object") {
          throw new TypeError("Argument `headers` should be an object");
        }
        if (!(body instanceof Buffer)) {
          throw new TypeError("Argument `body` should be a buffer");
        }
        if (typeof url2 !== "string") {
          throw new TypeError("Argument `url` should be a string");
        }
        super();
        this.statusCode = statusCode;
        this.headers = lowercaseKeys(headers);
        this.body = body;
        this.url = url2;
      }
      _read() {
        this.push(this.body);
        this.push(null);
      }
    };
    module2.exports = Response;
  }
});

// node_modules/cacheable-request/node_modules/lowercase-keys/index.js
var require_lowercase_keys2 = __commonJS({
  "node_modules/cacheable-request/node_modules/lowercase-keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      var ret = {};
      var keys = Object.keys(Object(obj));
      for (var i4 = 0; i4 < keys.length; i4++) {
        ret[keys[i4].toLowerCase()] = obj[keys[i4]];
      }
      return ret;
    };
  }
});

// node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProps = [
      "destroy",
      "setTimeout",
      "socket",
      "headers",
      "trailers",
      "rawHeaders",
      "statusCode",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "rawTrailers",
      "statusMessage"
    ];
    module2.exports = (fromStream, toStream) => {
      const fromProps = new Set(Object.keys(fromStream).concat(knownProps));
      for (const prop of fromProps) {
        if (prop in toStream) {
          continue;
        }
        toStream[prop] = typeof fromStream[prop] === "function" ? fromStream[prop].bind(fromStream) : fromStream[prop];
      }
    };
  }
});

// node_modules/clone-response/src/index.js
var require_src2 = __commonJS({
  "node_modules/clone-response/src/index.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    var mimicResponse = require_mimic_response();
    var cloneResponse = (response) => {
      if (!(response && response.pipe)) {
        throw new TypeError("Parameter `response` must be a response stream.");
      }
      const clone = new PassThrough();
      mimicResponse(response, clone);
      return response.pipe(clone);
    };
    module2.exports = cloneResponse;
  }
});

// node_modules/json-buffer/index.js
var require_json_buffer = __commonJS({
  "node_modules/json-buffer/index.js"(exports2) {
    exports2.stringify = function stringify2(o4) {
      if ("undefined" == typeof o4)
        return o4;
      if (o4 && Buffer.isBuffer(o4))
        return JSON.stringify(":base64:" + o4.toString("base64"));
      if (o4 && o4.toJSON)
        o4 = o4.toJSON();
      if (o4 && "object" === typeof o4) {
        var s5 = "";
        var array = Array.isArray(o4);
        s5 = array ? "[" : "{";
        var first = true;
        for (var k4 in o4) {
          var ignore = "function" == typeof o4[k4] || !array && "undefined" === typeof o4[k4];
          if (Object.hasOwnProperty.call(o4, k4) && !ignore) {
            if (!first)
              s5 += ",";
            first = false;
            if (array) {
              if (o4[k4] == void 0)
                s5 += "null";
              else
                s5 += stringify2(o4[k4]);
            } else if (o4[k4] !== void 0) {
              s5 += stringify2(k4) + ":" + stringify2(o4[k4]);
            }
          }
        }
        s5 += array ? "]" : "}";
        return s5;
      } else if ("string" === typeof o4) {
        return JSON.stringify(/^:/.test(o4) ? ":" + o4 : o4);
      } else if ("undefined" === typeof o4) {
        return "null";
      } else
        return JSON.stringify(o4);
    };
    exports2.parse = function(s5) {
      return JSON.parse(s5, function(key, value) {
        if ("string" === typeof value) {
          if (/^:base64:/.test(value))
            return new Buffer(value.substring(8), "base64");
          else
            return /^:/.test(value) ? value.substring(1) : value;
        }
        return value;
      });
    };
  }
});

// node_modules/keyv/src/index.js
var require_src3 = __commonJS({
  "node_modules/keyv/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var JSONB = require_json_buffer();
    var loadStore = (opts) => {
      const adapters = {
        redis: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql"
      };
      if (opts.adapter || opts.uri) {
        const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0];
        return new (require(adapters[adapter]))(opts);
      }
      return /* @__PURE__ */ new Map();
    };
    var Keyv = class extends EventEmitter {
      constructor(uri, opts) {
        super();
        this.opts = Object.assign(
          { namespace: "keyv" },
          typeof uri === "string" ? { uri } : uri,
          opts
        );
        if (!this.opts.store) {
          const adapterOpts = Object.assign({}, this.opts);
          this.opts.store = loadStore(adapterOpts);
        }
        if (typeof this.opts.store.on === "function") {
          this.opts.store.on("error", (err) => this.emit("error", err));
        }
        this.opts.store.namespace = this.opts.namespace;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      get(key) {
        key = this._getKeyPrefix(key);
        const store = this.opts.store;
        return Promise.resolve().then(() => store.get(key)).then((data) => {
          data = typeof data === "string" ? JSONB.parse(data) : data;
          if (data === void 0) {
            return void 0;
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            this.delete(key);
            return void 0;
          }
          return data.value;
        });
      }
      set(key, value, ttl) {
        key = this._getKeyPrefix(key);
        if (typeof ttl === "undefined") {
          ttl = this.opts.ttl;
        }
        if (ttl === 0) {
          ttl = void 0;
        }
        const store = this.opts.store;
        return Promise.resolve().then(() => {
          const expires = typeof ttl === "number" ? Date.now() + ttl : null;
          value = { value, expires };
          return store.set(key, JSONB.stringify(value), ttl);
        }).then(() => true);
      }
      delete(key) {
        key = this._getKeyPrefix(key);
        const store = this.opts.store;
        return Promise.resolve().then(() => store.delete(key));
      }
      clear() {
        const store = this.opts.store;
        return Promise.resolve().then(() => store.clear());
      }
    };
    module2.exports = Keyv;
  }
});

// node_modules/cacheable-request/src/index.js
var require_src4 = __commonJS({
  "node_modules/cacheable-request/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var urlLib = require("url");
    var normalizeUrl = require_normalize_url();
    var getStream2 = require_get_stream5();
    var CachePolicy = require_node4();
    var Response = require_src();
    var lowercaseKeys = require_lowercase_keys2();
    var cloneResponse = require_src2();
    var Keyv = require_src3();
    var CacheableRequest = class _CacheableRequest {
      constructor(request3, cacheAdapter) {
        if (typeof request3 !== "function") {
          throw new TypeError("Parameter `request` must be a function");
        }
        this.cache = new Keyv({
          uri: typeof cacheAdapter === "string" && cacheAdapter,
          store: typeof cacheAdapter !== "string" && cacheAdapter,
          namespace: "cacheable-request"
        });
        return this.createCacheableRequest(request3);
      }
      createCacheableRequest(request3) {
        return (opts, cb) => {
          if (typeof opts === "string") {
            opts = urlLib.parse(opts);
          }
          opts = Object.assign({
            headers: {},
            method: "GET",
            cache: true,
            strictTtl: false,
            automaticFailover: false
          }, opts);
          opts.headers = lowercaseKeys(opts.headers);
          const ee = new EventEmitter();
          const url2 = normalizeUrl(urlLib.format(opts));
          const key = `${opts.method}:${url2}`;
          let revalidate = false;
          let madeRequest = false;
          const makeRequest = (opts2) => {
            madeRequest = true;
            const handler = (response) => {
              if (revalidate) {
                const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts2, response);
                if (!revalidatedPolicy.modified) {
                  const headers = revalidatedPolicy.policy.responseHeaders();
                  response = new Response(response.statusCode, headers, revalidate.body, revalidate.url);
                  response.cachePolicy = revalidatedPolicy.policy;
                  response.fromCache = true;
                }
              }
              if (!response.fromCache) {
                response.cachePolicy = new CachePolicy(opts2, response);
                response.fromCache = false;
              }
              let clonedResponse;
              if (opts2.cache && response.cachePolicy.storable()) {
                clonedResponse = cloneResponse(response);
                getStream2.buffer(response).then((body) => {
                  const value = {
                    cachePolicy: response.cachePolicy.toObject(),
                    url: response.url,
                    statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                    body
                  };
                  const ttl = opts2.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                  return this.cache.set(key, value, ttl);
                }).catch((err) => ee.emit("error", new _CacheableRequest.CacheError(err)));
              } else if (opts2.cache && revalidate) {
                this.cache.delete(key).catch((err) => ee.emit("error", new _CacheableRequest.CacheError(err)));
              }
              ee.emit("response", clonedResponse || response);
              if (typeof cb === "function") {
                cb(clonedResponse || response);
              }
            };
            try {
              const req = request3(opts2, handler);
              ee.emit("request", req);
            } catch (err) {
              ee.emit("error", new _CacheableRequest.RequestError(err));
            }
          };
          const get2 = (opts2) => Promise.resolve().then(() => opts2.cache ? this.cache.get(key) : void 0).then((cacheEntry) => {
            if (typeof cacheEntry === "undefined") {
              return makeRequest(opts2);
            }
            const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
            if (policy.satisfiesWithoutRevalidation(opts2)) {
              const headers = policy.responseHeaders();
              const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
              response.cachePolicy = policy;
              response.fromCache = true;
              ee.emit("response", response);
              if (typeof cb === "function") {
                cb(response);
              }
            } else {
              revalidate = cacheEntry;
              opts2.headers = policy.revalidationHeaders(opts2);
              makeRequest(opts2);
            }
          });
          this.cache.on("error", (err) => ee.emit("error", new _CacheableRequest.CacheError(err)));
          get2(opts).catch((err) => {
            if (opts.automaticFailover && !madeRequest) {
              makeRequest(opts);
            }
            ee.emit("error", new _CacheableRequest.CacheError(err));
          });
          return ee;
        };
      }
    };
    CacheableRequest.RequestError = class extends Error {
      constructor(err) {
        super(err.message);
        this.name = "RequestError";
        Object.assign(this, err);
      }
    };
    CacheableRequest.CacheError = class extends Error {
      constructor(err) {
        super(err.message);
        this.name = "CacheError";
        Object.assign(this, err);
      }
    };
    module2.exports = CacheableRequest;
  }
});

// node_modules/duplexer3/index.js
var require_duplexer3 = __commonJS({
  "node_modules/duplexer3/index.js"(exports2, module2) {
    "use strict";
    var stream2 = require("stream");
    function DuplexWrapper(options3, writable, readable) {
      if (typeof readable === "undefined") {
        readable = writable;
        writable = options3;
        options3 = null;
      }
      stream2.Duplex.call(this, options3);
      if (typeof readable.read !== "function") {
        readable = new stream2.Readable(options3).wrap(readable);
      }
      this._writable = writable;
      this._readable = readable;
      this._waiting = false;
      var self2 = this;
      writable.once("finish", function() {
        self2.end();
      });
      this.once("finish", function() {
        writable.end();
      });
      readable.on("readable", function() {
        if (self2._waiting) {
          self2._waiting = false;
          self2._read();
        }
      });
      readable.once("end", function() {
        self2.push(null);
      });
      if (!options3 || typeof options3.bubbleErrors === "undefined" || options3.bubbleErrors) {
        writable.on("error", function(err) {
          self2.emit("error", err);
        });
        readable.on("error", function(err) {
          self2.emit("error", err);
        });
      }
    }
    DuplexWrapper.prototype = Object.create(stream2.Duplex.prototype, { constructor: { value: DuplexWrapper } });
    DuplexWrapper.prototype._write = function _write(input, encoding, done) {
      this._writable.write(input, encoding, done);
    };
    DuplexWrapper.prototype._read = function _read() {
      var buf;
      var reads = 0;
      while ((buf = this._readable.read()) !== null) {
        this.push(buf);
        reads++;
      }
      if (reads === 0) {
        this._waiting = true;
      }
    };
    module2.exports = function duplex2(options3, writable, readable) {
      return new DuplexWrapper(options3, writable, readable);
    };
    module2.exports.DuplexWrapper = DuplexWrapper;
  }
});

// node_modules/from2/index.js
var require_from2 = __commonJS({
  "node_modules/from2/index.js"(exports2, module2) {
    var Readable = require_readable_browser().Readable;
    var inherits = require_inherits_browser();
    module2.exports = from2;
    from2.ctor = ctor;
    from2.obj = obj;
    var Proto = ctor();
    function toFunction(list) {
      list = list.slice();
      return function(_3, cb) {
        var err = null;
        var item = list.length ? list.shift() : null;
        if (item instanceof Error) {
          err = item;
          item = null;
        }
        cb(err, item);
      };
    }
    function from2(opts, read) {
      if (typeof opts !== "object" || Array.isArray(opts)) {
        read = opts;
        opts = {};
      }
      var rs = new Proto(opts);
      rs._from = Array.isArray(read) ? toFunction(read) : read || noop3;
      return rs;
    }
    function ctor(opts, read) {
      if (typeof opts === "function") {
        read = opts;
        opts = {};
      }
      opts = defaults(opts);
      inherits(Class, Readable);
      function Class(override) {
        if (!(this instanceof Class))
          return new Class(override);
        this._reading = false;
        this._callback = check;
        this.destroyed = false;
        Readable.call(this, override || opts);
        var self2 = this;
        var hwm = this._readableState.highWaterMark;
        function check(err, data) {
          if (self2.destroyed)
            return;
          if (err)
            return self2.destroy(err);
          if (data === null)
            return self2.push(null);
          self2._reading = false;
          if (self2.push(data))
            self2._read(hwm);
        }
      }
      Class.prototype._from = read || noop3;
      Class.prototype._read = function(size) {
        if (this._reading || this.destroyed)
          return;
        this._reading = true;
        this._from(size, this._callback);
      };
      Class.prototype.destroy = function(err) {
        if (this.destroyed)
          return;
        this.destroyed = true;
        var self2 = this;
        process.nextTick(function() {
          if (err)
            self2.emit("error", err);
          self2.emit("close");
        });
      };
      return Class;
    }
    function obj(opts, read) {
      if (typeof opts === "function" || Array.isArray(opts)) {
        read = opts;
        opts = {};
      }
      opts = defaults(opts);
      opts.objectMode = true;
      opts.highWaterMark = 16;
      return from2(opts, read);
    }
    function noop3() {
    }
    function defaults(opts) {
      opts = opts || {};
      return opts;
    }
  }
});

// node_modules/p-is-promise/index.js
var require_p_is_promise = __commonJS({
  "node_modules/p-is-promise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (x5) => x5 instanceof Promise || x5 !== null && typeof x5 === "object" && typeof x5.then === "function" && typeof x5.catch === "function";
  }
});

// node_modules/into-stream/index.js
var require_into_stream = __commonJS({
  "node_modules/into-stream/index.js"(exports2, module2) {
    "use strict";
    var from2 = require_from2();
    var pIsPromise = require_p_is_promise();
    module2.exports = (x5) => {
      if (Array.isArray(x5)) {
        x5 = x5.slice();
      }
      let promise;
      let iterator;
      prepare(x5);
      function prepare(value) {
        x5 = value;
        promise = pIsPromise(x5) ? x5 : null;
        const shouldIterate = !promise && x5[Symbol.iterator] && typeof x5 !== "string" && !Buffer.isBuffer(x5);
        iterator = shouldIterate ? x5[Symbol.iterator]() : null;
      }
      return from2(function reader(size, cb) {
        if (promise) {
          promise.then(prepare).then(() => reader.call(this, size, cb), cb);
          return;
        }
        if (iterator) {
          const obj = iterator.next();
          setImmediate(cb, null, obj.done ? null : obj.value);
          return;
        }
        if (x5.length === 0) {
          setImmediate(cb, null, null);
          return;
        }
        const chunk = x5.slice(0, size);
        x5 = x5.slice(size);
        setImmediate(cb, null, chunk);
      });
    };
    module2.exports.obj = (x5) => {
      if (Array.isArray(x5)) {
        x5 = x5.slice();
      }
      let promise;
      let iterator;
      prepare(x5);
      function prepare(value) {
        x5 = value;
        promise = pIsPromise(x5) ? x5 : null;
        iterator = !promise && x5[Symbol.iterator] ? x5[Symbol.iterator]() : null;
      }
      return from2.obj(function reader(size, cb) {
        if (promise) {
          promise.then(prepare).then(() => reader.call(this, size, cb), cb);
          return;
        }
        if (iterator) {
          const obj = iterator.next();
          setImmediate(cb, null, obj.done ? null : obj.value);
          return;
        }
        this.push(x5);
        setImmediate(cb, null, null);
      });
    };
  }
});

// node_modules/@sindresorhus/is/dist/index.js
var require_dist = __commonJS({
  "node_modules/@sindresorhus/is/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util = require("util");
    var toString2 = Object.prototype.toString;
    var isOfType = (type) => (value) => typeof value === type;
    var getObjectType = (value) => {
      const objectName = toString2.call(value).slice(8, -1);
      if (objectName) {
        return objectName;
      }
      return null;
    };
    var isObjectOfType = (typeName) => (value) => {
      return getObjectType(value) === typeName;
    };
    function is(value) {
      if (value === null) {
        return "null";
      }
      if (value === true || value === false) {
        return "boolean";
      }
      const type = typeof value;
      if (type === "undefined") {
        return "undefined";
      }
      if (type === "string") {
        return "string";
      }
      if (type === "number") {
        return "number";
      }
      if (type === "symbol") {
        return "symbol";
      }
      if (is.function_(value)) {
        return "Function";
      }
      if (Array.isArray(value)) {
        return "Array";
      }
      if (Buffer.isBuffer(value)) {
        return "Buffer";
      }
      const tagType = getObjectType(value);
      if (tagType) {
        return tagType;
      }
      if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError("Please don't use object wrappers for primitive types");
      }
      return "Object";
    }
    (function(is2) {
      const isObject2 = (value) => typeof value === "object";
      is2.undefined = isOfType("undefined");
      is2.string = isOfType("string");
      is2.number = isOfType("number");
      is2.function_ = isOfType("function");
      is2.null_ = (value) => value === null;
      is2.class_ = (value) => is2.function_(value) && value.toString().startsWith("class ");
      is2.boolean = (value) => value === true || value === false;
      is2.symbol = isOfType("symbol");
      is2.array = Array.isArray;
      is2.buffer = Buffer.isBuffer;
      is2.nullOrUndefined = (value) => is2.null_(value) || is2.undefined(value);
      is2.object = (value) => !is2.nullOrUndefined(value) && (is2.function_(value) || isObject2(value));
      is2.iterable = (value) => !is2.nullOrUndefined(value) && is2.function_(value[Symbol.iterator]);
      is2.generator = (value) => is2.iterable(value) && is2.function_(value.next) && is2.function_(value.throw);
      is2.nativePromise = isObjectOfType(
        "Promise"
        /* Promise */
      );
      const hasPromiseAPI = (value) => !is2.null_(value) && isObject2(value) && is2.function_(value.then) && is2.function_(value.catch);
      is2.promise = (value) => is2.nativePromise(value) || hasPromiseAPI(value);
      const isFunctionOfType = (type) => (value) => is2.function_(value) && is2.function_(value.constructor) && value.constructor.name === type;
      is2.generatorFunction = isFunctionOfType("GeneratorFunction");
      is2.asyncFunction = isFunctionOfType("AsyncFunction");
      is2.boundFunction = (value) => is2.function_(value) && !value.hasOwnProperty("prototype");
      is2.regExp = isObjectOfType(
        "RegExp"
        /* RegExp */
      );
      is2.date = isObjectOfType(
        "Date"
        /* Date */
      );
      is2.error = isObjectOfType(
        "Error"
        /* Error */
      );
      is2.map = isObjectOfType(
        "Map"
        /* Map */
      );
      is2.set = isObjectOfType(
        "Set"
        /* Set */
      );
      is2.weakMap = isObjectOfType(
        "WeakMap"
        /* WeakMap */
      );
      is2.weakSet = isObjectOfType(
        "WeakSet"
        /* WeakSet */
      );
      is2.int8Array = isObjectOfType(
        "Int8Array"
        /* Int8Array */
      );
      is2.uint8Array = isObjectOfType(
        "Uint8Array"
        /* Uint8Array */
      );
      is2.uint8ClampedArray = isObjectOfType(
        "Uint8ClampedArray"
        /* Uint8ClampedArray */
      );
      is2.int16Array = isObjectOfType(
        "Int16Array"
        /* Int16Array */
      );
      is2.uint16Array = isObjectOfType(
        "Uint16Array"
        /* Uint16Array */
      );
      is2.int32Array = isObjectOfType(
        "Int32Array"
        /* Int32Array */
      );
      is2.uint32Array = isObjectOfType(
        "Uint32Array"
        /* Uint32Array */
      );
      is2.float32Array = isObjectOfType(
        "Float32Array"
        /* Float32Array */
      );
      is2.float64Array = isObjectOfType(
        "Float64Array"
        /* Float64Array */
      );
      is2.arrayBuffer = isObjectOfType(
        "ArrayBuffer"
        /* ArrayBuffer */
      );
      is2.sharedArrayBuffer = isObjectOfType(
        "SharedArrayBuffer"
        /* SharedArrayBuffer */
      );
      is2.dataView = isObjectOfType(
        "DataView"
        /* DataView */
      );
      is2.directInstanceOf = (instance, klass) => is2.object(instance) && is2.object(klass) && Object.getPrototypeOf(instance) === klass.prototype;
      is2.truthy = (value) => Boolean(value);
      is2.falsy = (value) => !value;
      is2.nan = (value) => Number.isNaN(value);
      const primitiveTypes = /* @__PURE__ */ new Set([
        "undefined",
        "string",
        "number",
        "boolean",
        "symbol"
      ]);
      is2.primitive = (value) => is2.null_(value) || primitiveTypes.has(typeof value);
      is2.integer = (value) => Number.isInteger(value);
      is2.safeInteger = (value) => Number.isSafeInteger(value);
      is2.plainObject = (value) => {
        let prototype;
        return getObjectType(value) === "Object" && (prototype = Object.getPrototypeOf(value), prototype === null || // tslint:disable-line:ban-comma-operator
        prototype === Object.getPrototypeOf({}));
      };
      const typedArrayTypes = /* @__PURE__ */ new Set([
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array"
        /* Float64Array */
      ]);
      is2.typedArray = (value) => {
        const objectType = getObjectType(value);
        if (objectType === null) {
          return false;
        }
        return typedArrayTypes.has(objectType);
      };
      const isValidLength = (value) => is2.safeInteger(value) && value > -1;
      is2.arrayLike = (value) => !is2.nullOrUndefined(value) && !is2.function_(value) && isValidLength(value.length);
      is2.inRange = (value, range) => {
        if (is2.number(range)) {
          return value >= Math.min(0, range) && value <= Math.max(range, 0);
        }
        if (is2.array(range) && range.length === 2) {
          return value >= Math.min.apply(null, range) && value <= Math.max.apply(null, range);
        }
        throw new TypeError(`Invalid range: ${util.inspect(range)}`);
      };
      const NODE_TYPE_ELEMENT = 1;
      const DOM_PROPERTIES_TO_CHECK = [
        "innerHTML",
        "ownerDocument",
        "style",
        "attributes",
        "nodeValue"
      ];
      is2.domElement = (value) => is2.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is2.string(value.nodeName) && !is2.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
      is2.nodeStream = (value) => !is2.nullOrUndefined(value) && isObject2(value) && is2.function_(value.pipe);
      is2.infinite = (value) => value === Infinity || value === -Infinity;
      const isAbsoluteMod2 = (value) => (rem) => is2.integer(rem) && Math.abs(rem % 2) === value;
      is2.even = isAbsoluteMod2(0);
      is2.odd = isAbsoluteMod2(1);
      const isWhiteSpaceString = (value) => is2.string(value) && /\S/.test(value) === false;
      const isEmptyStringOrArray = (value) => (is2.string(value) || is2.array(value)) && value.length === 0;
      const isEmptyObject = (value) => !is2.map(value) && !is2.set(value) && is2.object(value) && Object.keys(value).length === 0;
      const isEmptyMapOrSet = (value) => (is2.map(value) || is2.set(value)) && value.size === 0;
      is2.empty = (value) => is2.falsy(value) || isEmptyStringOrArray(value) || isEmptyObject(value) || isEmptyMapOrSet(value);
      is2.emptyOrWhitespace = (value) => is2.empty(value) || isWhiteSpaceString(value);
      const predicateOnArray = (method, predicate, args2) => {
        const values = Array.prototype.slice.call(args2, 1);
        if (is2.function_(predicate) === false) {
          throw new TypeError(`Invalid predicate: ${util.inspect(predicate)}`);
        }
        if (values.length === 0) {
          throw new TypeError("Invalid number of values");
        }
        return method.call(values, predicate);
      };
      function any(predicate) {
        return predicateOnArray(Array.prototype.some, predicate, arguments);
      }
      is2.any = any;
      function all(predicate) {
        return predicateOnArray(Array.prototype.every, predicate, arguments);
      }
      is2.all = all;
    })(is || (is = {}));
    Object.defineProperties(is, {
      class: {
        value: is.class_
      },
      function: {
        value: is.function_
      },
      null: {
        value: is.null_
      }
    });
    exports2.default = is;
    module2.exports = is;
    module2.exports.default = is;
  }
});

// node_modules/timed-out/index.js
var require_timed_out = __commonJS({
  "node_modules/timed-out/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(req, time) {
      if (req.timeoutTimer) {
        return req;
      }
      var delays = isNaN(time) ? time : { socket: time, connect: time };
      var host = req._headers ? " to " + req._headers.host : "";
      if (delays.connect !== void 0) {
        req.timeoutTimer = setTimeout(function timeoutHandler() {
          req.abort();
          var e3 = new Error("Connection timed out on request" + host);
          e3.code = "ETIMEDOUT";
          req.emit("error", e3);
        }, delays.connect);
      }
      req.on("socket", function assign2(socket) {
        if (!(socket.connecting || socket._connecting)) {
          connect();
          return;
        }
        socket.once("connect", connect);
      });
      function clear() {
        if (req.timeoutTimer) {
          clearTimeout(req.timeoutTimer);
          req.timeoutTimer = null;
        }
      }
      function connect() {
        clear();
        if (delays.socket !== void 0) {
          req.setTimeout(delays.socket, function socketTimeoutHandler() {
            req.abort();
            var e3 = new Error("Socket timed out on request" + host);
            e3.code = "ESOCKETTIMEDOUT";
            req.emit("error", e3);
          });
        }
      }
      return req.on("error", clear);
    };
  }
});

// node_modules/url-parse-lax/index.js
var require_url_parse_lax = __commonJS({
  "node_modules/url-parse-lax/index.js"(exports2, module2) {
    "use strict";
    var url2 = require("url");
    var prependHttp = require_prepend_http();
    module2.exports = (input, options3) => {
      if (typeof input !== "string") {
        throw new TypeError(`Expected \`url\` to be of type \`string\`, got \`${typeof input}\` instead.`);
      }
      const finalUrl = prependHttp(input, Object.assign({ https: true }, options3));
      return url2.parse(finalUrl);
    };
  }
});

// node_modules/url-to-options/index.js
var require_url_to_options = __commonJS({
  "node_modules/url-to-options/index.js"(exports2, module2) {
    "use strict";
    function urlToOptions(url2) {
      var options3 = {
        protocol: url2.protocol,
        hostname: url2.hostname,
        hash: url2.hash,
        search: url2.search,
        pathname: url2.pathname,
        path: `${url2.pathname}${url2.search}`,
        href: url2.href
      };
      if (url2.port !== "") {
        options3.port = Number(url2.port);
      }
      if (url2.username || url2.password) {
        options3.auth = `${url2.username}:${url2.password}`;
      }
      return options3;
    }
    module2.exports = urlToOptions;
  }
});

// (disabled):node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "(disabled):node_modules/decompress-response/index.js"() {
  }
});

// node_modules/is-retry-allowed/index.js
var require_is_retry_allowed = __commonJS({
  "node_modules/is-retry-allowed/index.js"(exports2, module2) {
    "use strict";
    var WHITELIST = [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "EPIPE",
      "EHOSTUNREACH",
      "EAI_AGAIN"
    ];
    var BLACKLIST = [
      "ENOTFOUND",
      "ENETUNREACH",
      // SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950
      "UNABLE_TO_GET_ISSUER_CERT",
      "UNABLE_TO_GET_CRL",
      "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
      "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
      "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
      "CERT_SIGNATURE_FAILURE",
      "CRL_SIGNATURE_FAILURE",
      "CERT_NOT_YET_VALID",
      "CERT_HAS_EXPIRED",
      "CRL_NOT_YET_VALID",
      "CRL_HAS_EXPIRED",
      "ERROR_IN_CERT_NOT_BEFORE_FIELD",
      "ERROR_IN_CERT_NOT_AFTER_FIELD",
      "ERROR_IN_CRL_LAST_UPDATE_FIELD",
      "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
      "OUT_OF_MEM",
      "DEPTH_ZERO_SELF_SIGNED_CERT",
      "SELF_SIGNED_CERT_IN_CHAIN",
      "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
      "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
      "CERT_CHAIN_TOO_LONG",
      "CERT_REVOKED",
      "INVALID_CA",
      "PATH_LENGTH_EXCEEDED",
      "INVALID_PURPOSE",
      "CERT_UNTRUSTED",
      "CERT_REJECTED"
    ];
    module2.exports = function(err) {
      if (!err || !err.code) {
        return true;
      }
      if (WHITELIST.indexOf(err.code) !== -1) {
        return true;
      }
      if (BLACKLIST.indexOf(err.code) !== -1) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/has-symbol-support-x/index.js
var require_has_symbol_support_x = __commonJS({
  "node_modules/has-symbol-support-x/index.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Symbol === "function" && typeof Symbol("") === "symbol";
  }
});

// node_modules/has-to-string-tag-x/index.js
var require_has_to_string_tag_x = __commonJS({
  "node_modules/has-to-string-tag-x/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_has_symbol_support_x() && typeof Symbol.toStringTag === "symbol";
  }
});

// node_modules/is-object/index.js
var require_is_object = __commonJS({
  "node_modules/is-object/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isObject2(x5) {
      return typeof x5 === "object" && x5 !== null;
    };
  }
});

// node_modules/isurl/index.js
var require_isurl = __commonJS({
  "node_modules/isurl/index.js"(exports2, module2) {
    "use strict";
    var hasToStringTag = require_has_to_string_tag_x();
    var isObject2 = require_is_object();
    var toString2 = Object.prototype.toString;
    var urlClass = "[object URL]";
    var hash2 = "hash";
    var host = "host";
    var hostname = "hostname";
    var href = "href";
    var password = "password";
    var pathname = "pathname";
    var port = "port";
    var protocol = "protocol";
    var search2 = "search";
    var username = "username";
    var isURL = (url2, supportIncomplete) => {
      if (!isObject2(url2))
        return false;
      if (!hasToStringTag && toString2.call(url2) === urlClass)
        return true;
      if (!(href in url2))
        return false;
      if (!(protocol in url2))
        return false;
      if (!(username in url2))
        return false;
      if (!(password in url2))
        return false;
      if (!(hostname in url2))
        return false;
      if (!(port in url2))
        return false;
      if (!(host in url2))
        return false;
      if (!(pathname in url2))
        return false;
      if (!(search2 in url2))
        return false;
      if (!(hash2 in url2))
        return false;
      if (supportIncomplete !== true) {
        if (!isObject2(url2.searchParams))
          return false;
      }
      return true;
    };
    isURL.lenient = (url2) => {
      return isURL(url2, true);
    };
    module2.exports = isURL;
  }
});

// node_modules/p-cancelable/index.js
var require_p_cancelable = __commonJS({
  "node_modules/p-cancelable/index.js"(exports2, module2) {
    "use strict";
    var CancelError = class extends Error {
      constructor() {
        super("Promise was canceled");
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    var PCancelable = class _PCancelable {
      static fn(userFn) {
        return function() {
          const args2 = [].slice.apply(arguments);
          return new _PCancelable((resolve2, reject2, onCancel) => {
            args2.push(onCancel);
            userFn.apply(null, args2).then(resolve2, reject2);
          });
        };
      }
      constructor(executor) {
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._promise = new Promise((resolve2, reject2) => {
          this._reject = reject2;
          return executor(
            (value) => {
              this._isPending = false;
              resolve2(value);
            },
            (error) => {
              this._isPending = false;
              reject2(error);
            },
            (handler) => {
              this._cancelHandlers.push(handler);
            }
          );
        });
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this._promise.catch(onRejected);
      }
      finally(onFinally) {
        return this._promise.finally(onFinally);
      }
      cancel() {
        if (!this._isPending || this._isCanceled) {
          return;
        }
        if (this._cancelHandlers.length > 0) {
          try {
            for (const handler of this._cancelHandlers) {
              handler();
            }
          } catch (err) {
            this._reject(err);
          }
        }
        this._isCanceled = true;
        this._reject(new CancelError());
      }
      get isCanceled() {
        return this._isCanceled;
      }
    };
    Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
    module2.exports = PCancelable;
    module2.exports.CancelError = CancelError;
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve2) => {
          resolve2(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve2) => {
          resolve2(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-timeout/index.js"(exports2, module2) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    module2.exports = (promise, ms, fallback) => new Promise((resolve2, reject2) => {
      if (typeof ms !== "number" || ms < 0) {
        throw new TypeError("Expected `ms` to be a positive number");
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve2(fallback());
          } catch (err2) {
            reject2(err2);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${ms} milliseconds`;
        const err = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject2(err);
      }, ms);
      pFinally(
        promise.then(resolve2, reject2),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module2.exports.TimeoutError = TimeoutError;
  }
});

// node_modules/pify/index.js
var require_pify4 = __commonJS({
  "node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn2, opts) => function() {
      const P3 = opts.promiseModule;
      const args2 = new Array(arguments.length);
      for (let i4 = 0; i4 < arguments.length; i4++) {
        args2[i4] = arguments[i4];
      }
      return new P3((resolve2, reject2) => {
        if (opts.errorFirst) {
          args2.push(function(err, result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i4 = 1; i4 < arguments.length; i4++) {
                results[i4 - 1] = arguments[i4];
              }
              if (err) {
                results.unshift(err);
                reject2(results);
              } else {
                resolve2(results);
              }
            } else if (err) {
              reject2(err);
            } else {
              resolve2(result);
            }
          });
        } else {
          args2.push(function(result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i4 = 0; i4 < arguments.length; i4++) {
                results[i4] = arguments[i4];
              }
              resolve2(results);
            } else {
              resolve2(result);
            }
          });
        }
        fn2.apply(this, args2);
      });
    };
    module2.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter = (key) => {
        const match2 = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return opts.include ? opts.include.some(match2) : !opts.exclude.some(match2);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key in obj) {
        const x5 = obj[key];
        ret[key] = typeof x5 === "function" && filter(key) ? processFn(x5, opts) : x5;
      }
      return ret;
    };
  }
});

// node_modules/got/package.json
var require_package2 = __commonJS({
  "node_modules/got/package.json"(exports2, module2) {
    module2.exports = {
      name: "got",
      version: "8.3.2",
      description: "Simplified HTTP requests",
      license: "MIT",
      repository: "sindresorhus/got",
      maintainers: [
        {
          name: "Sindre Sorhus",
          email: "sindresorhus@gmail.com",
          url: "sindresorhus.com"
        },
        {
          name: "Vsevolod Strukchinsky",
          email: "floatdrop@gmail.com",
          url: "github.com/floatdrop"
        },
        {
          name: "Alexander Tesfamichael",
          email: "alex.tesfamichael@gmail.com",
          url: "alextes.me"
        }
      ],
      engines: {
        node: ">=4"
      },
      scripts: {
        test: "xo && nyc ava",
        coveralls: "nyc report --reporter=text-lcov | coveralls"
      },
      files: [
        "index.js",
        "errors.js"
      ],
      keywords: [
        "http",
        "https",
        "get",
        "got",
        "url",
        "uri",
        "request",
        "util",
        "utility",
        "simple",
        "curl",
        "wget",
        "fetch",
        "net",
        "network",
        "electron"
      ],
      dependencies: {
        "@sindresorhus/is": "^0.7.0",
        "cacheable-request": "^2.1.1",
        "decompress-response": "^3.3.0",
        duplexer3: "^0.1.4",
        "get-stream": "^3.0.0",
        "into-stream": "^3.1.0",
        "is-retry-allowed": "^1.1.0",
        isurl: "^1.0.0-alpha5",
        "lowercase-keys": "^1.0.0",
        "mimic-response": "^1.0.0",
        "p-cancelable": "^0.4.0",
        "p-timeout": "^2.0.1",
        pify: "^3.0.0",
        "safe-buffer": "^5.1.1",
        "timed-out": "^4.0.1",
        "url-parse-lax": "^3.0.0",
        "url-to-options": "^1.0.1"
      },
      devDependencies: {
        ava: "^0.25.0",
        coveralls: "^3.0.0",
        "form-data": "^2.1.1",
        "get-port": "^3.0.0",
        nyc: "^11.0.2",
        "p-event": "^1.3.0",
        pem: "^1.4.4",
        proxyquire: "^1.8.0",
        sinon: "^4.0.0",
        "slow-stream": "0.0.4",
        tempfile: "^2.0.0",
        tempy: "^0.2.1",
        "universal-url": "1.0.0-alpha",
        xo: "^0.20.0"
      },
      ava: {
        concurrency: 4
      },
      browser: {
        "decompress-response": false,
        electron: false
      }
    };
  }
});

// node_modules/got/errors.js
var require_errors = __commonJS({
  "node_modules/got/errors.js"(exports2, module2) {
    "use strict";
    var urlLib = require("url");
    var http = require("http");
    var PCancelable = require_p_cancelable();
    var is = require_dist();
    var GotError = class extends Error {
      constructor(message, error, opts) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = "GotError";
        if (!is.undefined(error.code)) {
          this.code = error.code;
        }
        Object.assign(this, {
          host: opts.host,
          hostname: opts.hostname,
          method: opts.method,
          path: opts.path,
          protocol: opts.protocol,
          url: opts.href
        });
      }
    };
    module2.exports.GotError = GotError;
    module2.exports.CacheError = class extends GotError {
      constructor(error, opts) {
        super(error.message, error, opts);
        this.name = "CacheError";
      }
    };
    module2.exports.RequestError = class extends GotError {
      constructor(error, opts) {
        super(error.message, error, opts);
        this.name = "RequestError";
      }
    };
    module2.exports.ReadError = class extends GotError {
      constructor(error, opts) {
        super(error.message, error, opts);
        this.name = "ReadError";
      }
    };
    module2.exports.ParseError = class extends GotError {
      constructor(error, statusCode, opts, data) {
        super(`${error.message} in "${urlLib.format(opts)}": 
${data.slice(0, 77)}...`, error, opts);
        this.name = "ParseError";
        this.statusCode = statusCode;
        this.statusMessage = http.STATUS_CODES[this.statusCode];
      }
    };
    module2.exports.HTTPError = class extends GotError {
      constructor(statusCode, statusMessage, headers, opts) {
        if (statusMessage) {
          statusMessage = statusMessage.replace(/\r?\n/g, " ").trim();
        } else {
          statusMessage = http.STATUS_CODES[statusCode];
        }
        super(`Response code ${statusCode} (${statusMessage})`, {}, opts);
        this.name = "HTTPError";
        this.statusCode = statusCode;
        this.statusMessage = statusMessage;
        this.headers = headers;
      }
    };
    module2.exports.MaxRedirectsError = class extends GotError {
      constructor(statusCode, redirectUrls, opts) {
        super("Redirected 10 times. Aborting.", {}, opts);
        this.name = "MaxRedirectsError";
        this.statusCode = statusCode;
        this.statusMessage = http.STATUS_CODES[this.statusCode];
        this.redirectUrls = redirectUrls;
      }
    };
    module2.exports.UnsupportedProtocolError = class extends GotError {
      constructor(opts) {
        super(`Unsupported protocol "${opts.protocol}"`, {}, opts);
        this.name = "UnsupportedProtocolError";
      }
    };
    module2.exports.CancelError = PCancelable.CancelError;
  }
});

// node_modules/got/index.js
var require_got = __commonJS({
  "node_modules/got/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var PassThrough = require("stream").PassThrough;
    var Transform = require("stream").Transform;
    var urlLib = require("url");
    var fs2 = require("fs");
    var querystring = require("querystring");
    var CacheableRequest = require_src4();
    var duplexer3 = require_duplexer3();
    var intoStream = require_into_stream();
    var is = require_dist();
    var getStream2 = require_get_stream5();
    var timedOut = require_timed_out();
    var urlParseLax = require_url_parse_lax();
    var urlToOptions = require_url_to_options();
    var lowercaseKeys = require_lowercase_keys();
    var decompressResponse = require_decompress_response();
    var mimicResponse = require_mimic_response();
    var isRetryAllowed = require_is_retry_allowed();
    var isURL = require_isurl();
    var PCancelable = require_p_cancelable();
    var pTimeout = require_p_timeout();
    var pify = require_pify4();
    var Buffer4 = require_safe_buffer().Buffer;
    var pkg2 = require_package2();
    var errors = require_errors();
    var getMethodRedirectCodes = /* @__PURE__ */ new Set([300, 301, 302, 303, 304, 305, 307, 308]);
    var allMethodRedirectCodes = /* @__PURE__ */ new Set([300, 303, 307, 308]);
    var isFormData = (body) => is.nodeStream(body) && is.function(body.getBoundary);
    var getBodySize = (opts) => {
      const body = opts.body;
      if (opts.headers["content-length"]) {
        return Number(opts.headers["content-length"]);
      }
      if (!body && !opts.stream) {
        return 0;
      }
      if (is.string(body)) {
        return Buffer4.byteLength(body);
      }
      if (isFormData(body)) {
        return pify(body.getLength.bind(body))();
      }
      if (body instanceof fs2.ReadStream) {
        return pify(fs2.stat)(body.path).then((stat) => stat.size);
      }
      if (is.nodeStream(body) && is.buffer(body._buffer)) {
        return body._buffer.length;
      }
      return null;
    };
    function requestAsEventEmitter(opts) {
      opts = opts || {};
      const ee = new EventEmitter();
      const requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);
      const redirects = [];
      const agents = is.object(opts.agent) ? opts.agent : null;
      let retryCount = 0;
      let redirectUrl;
      let uploadBodySize;
      let uploaded = 0;
      const get2 = (opts2) => {
        if (opts2.protocol !== "http:" && opts2.protocol !== "https:") {
          ee.emit("error", new got.UnsupportedProtocolError(opts2));
          return;
        }
        let fn2 = opts2.protocol === "https:" ? https : http;
        if (agents) {
          const protocolName = opts2.protocol === "https:" ? "https" : "http";
          opts2.agent = agents[protocolName] || opts2.agent;
        }
        if (opts2.useElectronNet && process.versions.electron) {
          const electron = require("electron");
          fn2 = electron.net || electron.remote.net;
        }
        let progressInterval;
        const cacheableRequest = new CacheableRequest(fn2.request, opts2.cache);
        const cacheReq = cacheableRequest(opts2, (res) => {
          clearInterval(progressInterval);
          ee.emit("uploadProgress", {
            percent: 1,
            transferred: uploaded,
            total: uploadBodySize
          });
          const statusCode = res.statusCode;
          res.url = redirectUrl || requestUrl;
          res.requestUrl = requestUrl;
          const followRedirect = opts2.followRedirect && "location" in res.headers;
          const redirectGet = followRedirect && getMethodRedirectCodes.has(statusCode);
          const redirectAll = followRedirect && allMethodRedirectCodes.has(statusCode);
          if (redirectAll || redirectGet && (opts2.method === "GET" || opts2.method === "HEAD")) {
            res.resume();
            if (statusCode === 303) {
              opts2.method = "GET";
            }
            if (redirects.length >= 10) {
              ee.emit("error", new got.MaxRedirectsError(statusCode, redirects, opts2), null, res);
              return;
            }
            const bufferString = Buffer4.from(res.headers.location, "binary").toString();
            redirectUrl = urlLib.resolve(urlLib.format(opts2), bufferString);
            redirects.push(redirectUrl);
            const redirectOpts = Object.assign({}, opts2, urlLib.parse(redirectUrl));
            ee.emit("redirect", res, redirectOpts);
            get2(redirectOpts);
            return;
          }
          setImmediate(() => {
            try {
              getResponse(res, opts2, ee, redirects);
            } catch (e3) {
              ee.emit("error", e3);
            }
          });
        });
        cacheReq.on("error", (err) => {
          if (err instanceof CacheableRequest.RequestError) {
            ee.emit("error", new got.RequestError(err, opts2));
          } else {
            ee.emit("error", new got.CacheError(err, opts2));
          }
        });
        cacheReq.once("request", (req) => {
          let aborted = false;
          req.once("abort", (_3) => {
            aborted = true;
          });
          req.once("error", (err) => {
            clearInterval(progressInterval);
            if (aborted) {
              return;
            }
            const backoff = opts2.retries(++retryCount, err);
            if (backoff) {
              setTimeout(get2, backoff, opts2);
              return;
            }
            ee.emit("error", new got.RequestError(err, opts2));
          });
          ee.once("request", (req2) => {
            ee.emit("uploadProgress", {
              percent: 0,
              transferred: 0,
              total: uploadBodySize
            });
            const socket = req2.connection;
            if (socket) {
              const isConnecting = socket.connecting === void 0 ? socket._connecting : socket.connecting;
              const onSocketConnect = () => {
                const uploadEventFrequency = 150;
                progressInterval = setInterval(() => {
                  if (socket.destroyed) {
                    clearInterval(progressInterval);
                    return;
                  }
                  const lastUploaded = uploaded;
                  const headersSize = req2._header ? Buffer4.byteLength(req2._header) : 0;
                  uploaded = socket.bytesWritten - headersSize;
                  if (uploadBodySize && uploaded > uploadBodySize) {
                    uploaded = uploadBodySize;
                  }
                  if (uploaded === lastUploaded || uploaded === uploadBodySize) {
                    return;
                  }
                  ee.emit("uploadProgress", {
                    percent: uploadBodySize ? uploaded / uploadBodySize : 0,
                    transferred: uploaded,
                    total: uploadBodySize
                  });
                }, uploadEventFrequency);
              };
              if (isConnecting) {
                socket.once("connect", onSocketConnect);
              } else {
                onSocketConnect();
              }
            }
          });
          if (opts2.gotTimeout) {
            clearInterval(progressInterval);
            timedOut(req, opts2.gotTimeout);
          }
          setImmediate(() => {
            ee.emit("request", req);
          });
        });
      };
      setImmediate(() => {
        Promise.resolve(getBodySize(opts)).then((size) => {
          uploadBodySize = size;
          if (is.undefined(opts.headers["content-length"]) && is.undefined(opts.headers["transfer-encoding"]) && isFormData(opts.body)) {
            opts.headers["content-length"] = size;
          }
          get2(opts);
        }).catch((err) => {
          ee.emit("error", err);
        });
      });
      return ee;
    }
    function getResponse(res, opts, ee, redirects) {
      const downloadBodySize = Number(res.headers["content-length"]) || null;
      let downloaded = 0;
      const progressStream = new Transform({
        transform(chunk, encoding, callback) {
          downloaded += chunk.length;
          const percent = downloadBodySize ? downloaded / downloadBodySize : 0;
          if (percent < 1) {
            ee.emit("downloadProgress", {
              percent,
              transferred: downloaded,
              total: downloadBodySize
            });
          }
          callback(null, chunk);
        },
        flush(callback) {
          ee.emit("downloadProgress", {
            percent: 1,
            transferred: downloaded,
            total: downloadBodySize
          });
          callback();
        }
      });
      mimicResponse(res, progressStream);
      progressStream.redirectUrls = redirects;
      const response = opts.decompress === true && is.function(decompressResponse) && opts.method !== "HEAD" ? decompressResponse(progressStream) : progressStream;
      if (!opts.decompress && ["gzip", "deflate"].indexOf(res.headers["content-encoding"]) !== -1) {
        opts.encoding = null;
      }
      ee.emit("response", response);
      ee.emit("downloadProgress", {
        percent: 0,
        transferred: 0,
        total: downloadBodySize
      });
      res.pipe(progressStream);
    }
    function asPromise(opts) {
      const timeoutFn = (requestPromise) => opts.gotTimeout && opts.gotTimeout.request ? pTimeout(requestPromise, opts.gotTimeout.request, new got.RequestError({ message: "Request timed out", code: "ETIMEDOUT" }, opts)) : requestPromise;
      const proxy = new EventEmitter();
      const cancelable = new PCancelable((resolve2, reject2, onCancel) => {
        const ee = requestAsEventEmitter(opts);
        let cancelOnRequest = false;
        onCancel(() => {
          cancelOnRequest = true;
        });
        ee.on("request", (req) => {
          if (cancelOnRequest) {
            req.abort();
          }
          onCancel(() => {
            req.abort();
          });
          if (is.nodeStream(opts.body)) {
            opts.body.pipe(req);
            opts.body = void 0;
            return;
          }
          req.end(opts.body);
        });
        ee.on("response", (res) => {
          const stream2 = is.null(opts.encoding) ? getStream2.buffer(res) : getStream2(res, opts);
          stream2.catch((err) => reject2(new got.ReadError(err, opts))).then((data) => {
            const statusCode = res.statusCode;
            const limitStatusCode = opts.followRedirect ? 299 : 399;
            res.body = data;
            if (opts.json && res.body) {
              try {
                res.body = JSON.parse(res.body);
              } catch (err) {
                if (statusCode >= 200 && statusCode < 300) {
                  throw new got.ParseError(err, statusCode, opts, data);
                }
              }
            }
            if (opts.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {
              throw new got.HTTPError(statusCode, res.statusMessage, res.headers, opts);
            }
            resolve2(res);
          }).catch((err) => {
            Object.defineProperty(err, "response", { value: res });
            reject2(err);
          });
        });
        ee.once("error", reject2);
        ee.on("redirect", proxy.emit.bind(proxy, "redirect"));
        ee.on("uploadProgress", proxy.emit.bind(proxy, "uploadProgress"));
        ee.on("downloadProgress", proxy.emit.bind(proxy, "downloadProgress"));
      });
      Object.defineProperty(cancelable, "canceled", {
        get() {
          return cancelable.isCanceled;
        }
      });
      const promise = timeoutFn(cancelable);
      promise.cancel = cancelable.cancel.bind(cancelable);
      promise.on = (name, fn2) => {
        proxy.on(name, fn2);
        return promise;
      };
      return promise;
    }
    function asStream(opts) {
      opts.stream = true;
      const input = new PassThrough();
      const output = new PassThrough();
      const proxy = duplexer3(input, output);
      let timeout;
      if (opts.gotTimeout && opts.gotTimeout.request) {
        timeout = setTimeout(() => {
          proxy.emit("error", new got.RequestError({ message: "Request timed out", code: "ETIMEDOUT" }, opts));
        }, opts.gotTimeout.request);
      }
      if (opts.json) {
        throw new Error("Got can not be used as a stream when the `json` option is used");
      }
      if (opts.body) {
        proxy.write = () => {
          throw new Error("Got's stream is not writable when the `body` option is used");
        };
      }
      const ee = requestAsEventEmitter(opts);
      ee.on("request", (req) => {
        proxy.emit("request", req);
        if (is.nodeStream(opts.body)) {
          opts.body.pipe(req);
          return;
        }
        if (opts.body) {
          req.end(opts.body);
          return;
        }
        if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
          input.pipe(req);
          return;
        }
        req.end();
      });
      ee.on("response", (res) => {
        clearTimeout(timeout);
        const statusCode = res.statusCode;
        res.on("error", (err) => {
          proxy.emit("error", new got.ReadError(err, opts));
        });
        res.pipe(output);
        if (opts.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {
          proxy.emit("error", new got.HTTPError(statusCode, res.statusMessage, res.headers, opts), null, res);
          return;
        }
        proxy.emit("response", res);
      });
      ee.on("error", proxy.emit.bind(proxy, "error"));
      ee.on("redirect", proxy.emit.bind(proxy, "redirect"));
      ee.on("uploadProgress", proxy.emit.bind(proxy, "uploadProgress"));
      ee.on("downloadProgress", proxy.emit.bind(proxy, "downloadProgress"));
      return proxy;
    }
    function normalizeArguments(url2, opts) {
      if (!is.string(url2) && !is.object(url2)) {
        throw new TypeError(`Parameter \`url\` must be a string or object, not ${is(url2)}`);
      } else if (is.string(url2)) {
        url2 = url2.replace(/^unix:/, "http://$&");
        try {
          decodeURI(url2);
        } catch (err) {
          throw new Error("Parameter `url` must contain valid UTF-8 character sequences");
        }
        url2 = urlParseLax(url2);
        if (url2.auth) {
          throw new Error("Basic authentication must be done with the `auth` option");
        }
      } else if (isURL.lenient(url2)) {
        url2 = urlToOptions(url2);
      }
      opts = Object.assign(
        {
          path: "",
          retries: 2,
          cache: false,
          decompress: true,
          useElectronNet: false,
          throwHttpErrors: true
        },
        url2,
        {
          protocol: url2.protocol || "http:"
          // Override both null/undefined with default protocol
        },
        opts
      );
      const headers = lowercaseKeys(opts.headers);
      for (const key of Object.keys(headers)) {
        if (is.nullOrUndefined(headers[key])) {
          delete headers[key];
        }
      }
      opts.headers = Object.assign({
        "user-agent": `${pkg2.name}/${pkg2.version} (https://github.com/sindresorhus/got)`
      }, headers);
      if (opts.decompress && is.undefined(opts.headers["accept-encoding"])) {
        opts.headers["accept-encoding"] = "gzip, deflate";
      }
      const query = opts.query;
      if (query) {
        if (!is.string(query)) {
          opts.query = querystring.stringify(query);
        }
        opts.path = `${opts.path.split("?")[0]}?${opts.query}`;
        delete opts.query;
      }
      if (opts.json && is.undefined(opts.headers.accept)) {
        opts.headers.accept = "application/json";
      }
      const body = opts.body;
      if (is.nullOrUndefined(body)) {
        opts.method = (opts.method || "GET").toUpperCase();
      } else {
        const headers2 = opts.headers;
        if (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(opts.form || opts.json)) {
          throw new TypeError("The `body` option must be a stream.Readable, string, Buffer or plain Object");
        }
        const canBodyBeStringified = is.plainObject(body) || is.array(body);
        if ((opts.form || opts.json) && !canBodyBeStringified) {
          throw new TypeError("The `body` option must be a plain Object or Array when the `form` or `json` option is used");
        }
        if (isFormData(body)) {
          headers2["content-type"] = headers2["content-type"] || `multipart/form-data; boundary=${body.getBoundary()}`;
        } else if (opts.form && canBodyBeStringified) {
          headers2["content-type"] = headers2["content-type"] || "application/x-www-form-urlencoded";
          opts.body = querystring.stringify(body);
        } else if (opts.json && canBodyBeStringified) {
          headers2["content-type"] = headers2["content-type"] || "application/json";
          opts.body = JSON.stringify(body);
        }
        if (is.undefined(headers2["content-length"]) && is.undefined(headers2["transfer-encoding"]) && !is.nodeStream(body)) {
          const length2 = is.string(opts.body) ? Buffer4.byteLength(opts.body) : opts.body.length;
          headers2["content-length"] = length2;
        }
        if (is.buffer(body)) {
          opts.body = intoStream(body);
          opts.body._buffer = body;
        }
        opts.method = (opts.method || "POST").toUpperCase();
      }
      if (opts.hostname === "unix") {
        const matches = /(.+?):(.+)/.exec(opts.path);
        if (matches) {
          opts.socketPath = matches[1];
          opts.path = matches[2];
          opts.host = null;
        }
      }
      if (!is.function(opts.retries)) {
        const retries = opts.retries;
        opts.retries = (iter, err) => {
          if (iter > retries || !isRetryAllowed(err)) {
            return 0;
          }
          const noise = Math.random() * 100;
          return (1 << iter) * 1e3 + noise;
        };
      }
      if (is.undefined(opts.followRedirect)) {
        opts.followRedirect = true;
      }
      if (opts.timeout) {
        if (is.number(opts.timeout)) {
          opts.gotTimeout = { request: opts.timeout };
        } else {
          opts.gotTimeout = opts.timeout;
        }
        delete opts.timeout;
      }
      return opts;
    }
    function got(url2, opts) {
      try {
        const normalizedArgs = normalizeArguments(url2, opts);
        if (normalizedArgs.stream) {
          return asStream(normalizedArgs);
        }
        return asPromise(normalizedArgs);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    got.stream = (url2, opts) => asStream(normalizeArguments(url2, opts));
    var methods = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    for (const method of methods) {
      got[method] = (url2, opts) => got(url2, Object.assign({}, opts, { method }));
      got.stream[method] = (url2, opts) => got.stream(url2, Object.assign({}, opts, { method }));
    }
    Object.assign(got, errors);
    module2.exports = got;
  }
});

// node_modules/make-dir/node_modules/pify/index.js
var require_pify5 = __commonJS({
  "node_modules/make-dir/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn2, options3) => function(...args2) {
      const P3 = options3.promiseModule;
      return new P3((resolve2, reject2) => {
        if (options3.multiArgs) {
          args2.push((...result) => {
            if (options3.errorFirst) {
              if (result[0]) {
                reject2(result);
              } else {
                result.shift();
                resolve2(result);
              }
            } else {
              resolve2(result);
            }
          });
        } else if (options3.errorFirst) {
          args2.push((error, result) => {
            if (error) {
              reject2(error);
            } else {
              resolve2(result);
            }
          });
        } else {
          args2.push(resolve2);
        }
        fn2.apply(this, args2);
      });
    };
    module2.exports = (input, options3) => {
      options3 = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, options3);
      const objType2 = typeof input;
      if (!(input !== null && (objType2 === "object" || objType2 === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objType2}\``);
      }
      const filter = (key) => {
        const match2 = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return options3.include ? options3.include.some(match2) : !options3.exclude.some(match2);
      };
      let ret;
      if (objType2 === "function") {
        ret = function(...args2) {
          return options3.excludeMain ? input(...args2) : processFn(input, options3).apply(this, args2);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(input));
      }
      for (const key in input) {
        const property = input[key];
        ret[key] = typeof property === "function" && filter(key) ? processFn(property, options3) : property;
      }
      return ret;
    };
  }
});

// node_modules/make-dir/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/make-dir/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args2 = Array.prototype.slice.call(arguments, 0);
        args2.unshift("SEMVER");
        console.log.apply(console, args2);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R3 = 0;
    var NUMERICIDENTIFIER = R3++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R3++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R3++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R3++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R3++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R3++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R3++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R3++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R3++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R3++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R3++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R3++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R3++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R3++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R3++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R3++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R3++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R3++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R3++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R3++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R3++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R3++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R3++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R3++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R3++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R3++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R3++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R3++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R3++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R3++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R3++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R3++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R3++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R3++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R3++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i4 = 0; i4 < R3; i4++) {
      debug(i4, src[i4]);
      if (!re[i4]) {
        re[i4] = new RegExp(src[i4]);
      }
    }
    var i4;
    exports2.parse = parse3;
    function parse3(version, options3) {
      if (!options3 || typeof options3 !== "object") {
        options3 = {
          loose: !!options3,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r5 = options3.loose ? re[LOOSE] : re[FULL];
      if (!r5.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options3);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options3) {
      var v4 = parse3(version, options3);
      return v4 ? v4.version : null;
    }
    exports2.clean = clean;
    function clean(version, options3) {
      var s5 = parse3(version.trim().replace(/^[=v]+/, ""), options3);
      return s5 ? s5.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options3) {
      if (!options3 || typeof options3 !== "object") {
        options3 = {
          loose: !!options3,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options3.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options3);
      }
      debug("SemVer", version, options3);
      this.options = options3;
      this.loose = !!options3.loose;
      var m4 = version.trim().match(options3.loose ? re[LOOSE] : re[FULL]);
      if (!m4) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m4[1];
      this.minor = +m4[2];
      this.patch = +m4[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m4[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m4[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m4[5] ? m4[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i5 = 0;
      do {
        var a3 = this.prerelease[i5];
        var b4 = other.prerelease[i5];
        debug("prerelease compare", i5, a3, b4);
        if (a3 === void 0 && b4 === void 0) {
          return 0;
        } else if (b4 === void 0) {
          return 1;
        } else if (a3 === void 0) {
          return -1;
        } else if (a3 === b4) {
          continue;
        } else {
          return compareIdentifiers(a3, b4);
        }
      } while (++i5);
    };
    SemVer.prototype.inc = function(release, identifier2) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier2);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier2);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier2);
          this.inc("pre", identifier2);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier2);
          }
          this.inc("pre", identifier2);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i5 = this.prerelease.length;
            while (--i5 >= 0) {
              if (typeof this.prerelease[i5] === "number") {
                this.prerelease[i5]++;
                i5 = -2;
              }
            }
            if (i5 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier2) {
            if (this.prerelease[0] === identifier2) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier2, 0];
              }
            } else {
              this.prerelease = [identifier2, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier2) {
      if (typeof loose === "string") {
        identifier2 = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier2).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse3(version1);
        var v22 = parse3(version2);
        var prefix2 = "";
        if (v1.prerelease.length || v22.prerelease.length) {
          prefix2 = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v22[key]) {
              return prefix2 + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a3, b4) {
      var anum = numeric.test(a3);
      var bnum = numeric.test(b4);
      if (anum && bnum) {
        a3 = +a3;
        b4 = +b4;
      }
      return a3 === b4 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b4 ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a3, b4) {
      return compareIdentifiers(b4, a3);
    }
    exports2.major = major;
    function major(a3, loose) {
      return new SemVer(a3, loose).major;
    }
    exports2.minor = minor;
    function minor(a3, loose) {
      return new SemVer(a3, loose).minor;
    }
    exports2.patch = patch;
    function patch(a3, loose) {
      return new SemVer(a3, loose).patch;
    }
    exports2.compare = compare;
    function compare(a3, b4, loose) {
      return new SemVer(a3, loose).compare(new SemVer(b4, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a3, b4) {
      return compare(a3, b4, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a3, b4, loose) {
      return compare(b4, a3, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a3, b4) {
        return exports2.compare(a3, b4, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a3, b4) {
        return exports2.rcompare(a3, b4, loose);
      });
    }
    exports2.gt = gt;
    function gt(a3, b4, loose) {
      return compare(a3, b4, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a3, b4, loose) {
      return compare(a3, b4, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a3, b4, loose) {
      return compare(a3, b4, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a3, b4, loose) {
      return compare(a3, b4, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a3, b4, loose) {
      return compare(a3, b4, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a3, b4, loose) {
      return compare(a3, b4, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a3, op, b4, loose) {
      switch (op) {
        case "===":
          if (typeof a3 === "object")
            a3 = a3.version;
          if (typeof b4 === "object")
            b4 = b4.version;
          return a3 === b4;
        case "!==":
          if (typeof a3 === "object")
            a3 = a3.version;
          if (typeof b4 === "object")
            b4 = b4.version;
          return a3 !== b4;
        case "":
        case "=":
        case "==":
          return eq(a3, b4, loose);
        case "!=":
          return neq(a3, b4, loose);
        case ">":
          return gt(a3, b4, loose);
        case ">=":
          return gte(a3, b4, loose);
        case "<":
          return lt(a3, b4, loose);
        case "<=":
          return lte(a3, b4, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options3) {
      if (!options3 || typeof options3 !== "object") {
        options3 = {
          loose: !!options3,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options3.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options3);
      }
      debug("comparator", comp, options3);
      this.options = options3;
      this.loose = !!options3.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r5 = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m4 = comp.match(r5);
      if (!m4) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m4[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m4[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m4[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options3) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options3 || typeof options3 !== "object") {
        options3 = {
          loose: !!options3,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options3);
        return satisfies(this.value, rangeTmp, options3);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options3);
        return satisfies(comp.semver, rangeTmp, options3);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options3) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options3) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options3) {
      if (!options3 || typeof options3 !== "object") {
        options3 = {
          loose: !!options3,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options3.loose && range.includePrerelease === !!options3.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options3);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options3);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options3);
      }
      this.options = options3;
      this.loose = !!options3.loose;
      this.includePrerelease = !!options3.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c4) {
        return c4.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options3) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options3);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options3) {
      return new Range(range, options3).set.map(function(comp) {
        return comp.map(function(c4) {
          return c4.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options3) {
      debug("comp", comp, options3);
      comp = replaceCarets(comp, options3);
      debug("caret", comp);
      comp = replaceTildes(comp, options3);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options3);
      debug("xrange", comp);
      comp = replaceStars(comp, options3);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options3) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options3);
      }).join(" ");
    }
    function replaceTilde(comp, options3) {
      var r5 = options3.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r5, function(_3, M3, m4, p5, pr) {
        debug("tilde", comp, _3, M3, m4, p5, pr);
        var ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m4)) {
          ret = ">=" + M3 + ".0.0 <" + (+M3 + 1) + ".0.0";
        } else if (isX(p5)) {
          ret = ">=" + M3 + "." + m4 + ".0 <" + M3 + "." + (+m4 + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M3 + "." + m4 + "." + p5 + "-" + pr + " <" + M3 + "." + (+m4 + 1) + ".0";
        } else {
          ret = ">=" + M3 + "." + m4 + "." + p5 + " <" + M3 + "." + (+m4 + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options3) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options3);
      }).join(" ");
    }
    function replaceCaret(comp, options3) {
      debug("caret", comp, options3);
      var r5 = options3.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r5, function(_3, M3, m4, p5, pr) {
        debug("caret", comp, _3, M3, m4, p5, pr);
        var ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m4)) {
          ret = ">=" + M3 + ".0.0 <" + (+M3 + 1) + ".0.0";
        } else if (isX(p5)) {
          if (M3 === "0") {
            ret = ">=" + M3 + "." + m4 + ".0 <" + M3 + "." + (+m4 + 1) + ".0";
          } else {
            ret = ">=" + M3 + "." + m4 + ".0 <" + (+M3 + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M3 === "0") {
            if (m4 === "0") {
              ret = ">=" + M3 + "." + m4 + "." + p5 + "-" + pr + " <" + M3 + "." + m4 + "." + (+p5 + 1);
            } else {
              ret = ">=" + M3 + "." + m4 + "." + p5 + "-" + pr + " <" + M3 + "." + (+m4 + 1) + ".0";
            }
          } else {
            ret = ">=" + M3 + "." + m4 + "." + p5 + "-" + pr + " <" + (+M3 + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M3 === "0") {
            if (m4 === "0") {
              ret = ">=" + M3 + "." + m4 + "." + p5 + " <" + M3 + "." + m4 + "." + (+p5 + 1);
            } else {
              ret = ">=" + M3 + "." + m4 + "." + p5 + " <" + M3 + "." + (+m4 + 1) + ".0";
            }
          } else {
            ret = ">=" + M3 + "." + m4 + "." + p5 + " <" + (+M3 + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options3) {
      debug("replaceXRanges", comp, options3);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options3);
      }).join(" ");
    }
    function replaceXRange(comp, options3) {
      comp = comp.trim();
      var r5 = options3.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r5, function(ret, gtlt, M3, m4, p5, pr) {
        debug("xRange", comp, ret, gtlt, M3, m4, p5, pr);
        var xM = isX(M3);
        var xm = xM || isX(m4);
        var xp = xm || isX(p5);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m4 = 0;
          }
          p5 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M3 = +M3 + 1;
              m4 = 0;
              p5 = 0;
            } else {
              m4 = +m4 + 1;
              p5 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M3 = +M3 + 1;
            } else {
              m4 = +m4 + 1;
            }
          }
          ret = gtlt + M3 + "." + m4 + "." + p5;
        } else if (xm) {
          ret = ">=" + M3 + ".0.0 <" + (+M3 + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M3 + "." + m4 + ".0 <" + M3 + "." + (+m4 + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options3) {
      debug("replaceStars", comp, options3);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from2 = "";
      } else if (isX(fm)) {
        from2 = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from2 = ">=" + fM + "." + fm + ".0";
      } else {
        from2 = ">=" + from2;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from2 + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i5 = 0; i5 < this.set.length; i5++) {
        if (testSet(this.set[i5], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options3) {
      for (var i5 = 0; i5 < set.length; i5++) {
        if (!set[i5].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options3.includePrerelease) {
        for (i5 = 0; i5 < set.length; i5++) {
          debug(set[i5].semver);
          if (set[i5].semver === ANY) {
            continue;
          }
          if (set[i5].semver.prerelease.length > 0) {
            var allowed = set[i5].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options3) {
      try {
        range = new Range(range, options3);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options3) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options3);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v4) {
        if (rangeObj.test(v4)) {
          if (!max || maxSV.compare(v4) === -1) {
            max = v4;
            maxSV = new SemVer(max, options3);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options3) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options3);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v4) {
        if (rangeObj.test(v4)) {
          if (!min || minSV.compare(v4) === 1) {
            min = v4;
            minSV = new SemVer(min, options3);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i5 = 0; i5 < range.set.length; ++i5) {
        var comparators = range.set[i5];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options3) {
      try {
        return new Range(range, options3).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options3) {
      return outside(version, range, "<", options3);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options3) {
      return outside(version, range, ">", options3);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options3) {
      version = new SemVer(version, options3);
      range = new Range(range, options3);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options3)) {
        return false;
      }
      for (var i5 = 0; i5 < range.set.length; ++i5) {
        var comparators = range.set[i5];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options3)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options3)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options3) {
      var parsed = parse3(version, options3);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r22, options3) {
      r1 = new Range(r1, options3);
      r22 = new Range(r22, options3);
      return r1.intersects(r22);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match2 = version.match(re[COERCE]);
      if (match2 == null) {
        return null;
      }
      return parse3(match2[1] + "." + (match2[2] || "0") + "." + (match2[3] || "0"));
    }
  }
});

// node_modules/make-dir/index.js
var require_make_dir2 = __commonJS({
  "node_modules/make-dir/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path8 = require("path");
    var pify = require_pify5();
    var semver = require_semver();
    var defaults = {
      mode: 511 & ~process.umask(),
      fs: fs2
    };
    var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path8.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    var makeDir = (input, options3) => Promise.resolve().then(() => {
      checkPath(input);
      options3 = Object.assign({}, defaults, options3);
      const mkdir = pify(options3.fs.mkdir);
      const stat = pify(options3.fs.stat);
      if (useNativeRecursiveOption && options3.fs.mkdir === fs2.mkdir) {
        const pth = path8.resolve(input);
        return mkdir(pth, {
          mode: options3.mode,
          recursive: true
        }).then(() => pth);
      }
      const make = (pth) => {
        return mkdir(pth, options3.mode).then(() => pth).catch((error) => {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path8.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            return make(path8.dirname(pth)).then(() => make(pth));
          }
          return stat(pth).then((stats) => stats.isDirectory() ? pth : Promise.reject()).catch(() => {
            throw error;
          });
        });
      };
      return make(path8.resolve(input));
    });
    module2.exports = makeDir;
    module2.exports.default = makeDir;
    module2.exports.sync = (input, options3) => {
      checkPath(input);
      options3 = Object.assign({}, defaults, options3);
      if (useNativeRecursiveOption && options3.fs.mkdirSync === fs2.mkdirSync) {
        const pth = path8.resolve(input);
        fs2.mkdirSync(pth, {
          mode: options3.mode,
          recursive: true
        });
        return pth;
      }
      const make = (pth) => {
        try {
          options3.fs.mkdirSync(pth, options3.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path8.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path8.dirname(pth));
            return make(pth);
          }
          try {
            if (!options3.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_3) {
            throw error;
          }
        }
        return pth;
      };
      return make(path8.resolve(input));
    };
  }
});

// node_modules/download/node_modules/pify/index.js
var require_pify6 = __commonJS({
  "node_modules/download/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn2, options3) => function(...args2) {
      const P3 = options3.promiseModule;
      return new P3((resolve2, reject2) => {
        if (options3.multiArgs) {
          args2.push((...result) => {
            if (options3.errorFirst) {
              if (result[0]) {
                reject2(result);
              } else {
                result.shift();
                resolve2(result);
              }
            } else {
              resolve2(result);
            }
          });
        } else if (options3.errorFirst) {
          args2.push((error, result) => {
            if (error) {
              reject2(error);
            } else {
              resolve2(result);
            }
          });
        } else {
          args2.push(resolve2);
        }
        fn2.apply(this, args2);
      });
    };
    module2.exports = (input, options3) => {
      options3 = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, options3);
      const objType2 = typeof input;
      if (!(input !== null && (objType2 === "object" || objType2 === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objType2}\``);
      }
      const filter = (key) => {
        const match2 = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return options3.include ? options3.include.some(match2) : !options3.exclude.some(match2);
      };
      let ret;
      if (objType2 === "function") {
        ret = function(...args2) {
          return options3.excludeMain ? input(...args2) : processFn(input, options3).apply(this, args2);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(input));
      }
      for (const key in input) {
        const property = input[key];
        ret[key] = typeof property === "function" && filter(key) ? processFn(property, options3) : property;
      }
      return ret;
    };
  }
});

// node_modules/p-event/index.js
var require_p_event = __commonJS({
  "node_modules/p-event/index.js"(exports2, module2) {
    "use strict";
    var pTimeout = require_p_timeout();
    var symbolAsyncIterator = Symbol.asyncIterator || "@@asyncIterator";
    var normalizeEmitter = (emitter) => {
      const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
      const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
      if (!addListener || !removeListener) {
        throw new TypeError("Emitter is not compatible");
      }
      return {
        addListener: addListener.bind(emitter),
        removeListener: removeListener.bind(emitter)
      };
    };
    var normalizeEvents = (event) => Array.isArray(event) ? event : [event];
    var multiple = (emitter, event, options3) => {
      let cancel;
      const ret = new Promise((resolve2, reject2) => {
        options3 = Object.assign({
          rejectionEvents: ["error"],
          multiArgs: false,
          resolveImmediately: false
        }, options3);
        if (!(options3.count >= 0 && (options3.count === Infinity || Number.isInteger(options3.count)))) {
          throw new TypeError("The `count` option should be at least 0 or more");
        }
        const events = normalizeEvents(event);
        const items = [];
        const { addListener, removeListener } = normalizeEmitter(emitter);
        const onItem = (...args2) => {
          const value = options3.multiArgs ? args2 : args2[0];
          if (options3.filter && !options3.filter(value)) {
            return;
          }
          items.push(value);
          if (options3.count === items.length) {
            cancel();
            resolve2(items);
          }
        };
        const rejectHandler = (error) => {
          cancel();
          reject2(error);
        };
        cancel = () => {
          for (const event2 of events) {
            removeListener(event2, onItem);
          }
          for (const rejectionEvent of options3.rejectionEvents) {
            removeListener(rejectionEvent, rejectHandler);
          }
        };
        for (const event2 of events) {
          addListener(event2, onItem);
        }
        for (const rejectionEvent of options3.rejectionEvents) {
          addListener(rejectionEvent, rejectHandler);
        }
        if (options3.resolveImmediately) {
          resolve2(items);
        }
      });
      ret.cancel = cancel;
      if (typeof options3.timeout === "number") {
        const timeout = pTimeout(ret, options3.timeout);
        timeout.cancel = cancel;
        return timeout;
      }
      return ret;
    };
    module2.exports = (emitter, event, options3) => {
      if (typeof options3 === "function") {
        options3 = { filter: options3 };
      }
      options3 = Object.assign({}, options3, {
        count: 1,
        resolveImmediately: false
      });
      const arrayPromise = multiple(emitter, event, options3);
      const promise = arrayPromise.then((array) => array[0]);
      promise.cancel = arrayPromise.cancel;
      return promise;
    };
    module2.exports.multiple = multiple;
    module2.exports.iterator = (emitter, event, options3) => {
      if (typeof options3 === "function") {
        options3 = { filter: options3 };
      }
      const events = normalizeEvents(event);
      options3 = Object.assign({
        rejectionEvents: ["error"],
        resolutionEvents: [],
        limit: Infinity,
        multiArgs: false
      }, options3);
      const { limit } = options3;
      const isValidLimit = limit >= 0 && (limit === Infinity || Number.isInteger(limit));
      if (!isValidLimit) {
        throw new TypeError("The `limit` option should be a non-negative integer or Infinity");
      }
      if (limit === 0) {
        return {
          [Symbol.asyncIterator]() {
            return this;
          },
          next() {
            return Promise.resolve({ done: true, value: void 0 });
          }
        };
      }
      let isLimitReached = false;
      const { addListener, removeListener } = normalizeEmitter(emitter);
      let done = false;
      let error;
      let hasPendingError = false;
      const nextQueue = [];
      const valueQueue = [];
      let eventCount = 0;
      const valueHandler = (...args2) => {
        eventCount++;
        isLimitReached = eventCount === limit;
        const value = options3.multiArgs ? args2 : args2[0];
        if (nextQueue.length > 0) {
          const { resolve: resolve2 } = nextQueue.shift();
          resolve2({ done: false, value });
          if (isLimitReached) {
            cancel();
          }
          return;
        }
        valueQueue.push(value);
        if (isLimitReached) {
          cancel();
        }
      };
      const cancel = () => {
        done = true;
        for (const event2 of events) {
          removeListener(event2, valueHandler);
        }
        for (const rejectionEvent of options3.rejectionEvents) {
          removeListener(rejectionEvent, rejectHandler);
        }
        for (const resolutionEvent of options3.resolutionEvents) {
          removeListener(resolutionEvent, resolveHandler);
        }
        while (nextQueue.length > 0) {
          const { resolve: resolve2 } = nextQueue.shift();
          resolve2({ done: true, value: void 0 });
        }
      };
      const rejectHandler = (...args2) => {
        error = options3.multiArgs ? args2 : args2[0];
        if (nextQueue.length > 0) {
          const { reject: reject2 } = nextQueue.shift();
          reject2(error);
        } else {
          hasPendingError = true;
        }
        cancel();
      };
      const resolveHandler = (...args2) => {
        const value = options3.multiArgs ? args2 : args2[0];
        if (options3.filter && !options3.filter(value)) {
          return;
        }
        if (nextQueue.length > 0) {
          const { resolve: resolve2 } = nextQueue.shift();
          resolve2({ done: true, value });
        } else {
          valueQueue.push(value);
        }
        cancel();
      };
      for (const event2 of events) {
        addListener(event2, valueHandler);
      }
      for (const rejectionEvent of options3.rejectionEvents) {
        addListener(rejectionEvent, rejectHandler);
      }
      for (const resolutionEvent of options3.resolutionEvents) {
        addListener(resolutionEvent, resolveHandler);
      }
      return {
        [symbolAsyncIterator]() {
          return this;
        },
        next() {
          if (valueQueue.length > 0) {
            const value = valueQueue.shift();
            return Promise.resolve({ done: done && valueQueue.length === 0 && !isLimitReached, value });
          }
          if (hasPendingError) {
            hasPendingError = false;
            return Promise.reject(error);
          }
          if (done) {
            return Promise.resolve({ done: true, value: void 0 });
          }
          return new Promise((resolve2, reject2) => nextQueue.push({ resolve: resolve2, reject: reject2 }));
        },
        return(value) {
          cancel();
          return Promise.resolve({ done, value });
        }
      };
    };
  }
});

// node_modules/download/node_modules/file-type/util.js
var require_util2 = __commonJS({
  "node_modules/download/node_modules/file-type/util.js"(exports2) {
    "use strict";
    exports2.stringToBytes = (string) => [...string].map((character2) => character2.charCodeAt(0));
    var uint8ArrayUtf8ByteString2 = (array, start, end) => {
      return String.fromCharCode(...array.slice(start, end));
    };
    exports2.readUInt64LE = (buffer, offset = 0) => {
      let n3 = buffer[offset];
      let mul = 1;
      let i4 = 0;
      while (++i4 < 8) {
        mul *= 256;
        n3 += buffer[offset + i4] * mul;
      }
      return n3;
    };
    exports2.tarHeaderChecksumMatches = (buffer) => {
      if (buffer.length < 512) {
        return false;
      }
      const MASK_8TH_BIT = 128;
      let sum = 256;
      let signedBitSum = 0;
      for (let i4 = 0; i4 < 148; i4++) {
        const byte = buffer[i4];
        sum += byte;
        signedBitSum += byte & MASK_8TH_BIT;
      }
      for (let i4 = 156; i4 < 512; i4++) {
        const byte = buffer[i4];
        sum += byte;
        signedBitSum += byte & MASK_8TH_BIT;
      }
      const readSum = parseInt(uint8ArrayUtf8ByteString2(buffer, 148, 154), 8);
      return (
        // Checksum in header equals the sum we calculated
        readSum === sum || // Checksum in header equals sum we calculated plus signed-to-unsigned delta
        readSum === sum - (signedBitSum << 1)
      );
    };
    exports2.uint8ArrayUtf8ByteString = uint8ArrayUtf8ByteString2;
  }
});

// node_modules/download/node_modules/file-type/index.js
var require_file_type5 = __commonJS({
  "node_modules/download/node_modules/file-type/index.js"(exports, module) {
    "use strict";
    var { stringToBytes, readUInt64LE, tarHeaderChecksumMatches, uint8ArrayUtf8ByteString } = require_util2();
    var xpiZipFilename = stringToBytes("META-INF/mozilla.rsa");
    var oxmlContentTypes = stringToBytes("[Content_Types].xml");
    var oxmlRels = stringToBytes("_rels/.rels");
    var fileType = (input) => {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
      if (!(buffer && buffer.length > 1)) {
        return;
      }
      const check = (header, options3) => {
        options3 = Object.assign({
          offset: 0
        }, options3);
        for (let i4 = 0; i4 < header.length; i4++) {
          if (options3.mask) {
            if (header[i4] !== (options3.mask[i4] & buffer[i4 + options3.offset])) {
              return false;
            }
          } else if (header[i4] !== buffer[i4 + options3.offset]) {
            return false;
          }
        }
        return true;
      };
      const checkString = (header, options3) => check(stringToBytes(header), options3);
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (check([73, 73, 42, 0, 16, 251, 134, 1])) {
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      }
      if (check([73, 73, 42, 0, 8, 0, 0, 0, 45])) {
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      }
      if (check([73, 73, 42, 0, 48, 61, 114, 1, 28])) {
        return {
          ext: "nef",
          mime: "image/x-nikon-nef"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4])) {
        if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
          return {
            ext: "epub",
            mime: "application/epub+zip"
          };
        }
        if (check(xpiZipFilename, { offset: 30 })) {
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", { offset: 30 })) {
          return {
            ext: "odt",
            mime: "application/vnd.oasis.opendocument.text"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", { offset: 30 })) {
          return {
            ext: "ods",
            mime: "application/vnd.oasis.opendocument.spreadsheet"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", { offset: 30 })) {
          return {
            ext: "odp",
            mime: "application/vnd.oasis.opendocument.presentation"
          };
        }
        const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i4, arr2) => i4 >= startAt && arr2[i4] === 80 && arr2[i4 + 1] === 75 && arr2[i4 + 2] === 3 && arr2[i4 + 3] === 4);
        let zipHeaderIndex = 0;
        let oxmlFound = false;
        let type;
        do {
          const offset = zipHeaderIndex + 30;
          if (!oxmlFound) {
            oxmlFound = check(oxmlContentTypes, { offset }) || check(oxmlRels, { offset });
          }
          if (!type) {
            if (checkString("word/", { offset })) {
              type = {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              };
            } else if (checkString("ppt/", { offset })) {
              type = {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              };
            } else if (checkString("xl/", { offset })) {
              type = {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
          }
          if (oxmlFound && type) {
            return type;
          }
          zipHeaderIndex = findNextZipHeaderIndex(buffer, offset);
        } while (zipHeaderIndex >= 0);
        if (type) {
          return type;
        }
      }
      if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([48, 48, 48, 48, 48, 48], { offset: 148, mask: [248, 248, 248, 248, 248, 248] }) && // Valid tar checksum
      tarHeaderChecksumMatches(buffer)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([102, 114, 101, 101], { offset: 4 }) || // `free`
      check([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
      check([109, 111, 111, 118], { offset: 4 }) || // `moov`
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([102, 116, 121, 112], { offset: 4 }) && // `ftyp`
      (buffer[8] & 96) !== 0 && (buffer[9] & 96) !== 0 && (buffer[10] & 96) !== 0 && (buffer[11] & 96) !== 0) {
        const brandMajor = uint8ArrayUtf8ByteString(buffer, 8, 12);
        switch (brandMajor) {
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt  ":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V ":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P ":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B ":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A ":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V ":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P ":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A ":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B ":
            return { ext: "f4b", mime: "audio/mp4" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buffer.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i4, arr) => arr[i4] === 66 && arr[i4 + 1] === 130);
        if (idPos !== -1) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => [...type].every((c4, i4) => sliced[docTypePos + i4] === c4.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        let offset = 30;
        do {
          const objectSize = readUInt64LE(buffer, offset + 16);
          if (check([145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101], { offset })) {
            if (check([64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
              return {
                ext: "wma",
                mime: "audio/x-ms-wma"
              };
            }
            if (check([192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
              return {
                ext: "wmv",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          offset += objectSize;
        } while (offset + 24 <= buffer.length);
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      for (let start = 0; start < 2 && start < buffer.length - 16; start++) {
        if (check([73, 68, 51], { offset: start }) || // ID3 header
        check([255, 226], { offset: start, mask: [255, 230] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 228], { offset: start, mask: [255, 230] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 248], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 240], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp4",
            mime: "audio/mpeg"
          };
        }
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        if (check([128, 116, 104, 101, 111, 114, 97], { offset: 28 })) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (check([1, 118, 105, 100, 101, 111, 0], { offset: 28 })) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (check([127, 70, 76, 65, 67], { offset: 28 })) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (check([83, 112, 101, 101, 120, 32, 32], { offset: 28 })) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (check([1, 118, 111, 114, 98, 105, 115], { offset: 28 })) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([77, 65, 67, 32])) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([119, 118, 112, 107])) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        if (check([106, 112, 50, 32], { offset: 20 })) {
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        }
        if (check([106, 112, 120, 32], { offset: 20 })) {
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        }
        if (check([106, 112, 109, 32], { offset: 20 })) {
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        }
        if (check([109, 106, 112, 50], { offset: 20 })) {
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        }
      }
      if (check([70, 79, 82, 77])) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if (check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (check([77, 80, 43])) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (check([77, 80, 67, 75])) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (check([66, 69, 71, 73, 78, 58])) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
      if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (check([68, 83, 68, 32])) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
          // Non-standard
        };
      }
      if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
          // Invented by us
        };
      }
      if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
          // Invented by us
        };
      }
      if (checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
    };
    module.exports = fileType;
    Object.defineProperty(fileType, "minimumBytes", { value: 4100 });
    fileType.stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.once("readable", () => {
        const pass = new stream.PassThrough();
        const chunk = readableStream.read(module.exports.minimumBytes) || readableStream.read();
        try {
          pass.fileType = fileType(chunk);
        } catch (error) {
          reject(error);
        }
        readableStream.unshift(chunk);
        if (stream.pipeline) {
          resolve(stream.pipeline(readableStream, pass, () => {
          }));
        } else {
          resolve(readableStream.pipe(pass));
        }
      });
    });
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/ext-list/index.js
var require_ext_list = __commonJS({
  "node_modules/ext-list/index.js"(exports2, module2) {
    "use strict";
    var mimeDb = require_mime_db();
    module2.exports = function() {
      var ret = {};
      Object.keys(mimeDb).forEach(function(x5) {
        var val = mimeDb[x5];
        if (val.extensions && val.extensions.length > 0) {
          val.extensions.forEach(function(y4) {
            ret[y4] = x5;
          });
        }
      });
      return ret;
    };
  }
});

// node_modules/sort-keys/index.js
var require_sort_keys2 = __commonJS({
  "node_modules/sort-keys/index.js"(exports2, module2) {
    "use strict";
    var isPlainObj = require_is_plain_obj();
    module2.exports = function(obj, opts) {
      if (!isPlainObj(obj)) {
        throw new TypeError("Expected a plain object");
      }
      opts = opts || {};
      if (typeof opts === "function") {
        opts = { compare: opts };
      }
      var deep = opts.deep;
      var seenInput = [];
      var seenOutput = [];
      var sortKeys = function(x5) {
        var seenIndex = seenInput.indexOf(x5);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        var ret = {};
        var keys = Object.keys(x5).sort(opts.compare);
        seenInput.push(x5);
        seenOutput.push(ret);
        for (var i4 = 0; i4 < keys.length; i4++) {
          var key = keys[i4];
          var val = x5[key];
          ret[key] = deep && isPlainObj(val) ? sortKeys(val) : val;
        }
        return ret;
      };
      return sortKeys(obj);
    };
  }
});

// node_modules/sort-keys-length/index.js
var require_sort_keys_length = __commonJS({
  "node_modules/sort-keys-length/index.js"(exports2, module2) {
    "use strict";
    var sortKeys = require_sort_keys2();
    module2.exports.desc = function(obj) {
      return sortKeys(obj, function(a3, b4) {
        return b4.length - a3.length;
      });
    };
    module2.exports.asc = function(obj) {
      return sortKeys(obj, function(a3, b4) {
        return a3.length - b4.length;
      });
    };
  }
});

// node_modules/ext-name/index.js
var require_ext_name = __commonJS({
  "node_modules/ext-name/index.js"(exports2, module2) {
    "use strict";
    var extList = require_ext_list();
    var sortKeysLength = require_sort_keys_length();
    module2.exports = (str) => {
      const obj = sortKeysLength.desc(extList());
      const exts = Object.keys(obj).filter((x5) => str.endsWith(x5));
      if (exts.length === 0) {
        return [];
      }
      return exts.map((x5) => ({
        ext: x5,
        mime: obj[x5]
      }));
    };
    module2.exports.mime = (str) => {
      const obj = sortKeysLength.desc(extList());
      const exts = Object.keys(obj).filter((x5) => obj[x5] === str);
      if (exts.length === 0) {
        return [];
      }
      return exts.map((x5) => ({
        ext: x5,
        mime: obj[x5]
      }));
    };
  }
});

// node_modules/download/index.js
var require_download = __commonJS({
  "node_modules/download/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path8 = require("path");
    var { URL: URL2 } = require("url");
    var contentDisposition = require_content_disposition();
    var archiveType = require_archive_type();
    var decompress = require_decompress();
    var filenamify = require_filenamify();
    var getStream2 = require_get_stream4();
    var got = require_got();
    var makeDir = require_make_dir2();
    var pify = require_pify6();
    var pEvent = require_p_event();
    var fileType2 = require_file_type5();
    var extName = require_ext_name();
    var fsP = pify(fs2);
    var filenameFromPath = (res) => path8.basename(new URL2(res.requestUrl).pathname);
    var getExtFromMime = (res) => {
      const header = res.headers["content-type"];
      if (!header) {
        return null;
      }
      const exts = extName.mime(header);
      if (exts.length !== 1) {
        return null;
      }
      return exts[0].ext;
    };
    var getFilename = (res, data) => {
      const header = res.headers["content-disposition"];
      if (header) {
        const parsed = contentDisposition.parse(header);
        if (parsed.parameters && parsed.parameters.filename) {
          return parsed.parameters.filename;
        }
      }
      let filename = filenameFromPath(res);
      if (!path8.extname(filename)) {
        const ext = (fileType2(data) || {}).ext || getExtFromMime(res);
        if (ext) {
          filename = `${filename}.${ext}`;
        }
      }
      return filename;
    };
    module2.exports = (uri, output, opts) => {
      if (typeof output === "object") {
        opts = output;
        output = null;
      }
      opts = Object.assign({
        encoding: null,
        rejectUnauthorized: process.env.npm_config_strict_ssl !== "false"
      }, opts);
      const stream2 = got.stream(uri, opts);
      const promise = pEvent(stream2, "response").then((res) => {
        const encoding = opts.encoding === null ? "buffer" : opts.encoding;
        return Promise.all([getStream2(stream2, { encoding }), res]);
      }).then((result) => {
        const [data, res] = result;
        if (!output) {
          return opts.extract && archiveType(data) ? decompress(data, opts) : data;
        }
        const filename = opts.filename || filenamify(getFilename(res, data));
        const outputFilepath = path8.join(output, filename);
        if (opts.extract && archiveType(data)) {
          return decompress(data, path8.dirname(outputFilepath), opts);
        }
        return makeDir(path8.dirname(outputFilepath)).then(() => fsP.writeFile(outputFilepath, data)).then(() => data);
      });
      stream2.then = promise.then.bind(promise);
      stream2.catch = promise.catch.bind(promise);
      return stream2;
    };
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports2.AsyncMode = AsyncMode;
        exports2.ConcurrentMode = ConcurrentMode;
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element;
        exports2.ForwardRef = ForwardRef;
        exports2.Fragment = Fragment;
        exports2.Lazy = Lazy;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement;
        exports2.isForwardRef = isForwardRef;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isValidElementType = isValidElementType;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports2, module2) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i4 = 0; i4 < keys.length; ++i4) {
          var key = keys[i4];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e3) {
            }
          }
        }
      }
      return targetComponent;
    }
    module2.exports = hoistNonReactStatics;
  }
});

// node_modules/which/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/which/lib/index.js"(exports2, module2) {
    var isexe = require_isexe();
    var { join, delimiter: delimiter2, sep, posix } = require("path");
    var isWindows = process.platform === "win32";
    var rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? "" : sep}]`.replace(/(\\)/g, "\\$1"));
    var rRel = new RegExp(`^\\.${rSlash.source}`);
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, {
      path: optPath = process.env.PATH,
      pathExt: optPathExt = process.env.PATHEXT,
      delimiter: optDelimiter = delimiter2
    }) => {
      const pathEnv = cmd.match(rSlash) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(optPath || /* istanbul ignore next: very unusual */
        "").split(optDelimiter)
      ];
      if (isWindows) {
        const pathExtExe = optPathExt || [".EXE", ".CMD", ".BAT", ".COM"].join(optDelimiter);
        const pathExt = pathExtExe.split(optDelimiter).reduce((acc, item) => {
          acc.push(item);
          acc.push(item.toLowerCase());
          return acc;
        }, []);
        if (cmd.includes(".") && pathExt[0] !== "") {
          pathExt.unshift("");
        }
        return { pathEnv, pathExt, pathExtExe };
      }
      return { pathEnv, pathExt: [""] };
    };
    var getPathPart = (raw, cmd) => {
      const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
      const prefix2 = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "";
      return prefix2 + join(pathPart, cmd);
    };
    var which2 = async (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const envPart of pathEnv) {
        const p5 = getPathPart(envPart, cmd);
        for (const ext of pathExt) {
          const withExt = p5 + ext;
          const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    var whichSync = (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const pathEnvPart of pathEnv) {
        const p5 = getPathPart(pathEnvPart, cmd);
        for (const ext of pathExt) {
          const withExt = p5 + ext;
          const is = isexe.sync(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZoteroConnector
});
module.exports = __toCommonJS(main_exports);
var import_obsidian20 = require("obsidian");

// node_modules/shell-env/index.js
var import_node_process2 = __toESM(require("node:process"), 1);
var import_execa = __toESM(require_execa(), 1);

// node_modules/shell-env/node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}

// node_modules/shell-env/node_modules/strip-ansi/index.js
var regex = ansiRegex();
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(regex, "");
}

// node_modules/default-shell/index.js
var import_node_process = __toESM(require("node:process"), 1);
var import_node_os = require("node:os");
var detectDefaultShell = () => {
  const { env: env2 } = import_node_process.default;
  if (import_node_process.default.platform === "win32") {
    return env2.COMSPEC || "cmd.exe";
  }
  try {
    const { shell } = (0, import_node_os.userInfo)();
    if (shell) {
      return shell;
    }
  } catch (e3) {
  }
  if (import_node_process.default.platform === "darwin") {
    return env2.SHELL || "/bin/zsh";
  }
  return env2.SHELL || "/bin/sh";
};
var defaultShell = detectDefaultShell();
var default_shell_default = defaultShell;

// node_modules/shell-env/index.js
var args = [
  "-ilc",
  'echo -n "_SHELL_ENV_DELIMITER_"; env; echo -n "_SHELL_ENV_DELIMITER_"; exit'
];
var env = {
  // Disables Oh My Zsh auto-update thing that can block the process.
  DISABLE_AUTO_UPDATE: "true"
};
var parseEnv = (env2) => {
  env2 = env2.split("_SHELL_ENV_DELIMITER_")[1];
  const returnValue = {};
  for (const line2 of stripAnsi(env2).split("\n").filter((line3) => Boolean(line3))) {
    const [key, ...values] = line2.split("=");
    returnValue[key] = values.join("=");
  }
  return returnValue;
};
async function shellEnv(shell) {
  if (import_node_process2.default.platform === "win32") {
    return import_node_process2.default.env;
  }
  try {
    const { stdout } = await (0, import_execa.default)(shell || default_shell_default, args, { env });
    return parseEnv(stdout);
  } catch (error) {
    if (shell) {
      throw error;
    } else {
      return import_node_process2.default.env;
    }
  }
}

// node_modules/shell-path/index.js
async function shellPath() {
  const { PATH } = await shellEnv();
  return PATH;
}

// src/DataExplorerView.tsx
var import_obsidian11 = require("obsidian");

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var o;
var r;
var f;
var e;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var v = Array.isArray;
function h(n3, l4) {
  for (var u3 in l4)
    n3[u3] = l4[u3];
  return n3;
}
function p(n3) {
  var l4 = n3.parentNode;
  l4 && l4.removeChild(n3);
}
function y(l4, u3, i4) {
  var t3, o4, r5, f4 = {};
  for (r5 in u3)
    "key" == r5 ? t3 = u3[r5] : "ref" == r5 ? o4 = u3[r5] : f4[r5] = u3[r5];
  if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i4), "function" == typeof l4 && null != l4.defaultProps)
    for (r5 in l4.defaultProps)
      void 0 === f4[r5] && (f4[r5] = l4.defaultProps[r5]);
  return d(l4, f4, t3, o4, null);
}
function d(n3, i4, t3, o4, r5) {
  var f4 = { type: n3, props: i4, key: t3, ref: o4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == r5 ? ++u : r5 };
  return null == r5 && null != l.vnode && l.vnode(f4), f4;
}
function _() {
  return { current: null };
}
function k(n3) {
  return n3.children;
}
function b(n3, l4) {
  this.props = n3, this.context = l4;
}
function g(n3, l4) {
  if (null == l4)
    return n3.__ ? g(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u3; l4 < n3.__k.length; l4++)
    if (null != (u3 = n3.__k[l4]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n3.type ? g(n3) : null;
}
function m(n3) {
  var l4, u3;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l4 = 0; l4 < n3.__k.length; l4++)
      if (null != (u3 = n3.__k[l4]) && null != u3.__e) {
        n3.__e = n3.__c.base = u3.__e;
        break;
      }
    return m(n3);
  }
}
function w(n3) {
  (!n3.__d && (n3.__d = true) && t.push(n3) && !x.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(x);
}
function x() {
  var n3, l4, u3, i4, o4, r5, e3, c4;
  for (t.sort(f); n3 = t.shift(); )
    n3.__d && (l4 = t.length, i4 = void 0, o4 = void 0, e3 = (r5 = (u3 = n3).__v).__e, (c4 = u3.__P) && (i4 = [], (o4 = h({}, r5)).__v = r5.__v + 1, L(c4, r5, o4, u3.__n, void 0 !== c4.ownerSVGElement, null != r5.__h ? [e3] : null, i4, null == e3 ? g(r5) : e3, r5.__h), M(i4, r5), r5.__e != e3 && m(r5)), t.length > l4 && t.sort(f));
  x.__r = 0;
}
function P(n3, l4, u3, i4, t3, o4, r5, f4, e3, a3) {
  var h4, p5, y4, _3, b4, m4, w6, x5 = i4 && i4.__k || s, P3 = x5.length;
  for (u3.__k = [], h4 = 0; h4 < l4.length; h4++)
    if (null != (_3 = u3.__k[h4] = null == (_3 = l4[h4]) || "boolean" == typeof _3 || "function" == typeof _3 ? null : "string" == typeof _3 || "number" == typeof _3 || "bigint" == typeof _3 ? d(null, _3, null, null, _3) : v(_3) ? d(k, { children: _3 }, null, null, null) : _3.__b > 0 ? d(_3.type, _3.props, _3.key, _3.ref ? _3.ref : null, _3.__v) : _3)) {
      if (_3.__ = u3, _3.__b = u3.__b + 1, null === (y4 = x5[h4]) || y4 && _3.key == y4.key && _3.type === y4.type)
        x5[h4] = void 0;
      else
        for (p5 = 0; p5 < P3; p5++) {
          if ((y4 = x5[p5]) && _3.key == y4.key && _3.type === y4.type) {
            x5[p5] = void 0;
            break;
          }
          y4 = null;
        }
      L(n3, _3, y4 = y4 || c, t3, o4, r5, f4, e3, a3), b4 = _3.__e, (p5 = _3.ref) && y4.ref != p5 && (w6 || (w6 = []), y4.ref && w6.push(y4.ref, null, _3), w6.push(p5, _3.__c || b4, _3)), null != b4 ? (null == m4 && (m4 = b4), "function" == typeof _3.type && _3.__k === y4.__k ? _3.__d = e3 = C(_3, e3, n3) : e3 = $(n3, _3, y4, x5, b4, e3), "function" == typeof u3.type && (u3.__d = e3)) : e3 && y4.__e == e3 && e3.parentNode != n3 && (e3 = g(y4));
    }
  for (u3.__e = m4, h4 = P3; h4--; )
    null != x5[h4] && ("function" == typeof u3.type && null != x5[h4].__e && x5[h4].__e == u3.__d && (u3.__d = A(i4).nextSibling), q(x5[h4], x5[h4]));
  if (w6)
    for (h4 = 0; h4 < w6.length; h4++)
      O(w6[h4], w6[++h4], w6[++h4]);
}
function C(n3, l4, u3) {
  for (var i4, t3 = n3.__k, o4 = 0; t3 && o4 < t3.length; o4++)
    (i4 = t3[o4]) && (i4.__ = n3, l4 = "function" == typeof i4.type ? C(i4, l4, u3) : $(u3, i4, i4, t3, i4.__e, l4));
  return l4;
}
function S(n3, l4) {
  return l4 = l4 || [], null == n3 || "boolean" == typeof n3 || (v(n3) ? n3.some(function(n4) {
    S(n4, l4);
  }) : l4.push(n3)), l4;
}
function $(n3, l4, u3, i4, t3, o4) {
  var r5, f4, e3;
  if (void 0 !== l4.__d)
    r5 = l4.__d, l4.__d = void 0;
  else if (null == u3 || t3 != o4 || null == t3.parentNode)
    n:
      if (null == o4 || o4.parentNode !== n3)
        n3.appendChild(t3), r5 = null;
      else {
        for (f4 = o4, e3 = 0; (f4 = f4.nextSibling) && e3 < i4.length; e3 += 1)
          if (f4 == t3)
            break n;
        n3.insertBefore(t3, o4), r5 = o4;
      }
  return void 0 !== r5 ? r5 : t3.nextSibling;
}
function A(n3) {
  var l4, u3, i4;
  if (null == n3.type || "string" == typeof n3.type)
    return n3.__e;
  if (n3.__k) {
    for (l4 = n3.__k.length - 1; l4 >= 0; l4--)
      if ((u3 = n3.__k[l4]) && (i4 = A(u3)))
        return i4;
  }
  return null;
}
function H(n3, l4, u3, i4, t3) {
  var o4;
  for (o4 in u3)
    "children" === o4 || "key" === o4 || o4 in l4 || T(n3, o4, null, u3[o4], i4);
  for (o4 in l4)
    t3 && "function" != typeof l4[o4] || "children" === o4 || "key" === o4 || "value" === o4 || "checked" === o4 || u3[o4] === l4[o4] || T(n3, o4, l4[o4], u3[o4], i4);
}
function I(n3, l4, u3) {
  "-" === l4[0] ? n3.setProperty(l4, null == u3 ? "" : u3) : n3[l4] = null == u3 ? "" : "number" != typeof u3 || a.test(l4) ? u3 : u3 + "px";
}
function T(n3, l4, u3, i4, t3) {
  var o4;
  n:
    if ("style" === l4)
      if ("string" == typeof u3)
        n3.style.cssText = u3;
      else {
        if ("string" == typeof i4 && (n3.style.cssText = i4 = ""), i4)
          for (l4 in i4)
            u3 && l4 in u3 || I(n3.style, l4, "");
        if (u3)
          for (l4 in u3)
            i4 && u3[l4] === i4[l4] || I(n3.style, l4, u3[l4]);
      }
    else if ("o" === l4[0] && "n" === l4[1])
      o4 = l4 !== (l4 = l4.replace(/Capture$/, "")), l4 = l4.toLowerCase() in n3 ? l4.toLowerCase().slice(2) : l4.slice(2), n3.l || (n3.l = {}), n3.l[l4 + o4] = u3, u3 ? i4 || n3.addEventListener(l4, o4 ? z : j, o4) : n3.removeEventListener(l4, o4 ? z : j, o4);
    else if ("dangerouslySetInnerHTML" !== l4) {
      if (t3)
        l4 = l4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l4 && "height" !== l4 && "href" !== l4 && "list" !== l4 && "form" !== l4 && "tabIndex" !== l4 && "download" !== l4 && "rowSpan" !== l4 && "colSpan" !== l4 && l4 in n3)
        try {
          n3[l4] = null == u3 ? "" : u3;
          break n;
        } catch (n4) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && "-" !== l4[4] ? n3.removeAttribute(l4) : n3.setAttribute(l4, u3));
    }
}
function j(n3) {
  return this.l[n3.type + false](l.event ? l.event(n3) : n3);
}
function z(n3) {
  return this.l[n3.type + true](l.event ? l.event(n3) : n3);
}
function L(n3, u3, i4, t3, o4, r5, f4, e3, c4) {
  var s5, a3, p5, y4, d5, _3, g5, m4, w6, x5, C3, S3, $4, A4, H3, I3 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  null != i4.__h && (c4 = i4.__h, e3 = u3.__e = i4.__e, u3.__h = null, r5 = [e3]), (s5 = l.__b) && s5(u3);
  try {
    n:
      if ("function" == typeof I3) {
        if (m4 = u3.props, w6 = (s5 = I3.contextType) && t3[s5.__c], x5 = s5 ? w6 ? w6.props.value : s5.__ : t3, i4.__c ? g5 = (a3 = u3.__c = i4.__c).__ = a3.__E : ("prototype" in I3 && I3.prototype.render ? u3.__c = a3 = new I3(m4, x5) : (u3.__c = a3 = new b(m4, x5), a3.constructor = I3, a3.render = B), w6 && w6.sub(a3), a3.props = m4, a3.state || (a3.state = {}), a3.context = x5, a3.__n = t3, p5 = a3.__d = true, a3.__h = [], a3._sb = []), null == a3.__s && (a3.__s = a3.state), null != I3.getDerivedStateFromProps && (a3.__s == a3.state && (a3.__s = h({}, a3.__s)), h(a3.__s, I3.getDerivedStateFromProps(m4, a3.__s))), y4 = a3.props, d5 = a3.state, a3.__v = u3, p5)
          null == I3.getDerivedStateFromProps && null != a3.componentWillMount && a3.componentWillMount(), null != a3.componentDidMount && a3.__h.push(a3.componentDidMount);
        else {
          if (null == I3.getDerivedStateFromProps && m4 !== y4 && null != a3.componentWillReceiveProps && a3.componentWillReceiveProps(m4, x5), !a3.__e && null != a3.shouldComponentUpdate && false === a3.shouldComponentUpdate(m4, a3.__s, x5) || u3.__v === i4.__v) {
            for (u3.__v !== i4.__v && (a3.props = m4, a3.state = a3.__s, a3.__d = false), a3.__e = false, u3.__e = i4.__e, u3.__k = i4.__k, u3.__k.forEach(function(n4) {
              n4 && (n4.__ = u3);
            }), C3 = 0; C3 < a3._sb.length; C3++)
              a3.__h.push(a3._sb[C3]);
            a3._sb = [], a3.__h.length && f4.push(a3);
            break n;
          }
          null != a3.componentWillUpdate && a3.componentWillUpdate(m4, a3.__s, x5), null != a3.componentDidUpdate && a3.__h.push(function() {
            a3.componentDidUpdate(y4, d5, _3);
          });
        }
        if (a3.context = x5, a3.props = m4, a3.__P = n3, S3 = l.__r, $4 = 0, "prototype" in I3 && I3.prototype.render) {
          for (a3.state = a3.__s, a3.__d = false, S3 && S3(u3), s5 = a3.render(a3.props, a3.state, a3.context), A4 = 0; A4 < a3._sb.length; A4++)
            a3.__h.push(a3._sb[A4]);
          a3._sb = [];
        } else
          do {
            a3.__d = false, S3 && S3(u3), s5 = a3.render(a3.props, a3.state, a3.context), a3.state = a3.__s;
          } while (a3.__d && ++$4 < 25);
        a3.state = a3.__s, null != a3.getChildContext && (t3 = h(h({}, t3), a3.getChildContext())), p5 || null == a3.getSnapshotBeforeUpdate || (_3 = a3.getSnapshotBeforeUpdate(y4, d5)), P(n3, v(H3 = null != s5 && s5.type === k && null == s5.key ? s5.props.children : s5) ? H3 : [H3], u3, i4, t3, o4, r5, f4, e3, c4), a3.base = u3.__e, u3.__h = null, a3.__h.length && f4.push(a3), g5 && (a3.__E = a3.__ = null), a3.__e = false;
      } else
        null == r5 && u3.__v === i4.__v ? (u3.__k = i4.__k, u3.__e = i4.__e) : u3.__e = N(i4.__e, u3, i4, t3, o4, r5, f4, c4);
    (s5 = l.diffed) && s5(u3);
  } catch (n4) {
    u3.__v = null, (c4 || null != r5) && (u3.__e = e3, u3.__h = !!c4, r5[r5.indexOf(e3)] = null), l.__e(n4, u3, i4);
  }
}
function M(n3, u3) {
  l.__c && l.__c(u3, n3), n3.some(function(u4) {
    try {
      n3 = u4.__h, u4.__h = [], n3.some(function(n4) {
        n4.call(u4);
      });
    } catch (n4) {
      l.__e(n4, u4.__v);
    }
  });
}
function N(l4, u3, i4, t3, o4, r5, f4, e3) {
  var s5, a3, h4, y4 = i4.props, d5 = u3.props, _3 = u3.type, k4 = 0;
  if ("svg" === _3 && (o4 = true), null != r5) {
    for (; k4 < r5.length; k4++)
      if ((s5 = r5[k4]) && "setAttribute" in s5 == !!_3 && (_3 ? s5.localName === _3 : 3 === s5.nodeType)) {
        l4 = s5, r5[k4] = null;
        break;
      }
  }
  if (null == l4) {
    if (null === _3)
      return document.createTextNode(d5);
    l4 = o4 ? document.createElementNS("http://www.w3.org/2000/svg", _3) : document.createElement(_3, d5.is && d5), r5 = null, e3 = false;
  }
  if (null === _3)
    y4 === d5 || e3 && l4.data === d5 || (l4.data = d5);
  else {
    if (r5 = r5 && n.call(l4.childNodes), a3 = (y4 = i4.props || c).dangerouslySetInnerHTML, h4 = d5.dangerouslySetInnerHTML, !e3) {
      if (null != r5)
        for (y4 = {}, k4 = 0; k4 < l4.attributes.length; k4++)
          y4[l4.attributes[k4].name] = l4.attributes[k4].value;
      (h4 || a3) && (h4 && (a3 && h4.__html == a3.__html || h4.__html === l4.innerHTML) || (l4.innerHTML = h4 && h4.__html || ""));
    }
    if (H(l4, d5, y4, o4, e3), h4)
      u3.__k = [];
    else if (P(l4, v(k4 = u3.props.children) ? k4 : [k4], u3, i4, t3, o4 && "foreignObject" !== _3, r5, f4, r5 ? r5[0] : i4.__k && g(i4, 0), e3), null != r5)
      for (k4 = r5.length; k4--; )
        null != r5[k4] && p(r5[k4]);
    e3 || ("value" in d5 && void 0 !== (k4 = d5.value) && (k4 !== l4.value || "progress" === _3 && !k4 || "option" === _3 && k4 !== y4.value) && T(l4, "value", k4, y4.value, false), "checked" in d5 && void 0 !== (k4 = d5.checked) && k4 !== l4.checked && T(l4, "checked", k4, y4.checked, false));
  }
  return l4;
}
function O(n3, u3, i4) {
  try {
    "function" == typeof n3 ? n3(u3) : n3.current = u3;
  } catch (n4) {
    l.__e(n4, i4);
  }
}
function q(n3, u3, i4) {
  var t3, o4;
  if (l.unmount && l.unmount(n3), (t3 = n3.ref) && (t3.current && t3.current !== n3.__e || O(t3, null, u3)), null != (t3 = n3.__c)) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n4) {
        l.__e(n4, u3);
      }
    t3.base = t3.__P = null, n3.__c = void 0;
  }
  if (t3 = n3.__k)
    for (o4 = 0; o4 < t3.length; o4++)
      t3[o4] && q(t3[o4], u3, i4 || "function" != typeof n3.type);
  i4 || null == n3.__e || p(n3.__e), n3.__ = n3.__e = n3.__d = void 0;
}
function B(n3, l4, u3) {
  return this.constructor(n3, u3);
}
function D(u3, i4, t3) {
  var o4, r5, f4;
  l.__ && l.__(u3, i4), r5 = (o4 = "function" == typeof t3) ? null : t3 && t3.__k || i4.__k, f4 = [], L(i4, u3 = (!o4 && t3 || i4).__k = y(k, null, [u3]), r5 || c, c, void 0 !== i4.ownerSVGElement, !o4 && t3 ? [t3] : r5 ? null : i4.firstChild ? n.call(i4.childNodes) : null, f4, !o4 && t3 ? t3 : r5 ? r5.__e : i4.firstChild, o4), M(f4, u3);
}
function E(n3, l4) {
  D(n3, l4, E);
}
function F(l4, u3, i4) {
  var t3, o4, r5, f4, e3 = h({}, l4.props);
  for (r5 in l4.type && l4.type.defaultProps && (f4 = l4.type.defaultProps), u3)
    "key" == r5 ? t3 = u3[r5] : "ref" == r5 ? o4 = u3[r5] : e3[r5] = void 0 === u3[r5] && void 0 !== f4 ? f4[r5] : u3[r5];
  return arguments.length > 2 && (e3.children = arguments.length > 3 ? n.call(arguments, 2) : i4), d(l4.type, e3, t3 || l4.key, o4 || l4.ref, null);
}
function G(n3, l4) {
  var u3 = { __c: l4 = "__cC" + e++, __: n3, Consumer: function(n4, l5) {
    return n4.children(l5);
  }, Provider: function(n4) {
    var u4, i4;
    return this.getChildContext || (u4 = [], (i4 = {})[l4] = this, this.getChildContext = function() {
      return i4;
    }, this.shouldComponentUpdate = function(n5) {
      this.props.value !== n5.value && u4.some(function(n6) {
        n6.__e = true, w(n6);
      });
    }, this.sub = function(n5) {
      u4.push(n5);
      var l5 = n5.componentWillUnmount;
      n5.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n5), 1), l5 && l5.call(n5);
      };
    }), n4.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
n = s.slice, l = { __e: function(n3, l4, u3, i4) {
  for (var t3, o4, r5; l4 = l4.__; )
    if ((t3 = l4.__c) && !t3.__)
      try {
        if ((o4 = t3.constructor) && null != o4.getDerivedStateFromError && (t3.setState(o4.getDerivedStateFromError(n3)), r5 = t3.__d), null != t3.componentDidCatch && (t3.componentDidCatch(n3, i4 || {}), r5 = t3.__d), r5)
          return t3.__E = t3;
      } catch (l5) {
        n3 = l5;
      }
  throw n3;
} }, u = 0, i = function(n3) {
  return null != n3 && void 0 === n3.constructor;
}, b.prototype.setState = function(n3, l4) {
  var u3;
  u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n3 && (n3 = n3(h({}, u3), this.props)), n3 && h(u3, n3), null != n3 && this.__v && (l4 && this._sb.push(l4), w(this));
}, b.prototype.forceUpdate = function(n3) {
  this.__v && (this.__e = true, n3 && this.__h.push(n3), w(this));
}, b.prototype.render = k, t = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function(n3, l4) {
  return n3.__v.__b - l4.__v.__b;
}, x.__r = 0, e = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var o2 = 0;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function d2(t3, u3) {
  l.__h && l.__h(r2, t3, o2 || u3), o2 = 0;
  var i4 = r2.__H || (r2.__H = { __: [], __h: [] });
  return t3 >= i4.__.length && i4.__.push({ __V: c2 }), i4.__[t3];
}
function h2(n3) {
  return o2 = 1, s2(B2, n3);
}
function s2(n3, u3, i4) {
  var o4 = d2(t2++, 2);
  if (o4.t = n3, !o4.__c && (o4.__ = [i4 ? i4(u3) : B2(void 0, u3), function(n4) {
    var t3 = o4.__N ? o4.__N[0] : o4.__[0], r5 = o4.t(t3, n4);
    t3 !== r5 && (o4.__N = [r5, o4.__[1]], o4.__c.setState({}));
  }], o4.__c = r2, !r2.u)) {
    var f4 = function(n4, t3, r5) {
      if (!o4.__c.__H)
        return true;
      var u4 = o4.__c.__H.__.filter(function(n5) {
        return n5.__c;
      });
      if (u4.every(function(n5) {
        return !n5.__N;
      }))
        return !c4 || c4.call(this, n4, t3, r5);
      var i5 = false;
      return u4.forEach(function(n5) {
        if (n5.__N) {
          var t4 = n5.__[0];
          n5.__ = n5.__N, n5.__N = void 0, t4 !== n5.__[0] && (i5 = true);
        }
      }), !(!i5 && o4.__c.props === n4) && (!c4 || c4.call(this, n4, t3, r5));
    };
    r2.u = true;
    var c4 = r2.shouldComponentUpdate, e3 = r2.componentWillUpdate;
    r2.componentWillUpdate = function(n4, t3, r5) {
      if (this.__e) {
        var u4 = c4;
        c4 = void 0, f4(n4, t3, r5), c4 = u4;
      }
      e3 && e3.call(this, n4, t3, r5);
    }, r2.shouldComponentUpdate = f4;
  }
  return o4.__N || o4.__;
}
function p2(u3, i4) {
  var o4 = d2(t2++, 3);
  !l.__s && z2(o4.__H, i4) && (o4.__ = u3, o4.i = i4, r2.__H.__h.push(o4));
}
function y2(u3, i4) {
  var o4 = d2(t2++, 4);
  !l.__s && z2(o4.__H, i4) && (o4.__ = u3, o4.i = i4, r2.__h.push(o4));
}
function _2(n3) {
  return o2 = 5, F2(function() {
    return { current: n3 };
  }, []);
}
function A2(n3, t3, r5) {
  o2 = 6, y2(function() {
    return "function" == typeof n3 ? (n3(t3()), function() {
      return n3(null);
    }) : n3 ? (n3.current = t3(), function() {
      return n3.current = null;
    }) : void 0;
  }, null == r5 ? r5 : r5.concat(n3));
}
function F2(n3, r5) {
  var u3 = d2(t2++, 7);
  return z2(u3.__H, r5) ? (u3.__V = n3(), u3.i = r5, u3.__h = n3, u3.__V) : u3.__;
}
function T2(n3, t3) {
  return o2 = 8, F2(function() {
    return n3;
  }, t3);
}
function q2(n3) {
  var u3 = r2.context[n3.__c], i4 = d2(t2++, 9);
  return i4.c = n3, u3 ? (null == i4.__ && (i4.__ = true, u3.sub(r2)), u3.props.value) : n3.__;
}
function x2(t3, r5) {
  l.useDebugValue && l.useDebugValue(r5 ? r5(t3) : t3);
}
function V() {
  var n3 = d2(t2++, 11);
  if (!n3.__) {
    for (var u3 = r2.__v; null !== u3 && !u3.__m && null !== u3.__; )
      u3 = u3.__;
    var i4 = u3.__m || (u3.__m = [0, 0]);
    n3.__ = "P" + i4[0] + "-" + i4[1]++;
  }
  return n3.__;
}
function b2() {
  for (var t3; t3 = f2.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
      } catch (r5) {
        t3.__H.__h = [], l.__e(r5, t3.__v);
      }
}
l.__b = function(n3) {
  r2 = null, e2 && e2(n3);
}, l.__r = function(n3) {
  a2 && a2(n3), t2 = 0;
  var i4 = (r2 = n3.__c).__H;
  i4 && (u2 === r2 ? (i4.__h = [], r2.__h = [], i4.__.forEach(function(n4) {
    n4.__N && (n4.__ = n4.__N), n4.__V = c2, n4.__N = n4.i = void 0;
  })) : (i4.__h.forEach(k2), i4.__h.forEach(w2), i4.__h = [], t2 = 0)), u2 = r2;
}, l.diffed = function(t3) {
  v2 && v2(t3);
  var o4 = t3.__c;
  o4 && o4.__H && (o4.__H.__h.length && (1 !== f2.push(o4) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o4.__H.__.forEach(function(n3) {
    n3.i && (n3.__H = n3.i), n3.__V !== c2 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t3, r5) {
  r5.some(function(t4) {
    try {
      t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n3) {
        return !n3.__ || w2(n3);
      });
    } catch (u3) {
      r5.some(function(n3) {
        n3.__h && (n3.__h = []);
      }), r5 = [], l.__e(u3, t4.__v);
    }
  }), l2 && l2(t3, r5);
}, l.unmount = function(t3) {
  m2 && m2(t3);
  var r5, u3 = t3.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n3) {
    try {
      k2(n3);
    } catch (n4) {
      r5 = n4;
    }
  }), u3.__H = void 0, r5 && l.__e(r5, u3.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n3) {
  var t3, r5 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n3);
  }, u3 = setTimeout(r5, 100);
  g2 && (t3 = requestAnimationFrame(r5));
}
function k2(n3) {
  var t3 = r2, u3 = n3.__c;
  "function" == typeof u3 && (n3.__c = void 0, u3()), r2 = t3;
}
function w2(n3) {
  var t3 = r2;
  n3.__c = n3.__(), r2 = t3;
}
function z2(n3, t3) {
  return !n3 || n3.length !== t3.length || t3.some(function(t4, r5) {
    return t4 !== n3[r5];
  });
}
function B2(n3, t3) {
  return "function" == typeof t3 ? t3(n3) : t3;
}

// node_modules/preact/compat/dist/compat.module.js
function g3(n3, t3) {
  for (var e3 in t3)
    n3[e3] = t3[e3];
  return n3;
}
function C2(n3, t3) {
  for (var e3 in n3)
    if ("__source" !== e3 && !(e3 in t3))
      return true;
  for (var r5 in t3)
    if ("__source" !== r5 && n3[r5] !== t3[r5])
      return true;
  return false;
}
function E2(n3, t3) {
  return n3 === t3 && (0 !== n3 || 1 / n3 == 1 / t3) || n3 != n3 && t3 != t3;
}
function w3(n3) {
  this.props = n3;
}
function x3(n3, e3) {
  function r5(n4) {
    var t3 = this.props.ref, r6 = t3 == n4.ref;
    return !r6 && t3 && (t3.call ? t3(null) : t3.current = null), e3 ? !e3(this.props, n4) || !r6 : C2(this.props, n4);
  }
  function u3(e4) {
    return this.shouldComponentUpdate = r5, y(n3, e4);
  }
  return u3.displayName = "Memo(" + (n3.displayName || n3.name) + ")", u3.prototype.isReactComponent = true, u3.__f = true, u3;
}
(w3.prototype = new b()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n3, t3) {
  return C2(this.props, n3) || C2(this.state, t3);
};
var R = l.__b;
l.__b = function(n3) {
  n3.type && n3.type.__f && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), R && R(n3);
};
var N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function k3(n3) {
  function t3(t4) {
    var e3 = g3({}, t4);
    return delete e3.ref, n3(e3, t4.ref || null);
  }
  return t3.$$typeof = N2, t3.render = t3, t3.prototype.isReactComponent = t3.__f = true, t3.displayName = "ForwardRef(" + (n3.displayName || n3.name) + ")", t3;
}
var A3 = function(n3, t3) {
  return null == n3 ? null : S(S(n3).map(t3));
};
var O2 = { map: A3, forEach: A3, count: function(n3) {
  return n3 ? S(n3).length : 0;
}, only: function(n3) {
  var t3 = S(n3);
  if (1 !== t3.length)
    throw "Children.only";
  return t3[0];
}, toArray: S };
var T3 = l.__e;
l.__e = function(n3, t3, e3, r5) {
  if (n3.then) {
    for (var u3, o4 = t3; o4 = o4.__; )
      if ((u3 = o4.__c) && u3.__c)
        return null == t3.__e && (t3.__e = e3.__e, t3.__k = e3.__k), u3.__c(n3, t3);
  }
  T3(n3, t3, e3, r5);
};
var I2 = l.unmount;
function L2(n3, t3, e3) {
  return n3 && (n3.__c && n3.__c.__H && (n3.__c.__H.__.forEach(function(n4) {
    "function" == typeof n4.__c && n4.__c();
  }), n3.__c.__H = null), null != (n3 = g3({}, n3)).__c && (n3.__c.__P === e3 && (n3.__c.__P = t3), n3.__c = null), n3.__k = n3.__k && n3.__k.map(function(n4) {
    return L2(n4, t3, e3);
  })), n3;
}
function U(n3, t3, e3) {
  return n3 && (n3.__v = null, n3.__k = n3.__k && n3.__k.map(function(n4) {
    return U(n4, t3, e3);
  }), n3.__c && n3.__c.__P === t3 && (n3.__e && e3.insertBefore(n3.__e, n3.__d), n3.__c.__e = true, n3.__c.__P = e3)), n3;
}
function D2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F3(n3) {
  var t3 = n3.__.__c;
  return t3 && t3.__a && t3.__a(n3);
}
function M2(n3) {
  var e3, r5, u3;
  function o4(o5) {
    if (e3 || (e3 = n3()).then(function(n4) {
      r5 = n4.default || n4;
    }, function(n4) {
      u3 = n4;
    }), u3)
      throw u3;
    if (!r5)
      throw e3;
    return y(r5, o5);
  }
  return o4.displayName = "Lazy", o4.__f = true, o4;
}
function V2() {
  this.u = null, this.o = null;
}
l.unmount = function(n3) {
  var t3 = n3.__c;
  t3 && t3.__R && t3.__R(), t3 && true === n3.__h && (n3.type = null), I2 && I2(n3);
}, (D2.prototype = new b()).__c = function(n3, t3) {
  var e3 = t3.__c, r5 = this;
  null == r5.t && (r5.t = []), r5.t.push(e3);
  var u3 = F3(r5.__v), o4 = false, i4 = function() {
    o4 || (o4 = true, e3.__R = null, u3 ? u3(l4) : l4());
  };
  e3.__R = i4;
  var l4 = function() {
    if (!--r5.__u) {
      if (r5.state.__a) {
        var n4 = r5.state.__a;
        r5.__v.__k[0] = U(n4, n4.__c.__P, n4.__c.__O);
      }
      var t4;
      for (r5.setState({ __a: r5.__b = null }); t4 = r5.t.pop(); )
        t4.forceUpdate();
    }
  }, c4 = true === t3.__h;
  r5.__u++ || c4 || r5.setState({ __a: r5.__b = r5.__v.__k[0] }), n3.then(i4, i4);
}, D2.prototype.componentWillUnmount = function() {
  this.t = [];
}, D2.prototype.render = function(n3, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r5 = document.createElement("div"), o4 = this.__v.__k[0].__c;
      this.__v.__k[0] = L2(this.__b, r5, o4.__O = o4.__P);
    }
    this.__b = null;
  }
  var i4 = e3.__a && y(k, null, n3.fallback);
  return i4 && (i4.__h = null), [y(k, null, e3.__a ? null : n3.children), i4];
};
var W = function(n3, t3, e3) {
  if (++e3[1] === e3[0] && n3.o.delete(t3), n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.o.size))
    for (e3 = n3.u; e3; ) {
      for (; e3.length > 3; )
        e3.pop()();
      if (e3[1] < e3[0])
        break;
      n3.u = e3 = e3[2];
    }
};
function P2(n3) {
  return this.getChildContext = function() {
    return n3.context;
  }, n3.children;
}
function j3(n3) {
  var e3 = this, r5 = n3.i;
  e3.componentWillUnmount = function() {
    D(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r5 && e3.componentWillUnmount(), n3.__v ? (e3.l || (e3.i = r5, e3.l = { nodeType: 1, parentNode: r5, childNodes: [], appendChild: function(n4) {
    this.childNodes.push(n4), e3.i.appendChild(n4);
  }, insertBefore: function(n4, t3) {
    this.childNodes.push(n4), e3.i.appendChild(n4);
  }, removeChild: function(n4) {
    this.childNodes.splice(this.childNodes.indexOf(n4) >>> 1, 1), e3.i.removeChild(n4);
  } }), D(y(P2, { context: e3.context }, n3.__v), e3.l)) : e3.l && e3.componentWillUnmount();
}
function z3(n3, e3) {
  var r5 = y(j3, { __v: n3, i: e3 });
  return r5.containerInfo = e3, r5;
}
(V2.prototype = new b()).__a = function(n3) {
  var t3 = this, e3 = F3(t3.__v), r5 = t3.o.get(n3);
  return r5[0]++, function(u3) {
    var o4 = function() {
      t3.props.revealOrder ? (r5.push(u3), W(t3, n3, r5)) : u3();
    };
    e3 ? e3(o4) : o4();
  };
}, V2.prototype.render = function(n3) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t3 = S(n3.children);
  n3.revealOrder && "b" === n3.revealOrder[0] && t3.reverse();
  for (var e3 = t3.length; e3--; )
    this.o.set(t3[e3], this.u = [1, 0, this.u]);
  return n3.children;
}, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
  var n3 = this;
  this.o.forEach(function(t3, e3) {
    W(n3, e3, t3);
  });
};
var B3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var H2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var Z = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
var Y = /[A-Z0-9]/g;
var $2 = "undefined" != typeof document;
var q3 = function(n3) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n3);
};
function G2(n3, t3, e3) {
  return null == t3.__k && (t3.textContent = ""), D(n3, t3), "function" == typeof e3 && e3(), n3 ? n3.__c : null;
}
function J(n3, t3, e3) {
  return E(n3, t3), "function" == typeof e3 && e3(), n3 ? n3.__c : null;
}
b.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
  Object.defineProperty(b.prototype, t3, { configurable: true, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n3) {
    Object.defineProperty(this, t3, { configurable: true, writable: true, value: n3 });
  } });
});
var K = l.event;
function Q() {
}
function X() {
  return this.cancelBubble;
}
function nn() {
  return this.defaultPrevented;
}
l.event = function(n3) {
  return K && (n3 = K(n3)), n3.persist = Q, n3.isPropagationStopped = X, n3.isDefaultPrevented = nn, n3.nativeEvent = n3;
};
var tn;
var en = { enumerable: false, configurable: true, get: function() {
  return this.class;
} };
var rn = l.vnode;
l.vnode = function(n3) {
  "string" == typeof n3.type && function(n4) {
    var t3 = n4.props, e3 = n4.type, u3 = {};
    for (var o4 in t3) {
      var i4 = t3[o4];
      if (!("value" === o4 && "defaultValue" in t3 && null == i4 || $2 && "children" === o4 && "noscript" === e3 || "class" === o4 || "className" === o4)) {
        var l4 = o4.toLowerCase();
        "defaultValue" === o4 && "value" in t3 && null == t3.value ? o4 = "value" : "download" === o4 && true === i4 ? i4 = "" : "ondoubleclick" === l4 ? o4 = "ondblclick" : "onchange" !== l4 || "input" !== e3 && "textarea" !== e3 || q3(t3.type) ? "onfocus" === l4 ? o4 = "onfocusin" : "onblur" === l4 ? o4 = "onfocusout" : Z.test(o4) ? o4 = l4 : -1 === e3.indexOf("-") && H2.test(o4) ? o4 = o4.replace(Y, "-$&").toLowerCase() : null === i4 && (i4 = void 0) : l4 = o4 = "oninput", "oninput" === l4 && u3[o4 = l4] && (o4 = "oninputCapture"), u3[o4] = i4;
      }
    }
    "select" == e3 && u3.multiple && Array.isArray(u3.value) && (u3.value = S(t3.children).forEach(function(n5) {
      n5.props.selected = -1 != u3.value.indexOf(n5.props.value);
    })), "select" == e3 && null != u3.defaultValue && (u3.value = S(t3.children).forEach(function(n5) {
      n5.props.selected = u3.multiple ? -1 != u3.defaultValue.indexOf(n5.props.value) : u3.defaultValue == n5.props.value;
    })), t3.class && !t3.className ? (u3.class = t3.class, Object.defineProperty(u3, "className", en)) : (t3.className && !t3.class || t3.class && t3.className) && (u3.class = u3.className = t3.className), n4.props = u3;
  }(n3), n3.$$typeof = B3, rn && rn(n3);
};
var un = l.__r;
l.__r = function(n3) {
  un && un(n3), tn = n3.__c;
};
var on = l.diffed;
l.diffed = function(n3) {
  on && on(n3);
  var t3 = n3.props, e3 = n3.__e;
  null != e3 && "textarea" === n3.type && "value" in t3 && t3.value !== e3.value && (e3.value = null == t3.value ? "" : t3.value), tn = null;
};
var ln = { ReactCurrentDispatcher: { current: { readContext: function(n3) {
  return tn.__n[n3.__c].props.value;
} } } };
function fn(n3) {
  return y.bind(null, n3);
}
function an(n3) {
  return !!n3 && n3.$$typeof === B3;
}
function sn(n3) {
  return an(n3) ? F.apply(null, arguments) : n3;
}
function hn(n3) {
  return !!n3.__k && (D(null, n3), true);
}
function vn(n3) {
  return n3 && (n3.base || 1 === n3.nodeType && n3) || null;
}
var dn = function(n3, t3) {
  return n3(t3);
};
var pn = function(n3, t3) {
  return n3(t3);
};
var mn = k;
function yn(n3) {
  n3();
}
function _n(n3) {
  return n3;
}
function bn() {
  return [false, yn];
}
var Sn = y2;
function gn(n3, t3) {
  var e3 = t3(), r5 = h2({ h: { __: e3, v: t3 } }), u3 = r5[0].h, o4 = r5[1];
  return y2(function() {
    u3.__ = e3, u3.v = t3, E2(u3.__, t3()) || o4({ h: u3 });
  }, [n3, e3, t3]), p2(function() {
    return E2(u3.__, u3.v()) || o4({ h: u3 }), n3(function() {
      E2(u3.__, u3.v()) || o4({ h: u3 });
    });
  }, [n3]), e3;
}
var Cn = { useState: h2, useId: V, useReducer: s2, useEffect: p2, useLayoutEffect: y2, useInsertionEffect: Sn, useTransition: bn, useDeferredValue: _n, useSyncExternalStore: gn, startTransition: yn, useRef: _2, useImperativeHandle: A2, useMemo: F2, useCallback: T2, useContext: q2, useDebugValue: x2, version: "17.0.2", Children: O2, render: G2, hydrate: J, unmountComponentAtNode: hn, createPortal: z3, createElement: y, createContext: G, createFactory: fn, cloneElement: sn, createRef: _, Fragment: k, isValidElement: an, findDOMNode: vn, Component: b, PureComponent: w3, memo: x3, forwardRef: k3, flushSync: pn, unstable_batchedUpdates: dn, StrictMode: mn, Suspense: D2, SuspenseList: V2, lazy: M2, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ln };

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/react-json-tree/lib/esm/objType.js
function objType(obj) {
  const type = Object.prototype.toString.call(obj).slice(8, -1);
  if (type === "Object" && typeof obj[Symbol.iterator] === "function") {
    return "Iterable";
  }
  if (type === "Custom" && obj.constructor !== Object && obj instanceof Object) {
    return "Object";
  }
  return type;
}

// node_modules/react-json-tree/lib/esm/JSONArrow.js
function JSONArrow(_ref3) {
  let {
    styling,
    arrowStyle = "single",
    expanded,
    nodeType,
    onClick
  } = _ref3;
  return /* @__PURE__ */ Cn.createElement("div", _extends({}, styling("arrowContainer", arrowStyle), {
    onClick
  }), /* @__PURE__ */ Cn.createElement("div", styling(["arrow", "arrowSign"], nodeType, expanded, arrowStyle), "\u25B6", arrowStyle === "double" && /* @__PURE__ */ Cn.createElement("div", styling(["arrowSign", "arrowSignInner"]), "\u25B6")));
}

// node_modules/react-json-tree/lib/esm/getCollectionEntries.js
function getLength(type, collection) {
  if (type === "Object") {
    return Object.keys(collection).length;
  } else if (type === "Array") {
    return collection.length;
  }
  return Infinity;
}
function isIterableMap(collection) {
  return typeof collection.set === "function";
}
function getEntries(type, collection, sortObjectKeys) {
  let from2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  let to = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Infinity;
  let res;
  if (type === "Object") {
    let keys = Object.getOwnPropertyNames(collection);
    if (sortObjectKeys) {
      keys.sort(sortObjectKeys === true ? void 0 : sortObjectKeys);
    }
    keys = keys.slice(from2, to + 1);
    res = {
      entries: keys.map((key) => ({
        key,
        value: collection[key]
      }))
    };
  } else if (type === "Array") {
    res = {
      entries: collection.slice(from2, to + 1).map((val, idx) => ({
        key: idx + from2,
        value: val
      }))
    };
  } else {
    let idx = 0;
    const entries = [];
    let done = true;
    const isMap = isIterableMap(collection);
    for (const item of collection) {
      if (idx > to) {
        done = false;
        break;
      }
      if (from2 <= idx) {
        if (isMap && Array.isArray(item)) {
          if (typeof item[0] === "string" || typeof item[0] === "number") {
            entries.push({
              key: item[0],
              value: item[1]
            });
          } else {
            entries.push({
              key: `[entry ${idx}]`,
              value: {
                "[key]": item[0],
                "[value]": item[1]
              }
            });
          }
        } else {
          entries.push({
            key: idx,
            value: item
          });
        }
      }
      idx++;
    }
    res = {
      hasMore: !done,
      entries
    };
  }
  return res;
}
function getRanges(from2, to, limit) {
  const ranges = [];
  while (to - from2 > limit * limit) {
    limit = limit * limit;
  }
  for (let i4 = from2; i4 <= to; i4 += limit) {
    ranges.push({
      from: i4,
      to: Math.min(to, i4 + limit - 1)
    });
  }
  return ranges;
}
function getCollectionEntries(type, collection, sortObjectKeys, limit) {
  let from2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  let to = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : Infinity;
  const getEntriesBound = getEntries.bind(null, type, collection, sortObjectKeys);
  if (!limit) {
    return getEntriesBound().entries;
  }
  const isSubset = to < Infinity;
  const length2 = Math.min(to - from2, getLength(type, collection));
  if (type !== "Iterable") {
    if (length2 <= limit || limit < 7) {
      return getEntriesBound(from2, to).entries;
    }
  } else {
    if (length2 <= limit && !isSubset) {
      return getEntriesBound(from2, to).entries;
    }
  }
  let limitedEntries;
  if (type === "Iterable") {
    const {
      hasMore,
      entries
    } = getEntriesBound(from2, from2 + limit - 1);
    limitedEntries = hasMore ? [...entries, ...getRanges(from2 + limit, from2 + 2 * limit - 1, limit)] : entries;
  } else {
    limitedEntries = isSubset ? getRanges(from2, to, limit) : [...getEntriesBound(0, limit - 5).entries, ...getRanges(limit - 4, length2 - 5, limit), ...getEntriesBound(length2 - 4, length2 - 1).entries];
  }
  return limitedEntries;
}

// node_modules/react-json-tree/lib/esm/ItemRange.js
function ItemRange(props) {
  const {
    styling,
    from: from2,
    to,
    renderChildNodes: renderChildNodes2,
    nodeType
  } = props;
  const [expanded, setExpanded] = h2(false);
  const handleClick = T2(() => {
    setExpanded(!expanded);
  }, [expanded]);
  return expanded ? /* @__PURE__ */ Cn.createElement("div", styling("itemRange", expanded), renderChildNodes2(props, from2, to)) : /* @__PURE__ */ Cn.createElement("div", _extends({}, styling("itemRange", expanded), {
    onClick: handleClick
  }), /* @__PURE__ */ Cn.createElement(JSONArrow, {
    nodeType,
    styling,
    expanded: false,
    onClick: handleClick,
    arrowStyle: "double"
  }), `${from2} ... ${to}`);
}

// node_modules/react-json-tree/lib/esm/JSONNestedNode.js
function isRange(rangeOrEntry) {
  return rangeOrEntry.to !== void 0;
}
function renderChildNodes(props, from2, to) {
  const {
    nodeType,
    data,
    collectionLimit,
    circularCache,
    keyPath,
    postprocessValue,
    sortObjectKeys
  } = props;
  const childNodes = [];
  getCollectionEntries(nodeType, data, sortObjectKeys, collectionLimit, from2, to).forEach((entry) => {
    if (isRange(entry)) {
      childNodes.push(/* @__PURE__ */ Cn.createElement(ItemRange, _extends({}, props, {
        key: `ItemRange--${entry.from}-${entry.to}`,
        from: entry.from,
        to: entry.to,
        renderChildNodes
      })));
    } else {
      const {
        key,
        value
      } = entry;
      const isCircular = circularCache.indexOf(value) !== -1;
      childNodes.push(/* @__PURE__ */ Cn.createElement(JSONNode, _extends({}, props, {
        postprocessValue,
        collectionLimit,
        key: `Node--${key}`,
        keyPath: [key, ...keyPath],
        value: postprocessValue(value),
        circularCache: [...circularCache, value],
        isCircular,
        hideRoot: false
      })));
    }
  });
  return childNodes;
}
function JSONNestedNode(props) {
  const {
    circularCache = [],
    collectionLimit,
    createItemString: createItemString4,
    data,
    expandable,
    getItemString,
    hideRoot,
    isCircular,
    keyPath,
    labelRenderer,
    level = 0,
    nodeType,
    nodeTypeIndicator,
    shouldExpandNodeInitially,
    styling
  } = props;
  const [expanded, setExpanded] = h2(
    // calculate individual node expansion if necessary
    isCircular ? false : shouldExpandNodeInitially(keyPath, data, level)
  );
  const handleClick = T2(() => {
    if (expandable)
      setExpanded(!expanded);
  }, [expandable, expanded]);
  const renderedChildren = expanded || hideRoot && level === 0 ? renderChildNodes({
    ...props,
    circularCache,
    level: level + 1
  }) : null;
  const itemType = /* @__PURE__ */ Cn.createElement("span", styling("nestedNodeItemType", expanded), nodeTypeIndicator);
  const renderedItemString = getItemString(nodeType, data, itemType, createItemString4(data, collectionLimit), keyPath);
  const stylingArgs = [keyPath, nodeType, expanded, expandable];
  return hideRoot ? /* @__PURE__ */ Cn.createElement("li", styling("rootNode", ...stylingArgs), /* @__PURE__ */ Cn.createElement("ul", styling("rootNodeChildren", ...stylingArgs), renderedChildren)) : /* @__PURE__ */ Cn.createElement("li", styling("nestedNode", ...stylingArgs), expandable && /* @__PURE__ */ Cn.createElement(JSONArrow, {
    styling,
    nodeType,
    expanded,
    onClick: handleClick
  }), /* @__PURE__ */ Cn.createElement("label", _extends({}, styling(["label", "nestedNodeLabel"], ...stylingArgs), {
    onClick: handleClick
  }), labelRenderer(...stylingArgs)), /* @__PURE__ */ Cn.createElement("span", _extends({}, styling("nestedNodeItemString", ...stylingArgs), {
    onClick: handleClick
  }), renderedItemString), /* @__PURE__ */ Cn.createElement("ul", styling("nestedNodeChildren", ...stylingArgs), renderedChildren));
}

// node_modules/react-json-tree/lib/esm/JSONObjectNode.js
function createItemString(data) {
  const len = Object.getOwnPropertyNames(data).length;
  return `${len} ${len !== 1 ? "keys" : "key"}`;
}
function JSONObjectNode(_ref3) {
  let {
    data,
    ...props
  } = _ref3;
  return /* @__PURE__ */ Cn.createElement(JSONNestedNode, _extends({}, props, {
    data,
    nodeType: "Object",
    nodeTypeIndicator: props.nodeType === "Error" ? "Error()" : "{}",
    createItemString,
    expandable: Object.getOwnPropertyNames(data).length > 0
  }));
}

// node_modules/react-json-tree/lib/esm/JSONArrayNode.js
function createItemString2(data) {
  return `${data.length} ${data.length !== 1 ? "items" : "item"}`;
}
function JSONArrayNode(_ref3) {
  let {
    data,
    ...props
  } = _ref3;
  return /* @__PURE__ */ Cn.createElement(JSONNestedNode, _extends({}, props, {
    data,
    nodeType: "Array",
    nodeTypeIndicator: "[]",
    createItemString: createItemString2,
    expandable: data.length > 0
  }));
}

// node_modules/react-json-tree/lib/esm/JSONIterableNode.js
function createItemString3(data, limit) {
  let count = 0;
  let hasMore = false;
  if (Number.isSafeInteger(data.size)) {
    count = data.size;
  } else {
    for (const entry of data) {
      if (limit && count + 1 > limit) {
        hasMore = true;
        break;
      }
      count += 1;
    }
  }
  return `${hasMore ? ">" : ""}${count} ${count !== 1 ? "entries" : "entry"}`;
}
function JSONIterableNode(props) {
  return /* @__PURE__ */ Cn.createElement(JSONNestedNode, _extends({}, props, {
    nodeType: "Iterable",
    nodeTypeIndicator: "()",
    createItemString: createItemString3,
    expandable: true
  }));
}

// node_modules/react-json-tree/lib/esm/JSONValueNode.js
function JSONValueNode(_ref3) {
  let {
    nodeType,
    styling,
    labelRenderer,
    keyPath,
    valueRenderer,
    value,
    valueGetter = (value2) => value2
  } = _ref3;
  return /* @__PURE__ */ Cn.createElement("li", styling("value", nodeType, keyPath), /* @__PURE__ */ Cn.createElement("label", styling(["label", "valueLabel"], nodeType, keyPath), labelRenderer(keyPath, nodeType, false, false)), /* @__PURE__ */ Cn.createElement("span", styling("valueText", nodeType, keyPath), valueRenderer(valueGetter(value), value, ...keyPath)));
}

// node_modules/react-json-tree/lib/esm/JSONNode.js
function JSONNode(_ref3) {
  let {
    getItemString,
    keyPath,
    labelRenderer,
    styling,
    value,
    valueRenderer,
    isCustomNode,
    ...rest
  } = _ref3;
  const nodeType = isCustomNode(value) ? "Custom" : objType(value);
  const simpleNodeProps = {
    getItemString,
    key: keyPath[0],
    keyPath,
    labelRenderer,
    nodeType,
    styling,
    value,
    valueRenderer
  };
  const nestedNodeProps = {
    ...rest,
    ...simpleNodeProps,
    data: value,
    isCustomNode
  };
  switch (nodeType) {
    case "Object":
    case "Error":
    case "WeakMap":
    case "WeakSet":
      return /* @__PURE__ */ Cn.createElement(JSONObjectNode, nestedNodeProps);
    case "Array":
      return /* @__PURE__ */ Cn.createElement(JSONArrayNode, nestedNodeProps);
    case "Iterable":
    case "Map":
    case "Set":
      return /* @__PURE__ */ Cn.createElement(JSONIterableNode, nestedNodeProps);
    case "String":
      return /* @__PURE__ */ Cn.createElement(JSONValueNode, _extends({}, simpleNodeProps, {
        valueGetter: (raw) => `"${raw}"`
      }));
    case "Number":
      return /* @__PURE__ */ Cn.createElement(JSONValueNode, simpleNodeProps);
    case "Boolean":
      return /* @__PURE__ */ Cn.createElement(JSONValueNode, _extends({}, simpleNodeProps, {
        valueGetter: (raw) => raw ? "true" : "false"
      }));
    case "Date":
      return /* @__PURE__ */ Cn.createElement(JSONValueNode, _extends({}, simpleNodeProps, {
        valueGetter: (raw) => raw.toISOString()
      }));
    case "Null":
      return /* @__PURE__ */ Cn.createElement(JSONValueNode, _extends({}, simpleNodeProps, {
        valueGetter: () => "null"
      }));
    case "Undefined":
      return /* @__PURE__ */ Cn.createElement(JSONValueNode, _extends({}, simpleNodeProps, {
        valueGetter: () => "undefined"
      }));
    case "Function":
    case "Symbol":
      return /* @__PURE__ */ Cn.createElement(JSONValueNode, _extends({}, simpleNodeProps, {
        valueGetter: (raw) => raw.toString()
      }));
    case "Custom":
      return /* @__PURE__ */ Cn.createElement(JSONValueNode, simpleNodeProps);
    default:
      return /* @__PURE__ */ Cn.createElement(JSONValueNode, _extends({}, simpleNodeProps, {
        valueGetter: () => `<${nodeType}>`
      }));
  }
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i4) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i4) {
        if (Object(_i) !== _i)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i4); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n2 && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++)
    arr2[i4] = arr[i4];
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o4, minLen) {
  if (!o4)
    return;
  if (typeof o4 === "string")
    return _arrayLikeToArray(o4, minLen);
  var n3 = Object.prototype.toString.call(o4).slice(8, -1);
  if (n3 === "Object" && o4.constructor)
    n3 = o4.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o4);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray(o4, minLen);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i4) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i4) || _unsupportedIterableToArray(arr, i4) || _nonIterableRest();
}

// node_modules/react-base16-styling/lib/esm/index.js
var base16 = __toESM(require_lib());
var import_color = __toESM(require_color());
var import_lodash = __toESM(require_lodash());

// node_modules/react-base16-styling/lib/esm/colorConverters.js
function yuv2rgb(yuv) {
  var y4 = yuv[0], u3 = yuv[1], v4 = yuv[2];
  var r5, g5, b4;
  r5 = y4 * 1 + u3 * 0 + v4 * 1.13983;
  g5 = y4 * 1 + u3 * -0.39465 + v4 * -0.5806;
  b4 = y4 * 1 + u3 * 2.02311 + v4 * 0;
  r5 = Math.min(Math.max(0, r5), 1);
  g5 = Math.min(Math.max(0, g5), 1);
  b4 = Math.min(Math.max(0, b4), 1);
  return [r5 * 255, g5 * 255, b4 * 255];
}
function rgb2yuv(rgb) {
  var r5 = rgb[0] / 255, g5 = rgb[1] / 255, b4 = rgb[2] / 255;
  var y4 = r5 * 0.299 + g5 * 0.587 + b4 * 0.114;
  var u3 = r5 * -0.14713 + g5 * -0.28886 + b4 * 0.436;
  var v4 = r5 * 0.615 + g5 * -0.51499 + b4 * -0.10001;
  return [y4, u3, v4];
}

// node_modules/react-base16-styling/lib/esm/index.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var DEFAULT_BASE16 = base16.default;
var BASE16_KEYS = Object.keys(DEFAULT_BASE16);
var flip = function flip2(x5) {
  return x5 < 0.25 ? 1 : x5 < 0.5 ? 0.9 - x5 : 1.1 - x5;
};
var invertColor = function invertColor2(hexString) {
  var color = (0, import_color.default)(hexString);
  var _rgb2yuv = rgb2yuv(color.array()), _rgb2yuv2 = _slicedToArray(_rgb2yuv, 3), y4 = _rgb2yuv2[0], u3 = _rgb2yuv2[1], v4 = _rgb2yuv2[2];
  var flippedYuv = [flip(y4), u3, v4];
  var rgb = yuv2rgb(flippedYuv);
  return import_color.default.rgb(rgb).hex();
};
var merger = function merger2(styling) {
  return function(prevStyling) {
    return {
      className: [prevStyling.className, styling.className].filter(Boolean).join(" "),
      style: _objectSpread(_objectSpread({}, prevStyling.style || {}), styling.style || {})
    };
  };
};
var mergeStyling = function mergeStyling2(customStyling, defaultStyling) {
  if (customStyling === void 0) {
    return defaultStyling;
  }
  if (defaultStyling === void 0) {
    return customStyling;
  }
  var customType = _typeof(customStyling);
  var defaultType = _typeof(defaultStyling);
  switch (customType) {
    case "string":
      switch (defaultType) {
        case "string":
          return [defaultStyling, customStyling].filter(Boolean).join(" ");
        case "object":
          return merger({
            className: customStyling,
            style: defaultStyling
          });
        case "function":
          return function(styling) {
            for (var _len = arguments.length, args2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args2[_key - 1] = arguments[_key];
            }
            return merger({
              className: customStyling
            })(defaultStyling.apply(void 0, [styling].concat(args2)));
          };
      }
      break;
    case "object":
      switch (defaultType) {
        case "string":
          return merger({
            className: defaultStyling,
            style: customStyling
          });
        case "object":
          return _objectSpread(_objectSpread({}, defaultStyling), customStyling);
        case "function":
          return function(styling) {
            for (var _len2 = arguments.length, args2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args2[_key2 - 1] = arguments[_key2];
            }
            return merger({
              style: customStyling
            })(defaultStyling.apply(void 0, [styling].concat(args2)));
          };
      }
      break;
    case "function":
      switch (defaultType) {
        case "string":
          return function(styling) {
            for (var _len3 = arguments.length, args2 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args2[_key3 - 1] = arguments[_key3];
            }
            return customStyling.apply(void 0, [merger(styling)({
              className: defaultStyling
            })].concat(args2));
          };
        case "object":
          return function(styling) {
            for (var _len4 = arguments.length, args2 = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
              args2[_key4 - 1] = arguments[_key4];
            }
            return customStyling.apply(void 0, [merger(styling)({
              style: defaultStyling
            })].concat(args2));
          };
        case "function":
          return function(styling) {
            for (var _len5 = arguments.length, args2 = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
              args2[_key5 - 1] = arguments[_key5];
            }
            return customStyling.apply(void 0, [defaultStyling.apply(void 0, [styling].concat(args2))].concat(args2));
          };
      }
  }
};
var mergeStylings = function mergeStylings2(customStylings, defaultStylings) {
  var keys = Object.keys(defaultStylings);
  for (var key in customStylings) {
    if (keys.indexOf(key) === -1)
      keys.push(key);
  }
  return keys.reduce(function(mergedStyling, key2) {
    return mergedStyling[key2] = mergeStyling(customStylings[key2], defaultStylings[key2]), mergedStyling;
  }, {});
};
var getStylingByKeys = function getStylingByKeys2(mergedStyling, keys) {
  for (var _len6 = arguments.length, args2 = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
    args2[_key6 - 2] = arguments[_key6];
  }
  if (keys === null) {
    return mergedStyling;
  }
  if (!Array.isArray(keys)) {
    keys = [keys];
  }
  var styles = keys.map(function(key) {
    return mergedStyling[key];
  }).filter(Boolean);
  var props = styles.reduce(function(obj, s5) {
    if (typeof s5 === "string") {
      obj.className = [obj.className, s5].filter(Boolean).join(" ");
    } else if (_typeof(s5) === "object") {
      obj.style = _objectSpread(_objectSpread({}, obj.style), s5);
    } else if (typeof s5 === "function") {
      obj = _objectSpread(_objectSpread({}, obj), s5.apply(void 0, [obj].concat(args2)));
    }
    return obj;
  }, {
    className: "",
    style: {}
  });
  if (!props.className) {
    delete props.className;
  }
  if (Object.keys(props.style).length === 0) {
    delete props.style;
  }
  return props;
};
var invertBase16Theme = function invertBase16Theme2(base16Theme) {
  return Object.keys(base16Theme).reduce(function(t3, key) {
    return t3[key] = /^base/.test(key) ? invertColor(base16Theme[key]) : key === "scheme" ? base16Theme[key] + ":inverted" : base16Theme[key], t3;
  }, {});
};
var createStyling = (0, import_lodash.default)(function(getStylingFromBase16) {
  var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var themeOrStyling = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _options$defaultBase = options3.defaultBase16, defaultBase16 = _options$defaultBase === void 0 ? DEFAULT_BASE16 : _options$defaultBase, _options$base16Themes = options3.base16Themes, base16Themes = _options$base16Themes === void 0 ? null : _options$base16Themes;
  var base16Theme = getBase16Theme(themeOrStyling, base16Themes);
  if (base16Theme) {
    themeOrStyling = _objectSpread(_objectSpread({}, base16Theme), themeOrStyling);
  }
  var theme = BASE16_KEYS.reduce(function(t3, key) {
    return t3[key] = themeOrStyling[key] || defaultBase16[key], t3;
  }, {});
  var customStyling = Object.keys(themeOrStyling).reduce(function(s5, key) {
    return BASE16_KEYS.indexOf(key) === -1 ? (s5[key] = themeOrStyling[key], s5) : s5;
  }, {});
  var defaultStyling = getStylingFromBase16(theme);
  var mergedStyling = mergeStylings(customStyling, defaultStyling);
  for (var _len7 = arguments.length, args2 = new Array(_len7 > 3 ? _len7 - 3 : 0), _key7 = 3; _key7 < _len7; _key7++) {
    args2[_key7 - 3] = arguments[_key7];
  }
  return (0, import_lodash.default)(getStylingByKeys, 2).apply(void 0, [mergedStyling].concat(args2));
}, 3);
var isStylingConfig = function isStylingConfig2(theme) {
  return !!theme.extend;
};
var getBase16Theme = function getBase16Theme2(theme, base16Themes) {
  if (theme && isStylingConfig(theme) && theme.extend) {
    theme = theme.extend;
  }
  if (typeof theme === "string") {
    var _theme$split = theme.split(":"), _theme$split2 = _slicedToArray(_theme$split, 2), _themeName = _theme$split2[0], modifier = _theme$split2[1];
    if (base16Themes) {
      theme = base16Themes[_themeName];
    } else {
      theme = base16[_themeName];
    }
    if (modifier === "inverted") {
      theme = invertBase16Theme(theme);
    }
  }
  return theme && Object.prototype.hasOwnProperty.call(theme, "base00") ? theme : void 0;
};
var invertTheme = function invertTheme2(theme) {
  if (typeof theme === "string") {
    return "".concat(theme, ":inverted");
  }
  if (theme && isStylingConfig(theme) && theme.extend) {
    if (typeof theme.extend === "string") {
      return _objectSpread(_objectSpread({}, theme), {}, {
        extend: "".concat(theme.extend, ":inverted")
      });
    }
    return _objectSpread(_objectSpread({}, theme), {}, {
      extend: invertBase16Theme(theme.extend)
    });
  }
  if (theme) {
    return invertBase16Theme(theme);
  }
  return theme;
};

// node_modules/react-json-tree/lib/esm/themes/solarized.js
var solarized_default = {
  scheme: "solarized",
  author: "ethan schoonover (http://ethanschoonover.com/solarized)",
  base00: "#002b36",
  base01: "#073642",
  base02: "#586e75",
  base03: "#657b83",
  base04: "#839496",
  base05: "#93a1a1",
  base06: "#eee8d5",
  base07: "#fdf6e3",
  base08: "#dc322f",
  base09: "#cb4b16",
  base0A: "#b58900",
  base0B: "#859900",
  base0C: "#2aa198",
  base0D: "#268bd2",
  base0E: "#6c71c4",
  base0F: "#d33682"
};

// node_modules/react-json-tree/lib/esm/createStylingFromTheme.js
var colorMap = (theme) => ({
  BACKGROUND_COLOR: theme.base00,
  TEXT_COLOR: theme.base07,
  STRING_COLOR: theme.base0B,
  DATE_COLOR: theme.base0B,
  NUMBER_COLOR: theme.base09,
  BOOLEAN_COLOR: theme.base09,
  NULL_COLOR: theme.base08,
  UNDEFINED_COLOR: theme.base08,
  FUNCTION_COLOR: theme.base08,
  SYMBOL_COLOR: theme.base08,
  LABEL_COLOR: theme.base0D,
  ARROW_COLOR: theme.base0D,
  ITEM_STRING_COLOR: theme.base0B,
  ITEM_STRING_EXPANDED_COLOR: theme.base03
});
var valueColorMap = (colors2) => ({
  String: colors2.STRING_COLOR,
  Date: colors2.DATE_COLOR,
  Number: colors2.NUMBER_COLOR,
  Boolean: colors2.BOOLEAN_COLOR,
  Null: colors2.NULL_COLOR,
  Undefined: colors2.UNDEFINED_COLOR,
  Function: colors2.FUNCTION_COLOR,
  Symbol: colors2.SYMBOL_COLOR
});
var getDefaultThemeStyling = (theme) => {
  const colors2 = colorMap(theme);
  return {
    tree: {
      border: 0,
      padding: 0,
      marginTop: "0.5em",
      marginBottom: "0.5em",
      marginLeft: "0.125em",
      marginRight: 0,
      listStyle: "none",
      MozUserSelect: "none",
      WebkitUserSelect: "none",
      backgroundColor: colors2.BACKGROUND_COLOR
    },
    value: (_ref3, nodeType, keyPath) => {
      let {
        style
      } = _ref3;
      return {
        style: {
          ...style,
          paddingTop: "0.25em",
          paddingRight: 0,
          marginLeft: "0.875em",
          WebkitUserSelect: "text",
          MozUserSelect: "text",
          wordWrap: "break-word",
          paddingLeft: keyPath.length > 1 ? "2.125em" : "1.25em",
          textIndent: "-0.5em",
          wordBreak: "break-all"
        }
      };
    },
    label: {
      display: "inline-block",
      color: colors2.LABEL_COLOR
    },
    valueLabel: {
      margin: "0 0.5em 0 0"
    },
    valueText: (_ref23, nodeType) => {
      let {
        style
      } = _ref23;
      return {
        style: {
          ...style,
          color: valueColorMap(colors2)[nodeType]
        }
      };
    },
    itemRange: (styling, expanded) => ({
      style: {
        paddingTop: expanded ? 0 : "0.25em",
        cursor: "pointer",
        color: colors2.LABEL_COLOR
      }
    }),
    arrow: (_ref3, nodeType, expanded) => {
      let {
        style
      } = _ref3;
      return {
        style: {
          ...style,
          marginLeft: 0,
          transition: "150ms",
          WebkitTransition: "150ms",
          MozTransition: "150ms",
          WebkitTransform: expanded ? "rotateZ(90deg)" : "rotateZ(0deg)",
          MozTransform: expanded ? "rotateZ(90deg)" : "rotateZ(0deg)",
          transform: expanded ? "rotateZ(90deg)" : "rotateZ(0deg)",
          transformOrigin: "45% 50%",
          WebkitTransformOrigin: "45% 50%",
          MozTransformOrigin: "45% 50%",
          position: "relative",
          lineHeight: "1.1em",
          fontSize: "0.75em"
        }
      };
    },
    arrowContainer: (_ref4, arrowStyle) => {
      let {
        style
      } = _ref4;
      return {
        style: {
          ...style,
          display: "inline-block",
          paddingRight: "0.5em",
          paddingLeft: arrowStyle === "double" ? "1em" : 0,
          cursor: "pointer"
        }
      };
    },
    arrowSign: {
      color: colors2.ARROW_COLOR
    },
    arrowSignInner: {
      position: "absolute",
      top: 0,
      left: "-0.4em"
    },
    nestedNode: (_ref5, keyPath, nodeType, expanded, expandable) => {
      let {
        style
      } = _ref5;
      return {
        style: {
          ...style,
          position: "relative",
          paddingTop: "0.25em",
          marginLeft: keyPath.length > 1 ? "0.875em" : 0,
          paddingLeft: !expandable ? "1.125em" : 0
        }
      };
    },
    rootNode: {
      padding: 0,
      margin: 0
    },
    nestedNodeLabel: (_ref6, keyPath, nodeType, expanded, expandable) => {
      let {
        style
      } = _ref6;
      return {
        style: {
          ...style,
          margin: 0,
          padding: 0,
          WebkitUserSelect: expandable ? "inherit" : "text",
          MozUserSelect: expandable ? "inherit" : "text",
          cursor: expandable ? "pointer" : "default"
        }
      };
    },
    nestedNodeItemString: (_ref7, keyPath, nodeType, expanded) => {
      let {
        style
      } = _ref7;
      return {
        style: {
          ...style,
          paddingLeft: "0.5em",
          cursor: "default",
          color: expanded ? colors2.ITEM_STRING_EXPANDED_COLOR : colors2.ITEM_STRING_COLOR
        }
      };
    },
    nestedNodeItemType: {
      marginLeft: "0.3em",
      marginRight: "0.3em"
    },
    nestedNodeChildren: (_ref8, nodeType, expanded) => {
      let {
        style
      } = _ref8;
      return {
        style: {
          ...style,
          padding: 0,
          margin: 0,
          listStyle: "none",
          display: expanded ? "block" : "none"
        }
      };
    },
    rootNodeChildren: {
      padding: 0,
      margin: 0,
      listStyle: "none"
    }
  };
};
var createStylingFromTheme = createStyling(getDefaultThemeStyling, {
  defaultBase16: solarized_default
});
var createStylingFromTheme_default = createStylingFromTheme;

// node_modules/react-json-tree/lib/esm/index.js
var identity = (value) => value;
var expandRootNode = (keyPath, data, level) => level === 0;
var defaultItemString = (type, data, itemType, itemString) => /* @__PURE__ */ Cn.createElement("span", null, itemType, " ", itemString);
var defaultLabelRenderer = (_ref3) => {
  let [label] = _ref3;
  return /* @__PURE__ */ Cn.createElement("span", null, label, ":");
};
var noCustomNode = () => false;
function JSONTree(_ref23) {
  let {
    data: value,
    theme,
    invertTheme: shouldInvertTheme,
    keyPath = ["root"],
    labelRenderer = defaultLabelRenderer,
    valueRenderer = identity,
    shouldExpandNodeInitially = expandRootNode,
    hideRoot = false,
    getItemString = defaultItemString,
    postprocessValue = identity,
    isCustomNode = noCustomNode,
    collectionLimit = 50,
    sortObjectKeys = false
  } = _ref23;
  const styling = F2(() => createStylingFromTheme_default(shouldInvertTheme ? invertTheme(theme) : theme), [theme, shouldInvertTheme]);
  return /* @__PURE__ */ Cn.createElement("ul", styling("tree"), /* @__PURE__ */ Cn.createElement(JSONNode, {
    keyPath: hideRoot ? [] : keyPath,
    value: postprocessValue(value),
    isCustomNode,
    styling,
    labelRenderer,
    valueRenderer,
    shouldExpandNodeInitially,
    hideRoot,
    getItemString,
    postprocessValue,
    collectionLimit,
    sortObjectKeys
  }));
}

// src/bbt/export.ts
var import_fs3 = require("fs");
var import_obsidian10 = require("obsidian");
var import_path5 = __toESM(require("path"));

// node_modules/execa/index.js
var import_node_buffer2 = require("node:buffer");
var import_node_path2 = __toESM(require("node:path"), 1);
var import_node_child_process3 = __toESM(require("node:child_process"), 1);
var import_node_process5 = __toESM(require("node:process"), 1);
var import_cross_spawn = __toESM(require_cross_spawn(), 1);

// node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
  const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
  if (input[input.length - 1] === LF) {
    input = input.slice(0, -1);
  }
  if (input[input.length - 1] === CR) {
    input = input.slice(0, -1);
  }
  return input;
}

// node_modules/npm-run-path/index.js
var import_node_process3 = __toESM(require("node:process"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var import_node_url = __toESM(require("node:url"), 1);

// node_modules/npm-run-path/node_modules/path-key/index.js
function pathKey(options3 = {}) {
  const {
    env: env2 = process.env,
    platform = process.platform
  } = options3;
  if (platform !== "win32") {
    return "PATH";
  }
  return Object.keys(env2).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}

// node_modules/npm-run-path/index.js
function npmRunPath(options3 = {}) {
  const {
    cwd = import_node_process3.default.cwd(),
    path: path_ = import_node_process3.default.env[pathKey()],
    execPath = import_node_process3.default.execPath
  } = options3;
  let previous;
  const cwdString = cwd instanceof URL ? import_node_url.default.fileURLToPath(cwd) : cwd;
  let cwdPath = import_node_path.default.resolve(cwdString);
  const result = [];
  while (previous !== cwdPath) {
    result.push(import_node_path.default.join(cwdPath, "node_modules/.bin"));
    previous = cwdPath;
    cwdPath = import_node_path.default.resolve(cwdPath, "..");
  }
  result.push(import_node_path.default.resolve(cwdString, execPath, ".."));
  return [...result, path_].join(import_node_path.default.delimiter);
}
function npmRunPathEnv({ env: env2 = import_node_process3.default.env, ...options3 } = {}) {
  env2 = { ...env2 };
  const path8 = pathKey({ env: env2 });
  options3.path = env2[path8];
  env2[path8] = npmRunPath(options3);
  return env2;
}

// node_modules/onetime/node_modules/mimic-fn/index.js
var copyProperty = (to, from2, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from2, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
var canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
var changePrototype = (to, from2) => {
  const fromPrototype = Object.getPrototypeOf(from2);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
var changeToString = (to, from2, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from2.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
function mimicFunction(to, from2, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from2)) {
    copyProperty(to, from2, property, ignoreNonConfigurable);
  }
  changePrototype(to, from2);
  changeToString(to, from2, name);
  return to;
}

// node_modules/onetime/index.js
var calledFunctions = /* @__PURE__ */ new WeakMap();
var onetime = (function_, options3 = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options3.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFunction(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetime_default = onetime;

// node_modules/human-signals/build/src/main.js
var import_node_os3 = require("node:os");

// node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals = () => {
  const length2 = SIGRTMAX - SIGRTMIN + 1;
  return Array.from({ length: length2 }, getRealtimeSignal);
};
var getRealtimeSignal = (value, index2) => ({
  name: `SIGRT${index2 + 1}`,
  number: SIGRTMIN + index2,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
});
var SIGRTMIN = 34;
var SIGRTMAX = 64;

// node_modules/human-signals/build/src/signals.js
var import_node_os2 = require("node:os");

// node_modules/human-signals/build/src/core.js
var SIGNALS = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// node_modules/human-signals/build/src/signals.js
var getSignals = () => {
  const realtimeSignals = getRealtimeSignals();
  const signals = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
  return signals;
};
var normalizeSignal = ({
  name,
  number: defaultNumber,
  description,
  action,
  forced = false,
  standard
}) => {
  const {
    signals: { [name]: constantSignal }
  } = import_node_os2.constants;
  const supported = constantSignal !== void 0;
  const number = supported ? constantSignal : defaultNumber;
  return { name, number, description, supported, action, forced, standard };
};

// node_modules/human-signals/build/src/main.js
var getSignalsByName = () => {
  const signals = getSignals();
  return Object.fromEntries(signals.map(getSignalByName));
};
var getSignalByName = ({
  name,
  number,
  description,
  supported,
  action,
  forced,
  standard
}) => [name, { name, number, description, supported, action, forced, standard }];
var signalsByName = getSignalsByName();
var getSignalsByNumber = () => {
  const signals = getSignals();
  const length2 = SIGRTMAX + 1;
  const signalsA = Array.from({ length: length2 }, (value, number) => getSignalByNumber(number, signals));
  return Object.assign({}, ...signalsA);
};
var getSignalByNumber = (number, signals) => {
  const signal = findSignalByNumber(number, signals);
  if (signal === void 0) {
    return {};
  }
  const { name, description, supported, action, forced, standard } = signal;
  return {
    [number]: {
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }
  };
};
var findSignalByNumber = (number, signals) => {
  const signal = signals.find(({ name }) => import_node_os3.constants.signals[name] === number);
  if (signal !== void 0) {
    return signal;
  }
  return signals.find((signalA) => signalA.number === number);
};
var signalsByNumber = getSignalsByNumber();

// node_modules/execa/lib/error.js
var getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
  if (timedOut) {
    return `timed out after ${timeout} milliseconds`;
  }
  if (isCanceled) {
    return "was canceled";
  }
  if (errorCode !== void 0) {
    return `failed with ${errorCode}`;
  }
  if (signal !== void 0) {
    return `was killed with ${signal} (${signalDescription})`;
  }
  if (exitCode !== void 0) {
    return `failed with exit code ${exitCode}`;
  }
  return "failed";
};
var makeError = ({
  stdout,
  stderr,
  all,
  error,
  signal,
  exitCode,
  command,
  escapedCommand,
  timedOut,
  isCanceled,
  killed,
  parsed: { options: { timeout } }
}) => {
  exitCode = exitCode === null ? void 0 : exitCode;
  signal = signal === null ? void 0 : signal;
  const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
  const errorCode = error && error.code;
  const prefix2 = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
  const execaMessage = `Command ${prefix2}: ${command}`;
  const isError = Object.prototype.toString.call(error) === "[object Error]";
  const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
  const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
  if (isError) {
    error.originalMessage = error.message;
    error.message = message;
  } else {
    error = new Error(message);
  }
  error.shortMessage = shortMessage;
  error.command = command;
  error.escapedCommand = escapedCommand;
  error.exitCode = exitCode;
  error.signal = signal;
  error.signalDescription = signalDescription;
  error.stdout = stdout;
  error.stderr = stderr;
  if (all !== void 0) {
    error.all = all;
  }
  if ("bufferedData" in error) {
    delete error.bufferedData;
  }
  error.failed = true;
  error.timedOut = Boolean(timedOut);
  error.isCanceled = isCanceled;
  error.killed = killed && !timedOut;
  return error;
};

// node_modules/execa/lib/stdio.js
var aliases = ["stdin", "stdout", "stderr"];
var hasAlias = (options3) => aliases.some((alias) => options3[alias] !== void 0);
var normalizeStdio = (options3) => {
  if (!options3) {
    return;
  }
  const { stdio } = options3;
  if (stdio === void 0) {
    return aliases.map((alias) => options3[alias]);
  }
  if (hasAlias(options3)) {
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
  }
  if (typeof stdio === "string") {
    return stdio;
  }
  if (!Array.isArray(stdio)) {
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
  }
  const length2 = Math.max(stdio.length, aliases.length);
  return Array.from({ length: length2 }, (value, index2) => stdio[index2]);
};

// node_modules/execa/lib/kill.js
var import_node_os4 = __toESM(require("node:os"), 1);
var import_signal_exit = __toESM(require_signal_exit(), 1);
var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
var spawnedKill = (kill, signal = "SIGTERM", options3 = {}) => {
  const killResult = kill(signal);
  setKillTimeout(kill, signal, options3, killResult);
  return killResult;
};
var setKillTimeout = (kill, signal, options3, killResult) => {
  if (!shouldForceKill(signal, options3, killResult)) {
    return;
  }
  const timeout = getForceKillAfterTimeout(options3);
  const t3 = setTimeout(() => {
    kill("SIGKILL");
  }, timeout);
  if (t3.unref) {
    t3.unref();
  }
};
var shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
var isSigterm = (signal) => signal === import_node_os4.default.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
var getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {
  if (forceKillAfterTimeout === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }
  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
    throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
  }
  return forceKillAfterTimeout;
};
var spawnedCancel = (spawned, context) => {
  const killResult = spawned.kill();
  if (killResult) {
    context.isCanceled = true;
  }
};
var timeoutKill = (spawned, signal, reject2) => {
  spawned.kill(signal);
  reject2(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
};
var setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
  if (timeout === 0 || timeout === void 0) {
    return spawnedPromise;
  }
  let timeoutId;
  const timeoutPromise = new Promise((resolve2, reject2) => {
    timeoutId = setTimeout(() => {
      timeoutKill(spawned, killSignal, reject2);
    }, timeout);
  });
  const safeSpawnedPromise = spawnedPromise.finally(() => {
    clearTimeout(timeoutId);
  });
  return Promise.race([timeoutPromise, safeSpawnedPromise]);
};
var validateTimeout = ({ timeout }) => {
  if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
  }
};
var setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {
  if (!cleanup || detached) {
    return timedPromise;
  }
  const removeExitHandler = (0, import_signal_exit.default)(() => {
    spawned.kill();
  });
  return timedPromise.finally(() => {
    removeExitHandler();
  });
};

// node_modules/execa/lib/pipe.js
var import_node_fs = require("node:fs");
var import_node_child_process = require("node:child_process");

// node_modules/execa/node_modules/is-stream/index.js
function isStream(stream2) {
  return stream2 !== null && typeof stream2 === "object" && typeof stream2.pipe === "function";
}
function isWritableStream(stream2) {
  return isStream(stream2) && stream2.writable !== false && typeof stream2._write === "function" && typeof stream2._writableState === "object";
}

// node_modules/execa/lib/pipe.js
var isExecaChildProcess = (target) => target instanceof import_node_child_process.ChildProcess && typeof target.then === "function";
var pipeToTarget = (spawned, streamName, target) => {
  if (typeof target === "string") {
    spawned[streamName].pipe((0, import_node_fs.createWriteStream)(target));
    return spawned;
  }
  if (isWritableStream(target)) {
    spawned[streamName].pipe(target);
    return spawned;
  }
  if (!isExecaChildProcess(target)) {
    throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
  }
  if (!isWritableStream(target.stdin)) {
    throw new TypeError("The target child process's stdin must be available.");
  }
  spawned[streamName].pipe(target.stdin);
  return target;
};
var addPipeMethods = (spawned) => {
  if (spawned.stdout !== null) {
    spawned.pipeStdout = pipeToTarget.bind(void 0, spawned, "stdout");
  }
  if (spawned.stderr !== null) {
    spawned.pipeStderr = pipeToTarget.bind(void 0, spawned, "stderr");
  }
  if (spawned.all !== void 0) {
    spawned.pipeAll = pipeToTarget.bind(void 0, spawned, "all");
  }
};

// node_modules/execa/lib/stream.js
var import_node_fs2 = require("node:fs");
var import_get_stream = __toESM(require_get_stream2(), 1);
var import_merge_stream = __toESM(require_merge_stream(), 1);
var validateInputOptions = (input) => {
  if (input !== void 0) {
    throw new TypeError("The `input` and `inputFile` options cannot be both set.");
  }
};
var getInputSync = ({ input, inputFile }) => {
  if (typeof inputFile !== "string") {
    return input;
  }
  validateInputOptions(input);
  return (0, import_node_fs2.readFileSync)(inputFile);
};
var handleInputSync = (options3) => {
  const input = getInputSync(options3);
  if (isStream(input)) {
    throw new TypeError("The `input` option cannot be a stream in sync mode");
  }
  return input;
};
var getInput = ({ input, inputFile }) => {
  if (typeof inputFile !== "string") {
    return input;
  }
  validateInputOptions(input);
  return (0, import_node_fs2.createReadStream)(inputFile);
};
var handleInput = (spawned, options3) => {
  const input = getInput(options3);
  if (input === void 0) {
    return;
  }
  if (isStream(input)) {
    input.pipe(spawned.stdin);
  } else {
    spawned.stdin.end(input);
  }
};
var makeAllStream = (spawned, { all }) => {
  if (!all || !spawned.stdout && !spawned.stderr) {
    return;
  }
  const mixed = (0, import_merge_stream.default)();
  if (spawned.stdout) {
    mixed.add(spawned.stdout);
  }
  if (spawned.stderr) {
    mixed.add(spawned.stderr);
  }
  return mixed;
};
var getBufferedData = async (stream2, streamPromise) => {
  if (!stream2 || streamPromise === void 0) {
    return;
  }
  stream2.destroy();
  try {
    return await streamPromise;
  } catch (error) {
    return error.bufferedData;
  }
};
var getStreamPromise = (stream2, { encoding, buffer, maxBuffer }) => {
  if (!stream2 || !buffer) {
    return;
  }
  if (encoding) {
    return (0, import_get_stream.default)(stream2, { encoding, maxBuffer });
  }
  return import_get_stream.default.buffer(stream2, { maxBuffer });
};
var getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
  const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
  const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
  const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
  try {
    return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
  } catch (error) {
    return Promise.all([
      { error, signal: error.signal, timedOut: error.timedOut },
      getBufferedData(stdout, stdoutPromise),
      getBufferedData(stderr, stderrPromise),
      getBufferedData(all, allPromise)
    ]);
  }
};

// node_modules/execa/lib/promise.js
var nativePromisePrototype = (/* @__PURE__ */ (async () => {
})()).constructor.prototype;
var descriptors = ["then", "catch", "finally"].map((property) => [
  property,
  Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]);
var mergePromise = (spawned, promise) => {
  for (const [property, descriptor] of descriptors) {
    const value = typeof promise === "function" ? (...args2) => Reflect.apply(descriptor.value, promise(), args2) : descriptor.value.bind(promise);
    Reflect.defineProperty(spawned, property, { ...descriptor, value });
  }
};
var getSpawnedPromise = (spawned) => new Promise((resolve2, reject2) => {
  spawned.on("exit", (exitCode, signal) => {
    resolve2({ exitCode, signal });
  });
  spawned.on("error", (error) => {
    reject2(error);
  });
  if (spawned.stdin) {
    spawned.stdin.on("error", (error) => {
      reject2(error);
    });
  }
});

// node_modules/execa/lib/command.js
var import_node_buffer = require("node:buffer");
var import_node_child_process2 = require("node:child_process");
var normalizeArgs = (file, args2 = []) => {
  if (!Array.isArray(args2)) {
    return [file];
  }
  return [file, ...args2];
};
var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
var DOUBLE_QUOTES_REGEXP = /"/g;
var escapeArg = (arg) => {
  if (typeof arg !== "string" || NO_ESCAPE_REGEXP.test(arg)) {
    return arg;
  }
  return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
};
var joinCommand = (file, args2) => normalizeArgs(file, args2).join(" ");
var getEscapedCommand = (file, args2) => normalizeArgs(file, args2).map((arg) => escapeArg(arg)).join(" ");
var SPACES_REGEXP = / +/g;
var parseExpression = (expression) => {
  const typeOfExpression = typeof expression;
  if (typeOfExpression === "string") {
    return expression;
  }
  if (typeOfExpression === "number") {
    return String(expression);
  }
  if (typeOfExpression === "object" && expression !== null && !(expression instanceof import_node_child_process2.ChildProcess) && "stdout" in expression) {
    const typeOfStdout = typeof expression.stdout;
    if (typeOfStdout === "string") {
      return expression.stdout;
    }
    if (import_node_buffer.Buffer.isBuffer(expression.stdout)) {
      return expression.stdout.toString();
    }
    throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
  }
  throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
var concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
  ...tokens.slice(0, -1),
  `${tokens[tokens.length - 1]}${nextTokens[0]}`,
  ...nextTokens.slice(1)
];
var parseTemplate = ({ templates, expressions, tokens, index: index2, template: template2 }) => {
  const templateString = template2 != null ? template2 : templates.raw[index2];
  const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
  const newTokens = concatTokens(
    tokens,
    templateTokens,
    templateString.startsWith(" ")
  );
  if (index2 === expressions.length) {
    return newTokens;
  }
  const expression = expressions[index2];
  const expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
  return concatTokens(
    newTokens,
    expressionTokens,
    templateString.endsWith(" ")
  );
};
var parseTemplates = (templates, expressions) => {
  let tokens = [];
  for (const [index2, template2] of templates.entries()) {
    tokens = parseTemplate({ templates, expressions, tokens, index: index2, template: template2 });
  }
  return tokens;
};

// node_modules/execa/lib/verbose.js
var import_node_util = require("node:util");
var import_node_process4 = __toESM(require("node:process"), 1);
var verboseDefault = (0, import_node_util.debuglog)("execa").enabled;
var padField = (field, padding) => String(field).padStart(padding, "0");
var getTimestamp = () => {
  const date = /* @__PURE__ */ new Date();
  return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
};
var logCommand = (escapedCommand, { verbose }) => {
  if (!verbose) {
    return;
  }
  import_node_process4.default.stderr.write(`[${getTimestamp()}] ${escapedCommand}
`);
};

// node_modules/execa/index.js
var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
var getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
  const env2 = extendEnv ? { ...import_node_process5.default.env, ...envOption } : envOption;
  if (preferLocal) {
    return npmRunPathEnv({ env: env2, cwd: localDir, execPath });
  }
  return env2;
};
var handleArguments = (file, args2, options3 = {}) => {
  const parsed = import_cross_spawn.default._parse(file, args2, options3);
  file = parsed.command;
  args2 = parsed.args;
  options3 = parsed.options;
  options3 = {
    maxBuffer: DEFAULT_MAX_BUFFER,
    buffer: true,
    stripFinalNewline: true,
    extendEnv: true,
    preferLocal: false,
    localDir: options3.cwd || import_node_process5.default.cwd(),
    execPath: import_node_process5.default.execPath,
    encoding: "utf8",
    reject: true,
    cleanup: true,
    all: false,
    windowsHide: true,
    verbose: verboseDefault,
    ...options3
  };
  options3.env = getEnv(options3);
  options3.stdio = normalizeStdio(options3);
  if (import_node_process5.default.platform === "win32" && import_node_path2.default.basename(file, ".exe") === "cmd") {
    args2.unshift("/q");
  }
  return { file, args: args2, options: options3, parsed };
};
var handleOutput = (options3, value, error) => {
  if (typeof value !== "string" && !import_node_buffer2.Buffer.isBuffer(value)) {
    return error === void 0 ? void 0 : "";
  }
  if (options3.stripFinalNewline) {
    return stripFinalNewline(value);
  }
  return value;
};
function execa2(file, args2, options3) {
  const parsed = handleArguments(file, args2, options3);
  const command = joinCommand(file, args2);
  const escapedCommand = getEscapedCommand(file, args2);
  logCommand(escapedCommand, parsed.options);
  validateTimeout(parsed.options);
  let spawned;
  try {
    spawned = import_node_child_process3.default.spawn(parsed.file, parsed.args, parsed.options);
  } catch (error) {
    const dummySpawned = new import_node_child_process3.default.ChildProcess();
    const errorPromise = Promise.reject(makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    }));
    mergePromise(dummySpawned, errorPromise);
    return dummySpawned;
  }
  const spawnedPromise = getSpawnedPromise(spawned);
  const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
  const processDone = setExitHandler(spawned, parsed.options, timedPromise);
  const context = { isCanceled: false };
  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
  spawned.cancel = spawnedCancel.bind(null, spawned, context);
  const handlePromise = async () => {
    const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
    const stdout = handleOutput(parsed.options, stdoutResult);
    const stderr = handleOutput(parsed.options, stderrResult);
    const all = handleOutput(parsed.options, allResult);
    if (error || exitCode !== 0 || signal !== null) {
      const returnedError = makeError({
        error,
        exitCode,
        signal,
        stdout,
        stderr,
        all,
        command,
        escapedCommand,
        parsed,
        timedOut,
        isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
        killed: spawned.killed
      });
      if (!parsed.options.reject) {
        return returnedError;
      }
      throw returnedError;
    }
    return {
      command,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      all,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  };
  const handlePromiseOnce = onetime_default(handlePromise);
  handleInput(spawned, parsed.options);
  spawned.all = makeAllStream(spawned, parsed.options);
  addPipeMethods(spawned);
  mergePromise(spawned, handlePromiseOnce);
  return spawned;
}
function execaSync(file, args2, options3) {
  const parsed = handleArguments(file, args2, options3);
  const command = joinCommand(file, args2);
  const escapedCommand = getEscapedCommand(file, args2);
  logCommand(escapedCommand, parsed.options);
  const input = handleInputSync(parsed.options);
  let result;
  try {
    result = import_node_child_process3.default.spawnSync(parsed.file, parsed.args, { ...parsed.options, input });
  } catch (error) {
    throw makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    });
  }
  const stdout = handleOutput(parsed.options, result.stdout, result.error);
  const stderr = handleOutput(parsed.options, result.stderr, result.error);
  if (result.error || result.status !== 0 || result.signal !== null) {
    const error = makeError({
      stdout,
      stderr,
      error: result.error,
      signal: result.signal,
      exitCode: result.status,
      command,
      escapedCommand,
      parsed,
      timedOut: result.error && result.error.code === "ETIMEDOUT",
      isCanceled: false,
      killed: result.signal !== null
    });
    if (!parsed.options.reject) {
      return error;
    }
    throw error;
  }
  return {
    command,
    escapedCommand,
    exitCode: 0,
    stdout,
    stderr,
    failed: false,
    timedOut: false,
    isCanceled: false,
    killed: false
  };
}
var normalizeScriptStdin = ({ input, inputFile, stdio }) => input === void 0 && inputFile === void 0 && stdio === void 0 ? { stdin: "inherit" } : {};
var normalizeScriptOptions = (options3 = {}) => ({
  preferLocal: true,
  ...normalizeScriptStdin(options3),
  ...options3
});
function create$(options3) {
  function $4(templatesOrOptions, ...expressions) {
    if (!Array.isArray(templatesOrOptions)) {
      return create$({ ...options3, ...templatesOrOptions });
    }
    const [file, ...args2] = parseTemplates(templatesOrOptions, expressions);
    return execa2(file, args2, normalizeScriptOptions(options3));
  }
  $4.sync = (templates, ...expressions) => {
    if (!Array.isArray(templates)) {
      throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
    }
    const [file, ...args2] = parseTemplates(templates, expressions);
    return execaSync(file, args2, normalizeScriptOptions(options3));
  };
  return $4;
}
var $3 = create$();

// src/helpers.ts
var import_fs = __toESM(require("fs"));
var import_obsidian = require("obsidian");
var import_os = __toESM(require("os"));
var import_path = __toESM(require("path"));
function getCurrentWindow() {
  return require("electron").remote.BrowserWindow.getFocusedWindow();
}
function padNumber(n3) {
  return n3 < 10 ? `0${n3}` : n3.toString();
}
function getVaultRoot() {
  return app.vault.adapter.getBasePath();
}
function getExeRoot() {
  return import_path.default.join(
    getVaultRoot(),
    "./.obsidian/plugins/obsidian-zotero-desktop-connector/"
  );
}
function getExeName() {
  return import_os.default.platform() === "win32" ? "pdfannots2json.exe" : "pdfannots2json";
}
function getLegacyExeName() {
  return import_os.default.platform() === "win32" ? "pdf-annots2json.exe" : "pdf-annots2json";
}
function doesEXEExist(override) {
  if (override)
    return import_fs.default.existsSync(override);
  return import_fs.default.existsSync(import_path.default.join(getExeRoot(), getExeName()));
}
function doesLegacyEXEExist() {
  return import_fs.default.existsSync(import_path.default.join(getExeRoot(), getLegacyExeName()));
}
function removeEXE() {
  import_fs.default.rmSync(import_path.default.join(getExeRoot(), getExeName()));
}
function removeLegacyEXE() {
  import_fs.default.rmSync(import_path.default.join(getExeRoot(), getLegacyExeName()));
}
async function checkEXEVersion(override) {
  try {
    const result = await execa2(
      override || import_path.default.join(getExeRoot(), getExeName()),
      ["-v"]
    );
    if (result.stderr && !result.stderr.includes("warning")) {
      new import_obsidian.Notice(`Error checking PDF utility version: ${result.stderr}`, 1e4);
      throw new Error(result.stderr);
    }
    return result.stdout.trim();
  } catch (e3) {
    console.error(e3);
    new import_obsidian.Notice(`Error checking PDF utility version: ${e3.message}`, 1e4);
    throw e3;
  }
}

// src/bbt/basicTemplates/applyBasicTemplates.ts
var import_obsidian3 = require("obsidian");

// src/bbt/template.env.ts
var import_nunjucks = __toESM(require_nunjucks());
var import_obsidian2 = require("obsidian");
import_nunjucks.default.runtime.memberLookup = function memberLookup(obj, val) {
  if (obj === void 0 || obj === null) {
    return void 0;
  }
  if (val == "__proto__" || val == "constructor") {
    return function() {
      return function() {
      };
    };
  }
  if (typeof obj[val] === "function") {
    return (...args2) => obj[val].apply(obj, args2);
  }
  return obj[val];
};
function _prepareAttributeParts(attr) {
  if (!attr) {
    return [];
  }
  return attr.split(".");
}
function hasOwnProp(obj, k4) {
  return Object.prototype.hasOwnProperty.call(obj, k4);
}
function getAttrGetter(attribute) {
  const parts = _prepareAttributeParts(attribute);
  return function attrGetter(item) {
    let _item = item;
    for (let i4 = 0; i4 < parts.length; i4++) {
      const part = parts[i4];
      if (hasOwnProp(_item, part)) {
        _item = _item[part];
      } else {
        return void 0;
      }
    }
    return _item;
  };
}
function filterBy(arr, prop, cmd, ...val) {
  const getter = getAttrGetter(prop);
  if (val.length === 0)
    return arr;
  return arr.filter((v4) => {
    let toTest = typeof v4 === "string" ? v4 : getter(v4);
    if (!toTest)
      return false;
    if (typeof val[0] === "string" && ["startswith", "endswith", "contains"].includes(cmd)) {
      toTest = toTest.toString().toLocaleLowerCase();
      return val.some((value) => {
        const testVal = value.toLocaleLowerCase();
        if (cmd === "startswith") {
          return toTest.startsWith(testVal);
        }
        if (cmd === "endswith") {
          return toTest.endsWith(testVal);
        }
        if (cmd === "contains") {
          return toTest.includes(testVal);
        }
        return true;
      });
    }
    if (["dateafter", "dateonorafter", "datebefore", "dateonorbefore"].includes(
      cmd
    )) {
      return val.some((value) => {
        if (!import_obsidian2.moment.isMoment(toTest) || !import_obsidian2.moment.isMoment(value))
          return false;
        switch (cmd) {
          case "dateafter":
            return toTest.isAfter(value);
          case "dateonorafter":
            return toTest.isSameOrAfter(value);
          case "datebefore":
            return toTest.isBefore(value);
          case "dateonorbefore":
            return toTest.isSameOrBefore(value);
        }
      });
    }
    return false;
  });
}
function format(date, format3) {
  if (date instanceof import_obsidian2.moment) {
    return date.format(format3);
  }
  return "Error: `format` can only be applied to dates. Tried for format " + typeof date;
}
var PersistExtension = class {
  constructor() {
    this.tags = ["persist"];
  }
  parse(parser, nodes) {
    const tok = parser.nextToken();
    const args2 = parser.parseSignature(null, true);
    parser.advanceAfterBlockEnd(tok.value);
    const body = parser.parseUntilBlocks("endpersist");
    parser.advanceAfterBlockEnd();
    return new nodes.CallExtension(this, "run", args2, [body]);
  }
  run(context, id, body) {
    var _a2;
    let retained = "";
    if (((_a2 = context == null ? void 0 : context.ctx) == null ? void 0 : _a2._retained) && context.ctx._retained[id]) {
      retained = context.ctx._retained[id];
    }
    const trimmed = body().replace(/^\n/, "");
    return new import_nunjucks.default.runtime.SafeString(
      `%% begin ${id} %%${retained}${trimmed}%% end ${id} %%`
    );
  }
  static prepareTemplateData(templateData, md) {
    const out = {};
    if (!md)
      return templateData;
    const matches = md.matchAll(this.re);
    for (const match2 of matches) {
      out[match2[1]] = match2[2];
    }
    return {
      ...templateData,
      _retained: out
    };
  }
};
PersistExtension.id = "PersistExtension";
PersistExtension.re = /%% begin (.+?) %%([\w\W]*?)%% end \1 %%/gi;
var ObsidianMarkdownLoader = class extends import_nunjucks.Loader {
  constructor() {
    super(...arguments);
    this.async = true;
    this.wikiLinkRe = /^\[\[([^\]]+)\]\]$/;
    this.markdownLinkRe = /^\[[^\]]*\]\(([^)]+)\)$/;
  }
  setSourceFile(path8) {
    this.sourceFile = path8;
  }
  getLinkPath(link) {
    let match2 = link.trim().match(this.wikiLinkRe);
    if (match2) {
      return match2[1];
    }
    match2 = link.trim().match(this.markdownLinkRe);
    if (match2) {
      return match2[1];
    }
    return null;
  }
  getSource(name, callback) {
    const linkPath = this.getLinkPath(name);
    if (!linkPath) {
      return callback(
        new Error("Cannot find file. Invalid markdown link: " + name),
        null
      );
    }
    const file = app.metadataCache.getFirstLinkpathDest(
      linkPath,
      this.sourceFile || ""
    );
    if (!file) {
      return callback(
        new Error("Cannot find file. File not found: " + name),
        null
      );
    }
    app.vault.cachedRead(file).then((content) => {
      const src = {
        src: content,
        path: linkPath,
        noCache: true
      };
      callback(null, src);
      this.emit("load", name, src);
    }).catch((e3) => {
      callback(e3, null);
    });
  }
};
var loader = new ObsidianMarkdownLoader();
var template = new import_nunjucks.default.Environment(loader, {
  autoescape: false
});
template.addFilter("filterby", filterBy);
template.addFilter("format", format);
template.addExtension(PersistExtension.id, new PersistExtension());
function renderTemplate(sourceFile, templateStr, templateData) {
  return new Promise((res, rej) => {
    loader.setSourceFile(sourceFile);
    template.renderString(templateStr, templateData, (err, output) => {
      if (err) {
        return rej(err);
      }
      res(output);
    });
  });
}

// src/bbt/basicTemplates/applyBasicTemplates.ts
var creatorTemplate = `
{%- if creators and creators.length > 0 -%}
  {%- for creator in creators -%}
    {%- if creator.name -%}
      {{creator.name}}
    {%- else -%}
      {{creator.firstName}} {{creator.lastName}}
    {%- endif -%}
    {% if not loop.last %}, {% endif %}
  {%- endfor -%}
{%- endif -%}
`;
var pdfLinkTemplate = `
{%- if attachments and attachments.length > 0 -%}
{%- set file = attachments | filterby("path", "endswith", ".pdf") | first -%}
{%- if file and file.path and file.path.endsWith(".pdf") -%}
	[{{file.title}}](file://{{file.path | replace(" ", "%20")}})
{%- endif -%}
{%- endif -%}
`;
var pdfZoteroLinkTemplate = `
{%- if attachments and attachments.length > 0 -%}
{%- set file = attachments | filterby("path", "endswith", ".pdf") | first -%}
{%- if file and file.path and file.path.endsWith(".pdf") -%}
	[{{file.title}}]({{file.desktopURI}})
{%- endif -%}
{%- endif -%}
`;
var annotationsTemplate = `
{%- if annotations and annotations.length > 0 -%}
{%- set annots = annotations | filterby("date", "dateafter", lastExportDate) -%}
{%- if annots.length > 0 %}
**Imported: {{importDate | format("YYYY-MM-DD")}}**

{% for annotation in annots -%}
	{%- if annotation.annotatedText -%}
    > \u201C{{annotation.annotatedText}}\u201D{% if annotation.color %} {{annotation.colorCategory}} {{annotation.type | capitalize}} {% else %} {{annotation.type | capitalize}} {% endif %}[Page {{annotation.page}}]({{annotation.attachment.desktopURI.replace("select", "open-pdf")}}?page={{annotation.pageLabel}}&annotation={{annotation.id}})
    {%- endif %}
	{%- if annotation.imageRelativePath -%}
	> ![[{{annotation.imageRelativePath}}]]
    {%- endif %}
{% if annotation.comment %}
{{annotation.comment}}
{% endif %}
{% endfor -%}
{%- endif -%}
{%- endif -%}
`;
async function applyBasicTemplates(sourceFile, itemData) {
  var _a2, _b, _c;
  if (!itemData)
    return itemData;
  const creatorsByType = (itemData.creators || []).reduce(
    (byType, current) => {
      if (!byType[current.creatorType])
        byType[current.creatorType] = [];
      byType[current.creatorType].push(current);
      return byType;
    },
    {}
  );
  await Promise.all(
    Object.keys(creatorsByType).map(async (type) => {
      itemData[`${type}s`] = (await renderTemplate(sourceFile, creatorTemplate, {
        creators: creatorsByType[type]
      })).trim();
    })
  );
  const pdfLink = (await renderTemplate(sourceFile, pdfLinkTemplate, itemData)).trim();
  if (pdfLink)
    itemData.pdfLink = pdfLink;
  const pdfZoteroLink = (await renderTemplate(sourceFile, pdfZoteroLinkTemplate, itemData)).trim();
  if (pdfZoteroLink)
    itemData.pdfZoteroLink = pdfZoteroLink;
  if ((_a2 = itemData.notes) == null ? void 0 : _a2.length) {
    const notes = itemData.notes.reduce((combined, current) => {
      if (current.note) {
        return `${combined}

${current.note.trim()}`;
      }
      return combined;
    }, "").trim();
    if (notes) {
      itemData.markdownNotes = notes;
    }
  }
  if ((_b = itemData.tags) == null ? void 0 : _b.length) {
    itemData.allTags = itemData.tags.map((t3) => t3.tag).join(", ");
    itemData.hashTags = itemData.tags.map((t3) => `#${t3.tag.replace(/\s+/g, "-")}`).join(", ");
  }
  if ((_c = itemData.annotations) == null ? void 0 : _c.length) {
    itemData.formattedAnnotationsNew = (await renderTemplate(sourceFile, annotationsTemplate, itemData)).trim();
    itemData.formattedAnnotations = (await renderTemplate(sourceFile, annotationsTemplate, {
      ...itemData,
      lastExportDate: (0, import_obsidian3.moment)(0)
    })).trim();
  }
  return itemData;
}

// src/bbt/cayw.ts
var import_obsidian6 = require("obsidian");

// src/bbt/LoadingModal.ts
var import_obsidian4 = require("obsidian");
var LoadingModal = class extends import_obsidian4.Modal {
  constructor(app2, message) {
    super(app2);
    this.message = message;
  }
  onOpen() {
    this.contentEl.createDiv({ text: this.message });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/bbt/helpers.ts
var import_path2 = __toESM(require("path"));
var defaultHeaders = {
  "Content-Type": "application/json",
  "User-Agent": "obsidian/zotero",
  Accept: "application/json",
  Connection: "keep-alive"
};
function getPort(database, port) {
  if (database === "Zotero")
    return "23119";
  if (database === "Juris-M")
    return "24119";
  if (!port)
    return "23119";
  return port;
}
async function mkMDDir(mdPath) {
  const dir = import_path2.default.dirname(mdPath);
  if (await app.vault.adapter.exists(dir))
    return;
  await app.vault.createFolder(dir);
}
var toSpaceRegEx = /\s*[*?]+\s*/g;
var toDashRegEx = /\s*[:"<>|]+\s*/g;
function replaceIllegalChars(str) {
  return str.replace(toSpaceRegEx, " ").trim().replace(toDashRegEx, " - ").trim();
}
function sanitizeFilePath(filePath) {
  const parsed = import_path2.default.parse(filePath);
  const dir = replaceIllegalChars(parsed.dir);
  const name = replaceIllegalChars(parsed.name);
  return import_path2.default.join(dir, `${name}${parsed.ext}`);
}
function hexToHSL(str) {
  let rStr = "0", gStr = "0", bStr = "0";
  if (str.length == 4) {
    rStr = "0x" + str[1] + str[1];
    gStr = "0x" + str[2] + str[2];
    bStr = "0x" + str[3] + str[3];
  } else if (str.length == 7) {
    rStr = "0x" + str[1] + str[2];
    gStr = "0x" + str[3] + str[4];
    bStr = "0x" + str[5] + str[6];
  }
  const r5 = +rStr / 255;
  const g5 = +gStr / 255;
  const b4 = +bStr / 255;
  const cmin = Math.min(r5, g5, b4), cmax = Math.max(r5, g5, b4), delta = cmax - cmin;
  let h4 = 0, s5 = 0, l4 = 0;
  if (delta == 0)
    h4 = 0;
  else if (cmax == r5)
    h4 = (g5 - b4) / delta % 6;
  else if (cmax == g5)
    h4 = (b4 - r5) / delta + 2;
  else
    h4 = (r5 - g5) / delta + 4;
  h4 = Math.round(h4 * 60);
  if (h4 < 0)
    h4 += 360;
  l4 = (cmax + cmin) / 2;
  s5 = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l4 - 1));
  s5 = +(s5 * 100).toFixed(1);
  l4 = +(l4 * 100).toFixed(1);
  return { h: h4, s: s5, l: l4 };
}
function getColorCategory(hex) {
  const { h: h4, s: s5, l: l4 } = hexToHSL(hex);
  if (l4 < 12) {
    return "Black";
  }
  if (l4 > 98) {
    return "White";
  }
  if (s5 < 2) {
    return "Gray";
  }
  if (h4 < 15) {
    return "Red";
  }
  if (h4 < 45) {
    return "Orange";
  }
  if (h4 < 65) {
    return "Yellow";
  }
  if (h4 < 170) {
    return "Green";
  }
  if (h4 < 190) {
    return "Cyan";
  }
  if (h4 < 263) {
    return "Blue";
  }
  if (h4 < 280) {
    return "Purple";
  }
  if (h4 < 335) {
    return "Magenta";
  }
  return "Red";
}
function getLocalURI(ext, uri, params) {
  const itemId = uri.split("/").pop();
  const prefix2 = `zotero://${ext}`;
  let url2 = "";
  if (/group/.test(uri)) {
    url2 = uri.replace("http://zotero.org", prefix2);
  } else {
    url2 = `${prefix2}/library/items/${itemId}`;
  }
  if (params) {
    const p5 = new URLSearchParams(params);
    url2 += `?${p5}`;
  }
  return url2;
}

// src/bbt/jsonRPC.ts
var import_obsidian5 = require("obsidian");
async function getNotesFromCiteKeys(citeKeys, database) {
  let res;
  const modal = new LoadingModal(app, "Fetching notes from Zotero...");
  modal.open();
  try {
    res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "item.notes",
        params: [citeKeys.map((k4) => k4.key)]
      }),
      headers: defaultHeaders
    });
  } catch (e3) {
    console.error(e3);
    modal.close();
    new import_obsidian5.Notice(`Error retrieving notes: ${e3.message}`, 1e4);
    return null;
  }
  modal.close();
  try {
    return JSON.parse(res).result;
  } catch (e3) {
    console.error(e3);
    new import_obsidian5.Notice(`Error retrieving notes: ${e3.message}`, 1e4);
    return null;
  }
}
async function getCollectionFromCiteKey(citeKey, database) {
  let res;
  const modal = new LoadingModal(app, "Fetching collections from Zotero...");
  modal.open();
  try {
    res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "item.collections",
        params: [[citeKey.key], true]
      }),
      headers: defaultHeaders
    });
  } catch (e3) {
    console.error(e3);
    modal.close();
    new import_obsidian5.Notice(`Error retrieving notes: ${e3.message}`, 1e4);
    return null;
  }
  modal.close();
  try {
    const result = JSON.parse(res).result;
    const cols = result[citeKey.key];
    return cols.map((c4) => {
      let pointer = c4;
      const fullPath = [c4.name];
      while (pointer.parentCollection) {
        fullPath.push(pointer.parentCollection.name);
        pointer = pointer.parentCollection;
      }
      return {
        key: c4.key,
        name: c4.name,
        fullPath: fullPath.reverse().join("/")
      };
    });
  } catch (e3) {
    console.error(e3);
    new import_obsidian5.Notice(`Error retrieving notes: ${e3.message}`, 1e4);
    return null;
  }
}
async function getAttachmentsFromCiteKey(citeKey, database) {
  let res;
  const modal = new LoadingModal(app, "Fetching collections from Zotero...");
  modal.open();
  try {
    res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "item.attachments",
        params: [citeKey.key]
      }),
      headers: defaultHeaders
    });
  } catch (e3) {
    console.error(e3);
    modal.close();
    new import_obsidian5.Notice(`Error retrieving notes: ${e3.message}`, 1e4);
    return null;
  }
  modal.close();
  try {
    return JSON.parse(res).result;
  } catch (e3) {
    console.error(e3);
    new import_obsidian5.Notice(`Error retrieving notes: ${e3.message}`, 1e4);
    return null;
  }
}
var cachedLibs = null;
var cachedCiteKeys = /* @__PURE__ */ new Map();
async function getLibForCiteKey(citeKey, database) {
  var _a2;
  if (cachedCiteKeys.has(citeKey))
    return cachedCiteKeys.get(citeKey);
  try {
    const searchResults = await execSearch(citeKey, database);
    if (!searchResults || searchResults.length === 0) {
      return null;
    }
    const match2 = searchResults.find((res2) => res2.citekey === citeKey);
    if (!match2)
      return null;
    if (cachedLibs) {
      const lib = cachedLibs.find((p5) => p5.name === match2.library);
      if (lib) {
        cachedCiteKeys.set(citeKey, lib.id);
        return lib.id;
      }
      return null;
    }
    const res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "user.groups"
      }),
      headers: defaultHeaders
    });
    const parsed = JSON.parse(res);
    if (((_a2 = parsed.result) == null ? void 0 : _a2.length) > 0) {
      cachedLibs = parsed.result;
      const lib = cachedLibs.find((p5) => p5.name === match2.library);
      if (lib) {
        cachedCiteKeys.set(citeKey, lib.id);
        return lib.id;
      }
      return null;
    }
  } catch (e3) {
    console.error(e3);
    new import_obsidian5.Notice(`Error retrieving library id: ${e3.message}`, 1e4);
  }
  return null;
}
function getBibFromCiteKey(citeKey, database, cslStyle, format3, silent) {
  return getBibFromCiteKeys([citeKey], database, cslStyle, format3, silent);
}
async function getBibFromCiteKeys(citeKeys, database, cslStyle, format3, silent) {
  var _a2;
  if (!citeKeys || !citeKeys.length)
    return null;
  let res;
  let modal;
  if (!silent) {
    modal = new LoadingModal(app, "Fetching data from Zotero...");
    modal.open();
  }
  try {
    const params = {
      quickCopy: true,
      contentType: "html"
    };
    if (cslStyle) {
      delete params.quickCopy;
      params.id = cslStyle;
    }
    res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "item.bibliography",
        params: [citeKeys.map((k4) => k4.key), params, citeKeys[0].library]
      }),
      headers: defaultHeaders
    });
  } catch (e3) {
    console.error(e3);
    !silent && modal.close();
    new import_obsidian5.Notice(`Error retrieving formatted bibliography: ${e3.message}`, 1e4);
    return null;
  }
  !silent && modal.close();
  try {
    const parsed = JSON.parse(res);
    if ((_a2 = parsed.error) == null ? void 0 : _a2.message) {
      throw new Error(parsed.error.message);
    }
    return format3 === "html" ? parsed.result : (0, import_obsidian5.htmlToMarkdown)(parsed.result);
  } catch (e3) {
    console.error(e3);
    console.error(`Response from BBT: ${res}`);
    let message = `Error converting formatted bibliography to markdown: ${e3.message}`;
    if (e3.message.includes("element/document/fragment")) {
      message = `Error: Received empty bibliography from Zotero. Ensure Zotero's quick copy settings are set and the selected citation style is installed.`;
    }
    new import_obsidian5.Notice(message, 1e4);
    return null;
  }
}
async function getItemJSONFromCiteKeys(citeKeys, database, libraryID) {
  var _a2;
  let res;
  const modal = new LoadingModal(app, "Fetching data from Zotero...");
  modal.open();
  try {
    res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "item.export",
        params: [
          citeKeys.map((k4) => k4.key),
          "36a3b0b5-bad0-4a04-b79b-441c7cef77db",
          libraryID
        ]
      }),
      headers: defaultHeaders
    });
  } catch (e3) {
    console.error(e3);
    modal.close();
    new import_obsidian5.Notice(`Error retrieving item data: ${e3.message}`, 1e4);
    return null;
  }
  modal.close();
  try {
    const parsed = JSON.parse(res);
    if ((_a2 = parsed.error) == null ? void 0 : _a2.message) {
      throw new Error(parsed.error.message);
    }
    return JSON.parse(parsed.result[2]).items;
  } catch (e3) {
    console.error(e3);
    new import_obsidian5.Notice(`Error retrieving item data: ${e3.message}`, 1e4);
    return null;
  }
}
async function getItemJSONFromRelations(libraryID, relations, database) {
  let res;
  const modal = new LoadingModal(app, "Fetching data from Zotero...");
  modal.open();
  const uriMap = {};
  const idOrder = [];
  try {
    res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "item.citationkey",
        params: [
          relations.map((r5) => {
            const id = r5.split("/").pop();
            idOrder.push(id);
            uriMap[id] = r5;
            return `${libraryID}:${id}`;
          })
        ]
      }),
      headers: defaultHeaders
    });
  } catch (e3) {
    console.error(e3);
    modal.close();
    new import_obsidian5.Notice(`Error retrieving item data: ${e3.message}`, 1e4);
    return null;
  }
  modal.close();
  const idMap = {};
  const citekeys = [];
  try {
    const json = JSON.parse(res);
    Object.keys(json.result).forEach((k4) => {
      const id = k4.split(":").pop();
      if (json.result[k4]) {
        citekeys.push({ key: json.result[k4], library: libraryID });
        idMap[id] = { citekey: json.result[k4], uri: uriMap[id] };
      } else {
        idMap[id] = { uri: uriMap[id] };
      }
    });
  } catch (e3) {
    console.error(e3);
    new import_obsidian5.Notice(`Error retrieving item data: ${e3.message}`, 1e4);
    return null;
  }
  const items = citekeys.length ? await getItemJSONFromCiteKeys(citekeys, database, libraryID) : [];
  return idOrder.map((id) => {
    if (idMap[id].citekey) {
      const item = items.find(
        (item2) => {
          var _a2;
          return ((_a2 = getCiteKeyFromAny(item2)) == null ? void 0 : _a2.key) === idMap[id].citekey;
        }
      );
      if (item) {
        return item;
      }
    }
    return idMap[id];
  });
}
async function getIssueDateFromCiteKey(citeKey, database) {
  var _a2;
  let res;
  const modal = new LoadingModal(app, "Fetching data from Zotero...");
  modal.open();
  try {
    res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "item.export",
        params: [
          [citeKey.key],
          "f4b52ab0-f878-4556-85a0-c7aeedd09dfc",
          citeKey.library
        ]
      }),
      headers: defaultHeaders
    });
  } catch (e3) {
    console.error(e3);
    modal.close();
    new import_obsidian5.Notice(`Error retrieving item data: ${e3.message}`, 1e4);
    return null;
  }
  modal.close();
  try {
    const parsed = JSON.parse(res);
    if ((_a2 = parsed.error) == null ? void 0 : _a2.message) {
      throw new Error(parsed.error.message);
    }
    const items = JSON.parse(parsed.result[2]);
    const dates = items.map((i4) => {
      const { issued } = i4;
      if (!issued || !issued["date-parts"])
        return null;
      const dateParts = issued["date-parts"][0];
      if (!dateParts.length)
        return null;
      const date = (0, import_obsidian5.moment)(
        `${dateParts[0]}-${dateParts[1] ? padNumber(dateParts[1]) : "01"}-${dateParts[2] ? padNumber(dateParts[2]) : "01"}`,
        "YYYY-MM-DD"
      );
      return date;
    }).filter((d5) => d5);
    return dates[0] ? dates[0] : null;
  } catch (e3) {
    console.error(e3);
    new import_obsidian5.Notice(`Error retrieving item data: ${e3.message}`, 1e4);
    return null;
  }
}
async function execSearch(term, database) {
  let res;
  try {
    res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "item.search",
        params: [term]
      }),
      headers: defaultHeaders
    });
  } catch (e3) {
    console.error(e3);
    new import_obsidian5.Notice(`Error searching: ${e3.message}`, 1e4);
    return null;
  }
  try {
    return JSON.parse(res).result;
  } catch (e3) {
    console.error(e3);
    new import_obsidian5.Notice(`Error searching: ${e3.message}`, 1e4);
    return null;
  }
}
var translatorId = "f4b52ab0-f878-4556-85a0-c7aeedd09dfc";
async function getCiteKeyExport(database, groupId, groupName) {
  try {
    const res = await (0, import_obsidian5.request)({
      method: "GET",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/export/library?/${groupId}/${groupName}.${translatorId}`,
      headers: defaultHeaders
    });
    const entries = JSON.parse(res);
    return Array.isArray(entries) ? entries.map((e3) => {
      const out = {
        libraryID: Number(groupId)
      };
      if (e3["citation-key"]) {
        out.citekey = e3["citation-key"];
      } else {
        return null;
      }
      if (e3["title"]) {
        out.title = e3["title"];
      } else {
        return null;
      }
      return out;
    }).filter((k4) => !!k4) : null;
  } catch (e3) {
    return null;
  }
}
async function getUserGroups(database) {
  let res;
  try {
    res = await (0, import_obsidian5.request)({
      method: "POST",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/json-rpc`,
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "user.groups",
        params: []
      }),
      headers: defaultHeaders
    });
  } catch (e3) {
    console.error(e3);
    return null;
  }
  try {
    return JSON.parse(res).result;
  } catch (e3) {
    console.error(e3);
    return null;
  }
}
var cachedKeys = [];
var lastCheck = 0;
async function getAllCiteKeys(database, force) {
  if (!force && cachedKeys.length && Date.now() - lastCheck < 1e3 * 60 * 60) {
    return { citekeys: cachedKeys, fromCache: true };
  }
  if (!await isZoteroRunning(database, true)) {
    return { citekeys: cachedKeys, fromCache: true };
  }
  const allKeys = [];
  const userGroups = await getUserGroups(database);
  if (!userGroups) {
    return { citekeys: cachedKeys, fromCache: true };
  }
  for (const group of userGroups) {
    const keys = await getCiteKeyExport(database, group.id, group.name);
    if (keys) {
      allKeys.push(...keys);
    }
  }
  cachedKeys = allKeys;
  lastCheck = Date.now();
  return { citekeys: allKeys, fromCache: false };
}

// src/bbt/cayw.ts
function getCiteKeyFromAny(item) {
  if (!item.citekey && !item.citationKey)
    return null;
  return {
    key: item.citekey || item.citationKey,
    library: item.libraryID
  };
}
var cachedIsRunning = false;
var lastCheck2 = 0;
async function isZoteroRunning(database, silent) {
  if (cachedIsRunning && Date.now() - lastCheck2 < 1e3 * 60) {
    return cachedIsRunning;
  }
  let modal;
  if (!silent) {
    modal = new LoadingModal(app, "Fetching data from Zotero...");
    modal.open();
  }
  try {
    const res = await (0, import_obsidian6.request)({
      method: "GET",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/cayw?probe=true`,
      headers: defaultHeaders
    });
    modal == null ? void 0 : modal.close();
    cachedIsRunning = res === "ready";
    lastCheck2 = Date.now();
    return cachedIsRunning;
  } catch (e3) {
    modal == null ? void 0 : modal.close();
    !silent && new import_obsidian6.Notice(
      "Cannot connect to Zotero. Please ensure it is running and the Better BibTeX plugin is installed",
      1e4
    );
    return false;
  }
}
function getQueryParams(format3) {
  switch (format3.format) {
    case "formatted-bibliography":
      return "format=formatted-bibliography";
    case "formatted-citation":
      return `format=formatted-citation${format3.cslStyle ? `&style=${format3.cslStyle}` : ""}`;
    case "pandoc":
      return `format=pandoc${format3.brackets ? "&brackets=true" : ""}`;
    case "latex":
      return `format=latex&command=${format3.command || "cite"}`;
    case "biblatex":
      return `format=biblatex&command=${format3.command || "autocite"}`;
  }
}
async function getCAYW(format3, database) {
  const win = getCurrentWindow();
  if (!await isZoteroRunning(database)) {
    return null;
  }
  const modal = new LoadingModal(app, "Awaiting item selection from Zotero...");
  modal.open();
  try {
    if (format3.format === "formatted-bibliography") {
      modal.close();
      const citeKeys = await getCiteKeys(database);
      return await getBibFromCiteKeys(citeKeys, database, format3.cslStyle);
    }
    const res = await (0, import_obsidian6.request)({
      method: "GET",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/cayw?${getQueryParams(format3)}`,
      headers: defaultHeaders
    });
    win.show();
    modal.close();
    return res;
  } catch (e3) {
    win.show();
    console.error(e3);
    modal.close();
    new import_obsidian6.Notice(`Error processing citation: ${e3.message}`, 1e4);
    return null;
  }
}
async function getCiteKeys(database) {
  try {
    const json = await getCAYWJSON(database);
    if (!json)
      return [];
    const citeKeys = json.map((e3) => {
      return getCiteKeyFromAny(e3);
    }).filter((e3) => !!e3);
    if (!citeKeys.length) {
      return [];
    }
    return citeKeys;
  } catch (e3) {
    return [];
  }
}
async function getCAYWJSON(database) {
  const win = getCurrentWindow();
  if (!await isZoteroRunning(database)) {
    return null;
  }
  const modal = new LoadingModal(app, "Awaiting item selection from Zotero...");
  modal.open();
  try {
    const res = await (0, import_obsidian6.request)({
      method: "GET",
      url: `http://127.0.0.1:${getPort(
        database.database,
        database.port
      )}/better-bibtex/cayw?format=translate&translator=36a3b0b5-bad0-4a04-b79b-441c7cef77db&exportNotes=false`,
      headers: defaultHeaders
    });
    win.show();
    modal.close();
    if (res) {
      return JSON.parse(res).items || [];
    } else {
      return null;
    }
  } catch (e3) {
    win.show();
    console.error(e3);
    modal.close();
    new import_obsidian6.Notice(`Error retrieving cite key: ${e3.message}`, 1e4);
    return null;
  }
}

// src/bbt/exportNotes.ts
var import_fs2 = require("fs");
var import_obsidian8 = require("obsidian");
var import_path3 = __toESM(require("path"));

// src/bbt/template.helpers.ts
var import_obsidian7 = require("obsidian");
function loadTemplate(name, path8) {
  if (!path8)
    return null;
  const templateFile = app.vault.getAbstractFileByPath(
    sanitizeObsidianPath(path8)
  );
  if (!templateFile) {
    new import_obsidian7.Notice(`Error: ${name} template not found ${path8}`);
    return null;
  }
  return app.vault.cachedRead(templateFile);
}
async function getTemplates(params) {
  const { exportFormat } = params;
  const noLegacyTemplates = !exportFormat.headerTemplatePath && !exportFormat.annotationTemplatePath && !exportFormat.footerTemplatePath;
  if (exportFormat.templatePath || noLegacyTemplates) {
    return {
      template: await loadTemplate("", exportFormat.templatePath)
    };
  }
  return {
    headerTemplate: await loadTemplate(
      "Header",
      exportFormat.headerTemplatePath
    ),
    annotationTemplate: await loadTemplate(
      "Annotation",
      exportFormat.annotationTemplatePath
    ),
    footerTemplate: await loadTemplate(
      "Footer",
      exportFormat.footerTemplatePath
    )
  };
}
function getLastExport(md) {
  let match2 = md.match(/%% Import Date: (\S+) %%\n$/);
  if (match2 && match2[1]) {
    return (0, import_obsidian7.moment)(match2[1]);
  }
  match2 = md.match(/%% Export Date: (\S+) %%\n$/);
  if (match2 && match2[1]) {
    return (0, import_obsidian7.moment)(match2[1]);
  }
  return (0, import_obsidian7.moment)(0);
}
function appendExportDate(md) {
  return md + `

%% Import Date: ${(0, import_obsidian7.moment)().toISOString(true)} %%
`;
}
function getExistingAnnotations(md) {
  const match2 = md.match(
    /%% Begin annotations %%([\w\W]+)%% End annotations %%/
  );
  if (match2 && match2[1]) {
    return match2[1].trim();
  }
  return "";
}
function wrapAnnotationTemplate(str) {
  return `
%% Begin annotations %%
${str}
%% End annotations %%
`;
}
function removeStartingSlash(str) {
  if (str.startsWith("/")) {
    return str.replace(/^\/+/, "");
  }
  return str;
}
function sanitizeObsidianPath(str) {
  if (!str.endsWith(".md")) {
    str += ".md";
  }
  if (str.startsWith("/")) {
    str = removeStartingSlash(str);
  }
  return str;
}

// src/bbt/exportNotes.ts
async function processZoteroAnnotationNotes(key, noteStr, attachments, destination) {
  const parsed = new DOMParser().parseFromString(noteStr, "text/html");
  const annots = parsed.querySelectorAll("[data-annotation]");
  const cites = parsed.querySelectorAll("[data-citation]");
  for (const annot of Array.from(annots)) {
    try {
      const params = annot.dataset.annotation;
      const json = params ? JSON.parse(decodeURIComponent(params)) : null;
      if (!json)
        return;
      const annotationKey = json.annotationKey;
      const isImage = annot instanceof HTMLImageElement;
      if (isImage) {
        const imagePath = attachments[annotationKey];
        if (imagePath) {
          const parsed2 = import_path3.default.parse(imagePath);
          const destPath = await getAvailablePathForAttachments(
            parsed2.name,
            parsed2.ext.slice(1),
            destination
          );
          try {
            (0, import_fs2.copyFileSync)(
              import_path3.default.join(parsed2.dir, `${annotationKey}${parsed2.ext}`),
              import_path3.default.join(getVaultRoot(), destPath)
            );
          } catch (e3) {
            new import_obsidian8.Notice(
              "Error: unable to copy annotation image from Zotero into your vault",
              7e3
            );
            console.error(e3);
          }
          annot.src = destPath;
        }
      }
      annot.insertAdjacentElement(
        isImage ? "afterend" : "beforebegin",
        createEl("a", {
          text: "Go to annotation",
          href: getLocalURI("open-pdf", json.attachmentURI, {
            page: json.pageLabel,
            annotation: json.annotationKey
          })
        })
      );
      if (isImage) {
        annot.insertAdjacentElement("afterend", createEl("br"));
      } else {
        annot.insertAdjacentElement("beforebegin", createSpan({ text: " " }));
      }
    } catch (e3) {
      console.error(e3);
    }
  }
  cites.forEach((cite) => {
    var _a2;
    try {
      const params = cite.dataset.citation;
      const json = params ? JSON.parse(decodeURIComponent(params)) : null;
      if (!json || !json.citationItems.length || !((_a2 = json.citationItems[0].uris) == null ? void 0 : _a2.length))
        return;
      const citeSpan = cite.querySelector("span");
      if (!citeSpan)
        return;
      const text = citeSpan.innerText;
      citeSpan.empty();
      citeSpan.createEl("a", {
        text,
        href: getLocalURI("select", json.citationItems[0].uris[0])
      });
    } catch (e3) {
      console.error(e3);
    }
  });
  return parsed.body.innerHTML;
}
async function noteExportPrompt(database, destination) {
  const citeKeys = await getCiteKeys(database);
  if (!citeKeys.length)
    return;
  const notes = await getNotesFromCiteKeys(citeKeys, database);
  if (!notes) {
    new import_obsidian8.Notice("No notes found for selected items", 7e3);
    return;
  }
  const keys = Object.keys(notes);
  if (!keys.length) {
    new import_obsidian8.Notice("No notes found for selected items", 7e3);
    return;
  }
  const attachments = {};
  for (const key of citeKeys) {
    const attachment = await getAttachmentsFromCiteKey(key, database);
    if (attachment) {
      const images = {};
      attachment.forEach((a3) => {
        var _a2;
        (_a2 = a3.annotations) == null ? void 0 : _a2.forEach((annot) => {
          if (annot.annotationType === "image") {
            images[annot.key] = annot.annotationImagePath;
          }
        });
      });
      attachments[key.key] = images;
    }
  }
  const notesMarkdown = {};
  for (const key of keys) {
    const processed = [];
    for (const note of notes[key]) {
      processed.push(
        (0, import_obsidian8.htmlToMarkdown)(
          await processZoteroAnnotationNotes(
            key,
            note,
            attachments[key],
            destination
          )
        )
      );
    }
    notesMarkdown[key] = processed.join("\n\n");
  }
  return notesMarkdown;
}
async function getAvailablePathForAttachments(base, extension, destination) {
  let folderPath = app.vault.getConfig("attachmentFolderPath");
  const sameFolder = folderPath === "." || folderPath === "./";
  let subfolder = null;
  if (folderPath.startsWith("./")) {
    subfolder = folderPath.slice(2);
  }
  if (sameFolder) {
    folderPath = destination ? destination : "";
  } else if (subfolder) {
    folderPath = import_path3.default.join(destination ? destination : "", subfolder);
  }
  folderPath = (0, import_obsidian8.normalizePath)(folderPath);
  let folder = app.vault.getAbstractFileByPathInsensitive(folderPath);
  if (!folder && subfolder) {
    await app.vault.createFolder(folderPath);
    folder = app.vault.getAbstractFileByPathInsensitive(folderPath);
  }
  if (!(folder instanceof import_obsidian8.TFolder)) {
    return `${base}.${extension}`;
  }
  return `${folder.getParentPrefix() + base}.${extension}`;
}
function insertNotesIntoCurrentDoc(editor, notes) {
  editor.replaceSelection(Object.values(notes).join("\n\n"));
}
async function filesFromNotes(folder, notes) {
  const keys = Object.keys(notes);
  const files = [];
  for (const key of keys) {
    const file = await newFile(folder, key, notes[key]);
    if (!file) {
      break;
    }
    files.push(file);
  }
  return files.map((f4) => f4.path);
}
async function newFile(folder, citeKey, content) {
  const path8 = (0, import_obsidian8.normalizePath)(
    sanitizeFilePath(removeStartingSlash(`${folder}/${citeKey}.md`))
  );
  let file = app.vault.getAbstractFileByPath(path8);
  try {
    if (file) {
      await app.vault.modify(file, content);
    } else {
      await mkMDDir(path8);
      file = await app.vault.create(path8, content);
    }
  } catch (e3) {
    console.error(e3);
    new import_obsidian8.Notice(`Error creating file "${path8}": ${e3.message}`, 1e4);
    return null;
  }
  return file;
}

// src/bbt/extractAnnotations.ts
var import_obsidian9 = require("obsidian");
var import_path4 = __toESM(require("path"));
var paramMap = {
  noWrite: "-w",
  imageOutputPath: "-o",
  imageBaseName: "-n",
  imageFormat: "-f",
  imageDPI: "-d",
  imageQuality: "-q",
  ignoreBefore: "-b",
  attemptOCR: "-e",
  ocrLang: "-l",
  tesseractPath: "--tesseract-path",
  tessDataDir: "--tess-data-dir"
};
async function extractAnnotations(input, params) {
  const modal = new LoadingModal(app, "Extracting annotations...");
  modal.open();
  const args2 = [input];
  Object.keys(params).forEach((k4) => {
    const val = params[k4];
    if (val === "" || val === void 0)
      return "";
    const key = paramMap[k4];
    if (typeof val === "boolean") {
      if (val) {
        args2.push(key);
      }
    } else {
      args2.push(key);
      if (typeof val === "string" && val.startsWith("-")) {
        args2.push(`"${val}"`);
      } else {
        args2.push(val.toString());
      }
    }
  });
  try {
    const result = await execa2(import_path4.default.join(getExeRoot(), getExeName()), args2);
    modal.close();
    if (result.stderr.toLowerCase().includes("password")) {
      new import_obsidian9.Notice(
        `Error opening ${import_path4.default.basename(input)}: PDF is password protected`,
        1e4
      );
      return "[]";
    }
    if (result.stderr && !result.stderr.includes("warning")) {
      new import_obsidian9.Notice(`Error processing PDF: ${result.stderr}`, 1e4);
      throw new Error(result.stderr);
    }
    return result.stdout;
  } catch (e3) {
    modal.close();
    if (e3.message.toLowerCase().includes("password")) {
      new import_obsidian9.Notice(
        `Error opening ${import_path4.default.basename(input)}: PDF is password protected`,
        1e4
      );
      return "[]";
    } else if (e3.message.toLowerCase().includes("type3")) {
      new import_obsidian9.Notice(`Error processing annotations: ${e3.message}`, 1e4);
      return "[]";
    }
    console.error(e3);
    new import_obsidian9.Notice(`Error processing PDF: ${e3.message}`, 1e4);
    throw e3;
  }
}

// src/bbt/export.ts
async function processNote(citeKey, note) {
  if (note.note) {
    note.note = (0, import_obsidian10.htmlToMarkdown)(
      await processZoteroAnnotationNotes(citeKey.key, note.note, {})
    );
  }
  if (note.dateAdded) {
    note.dateAdded = (0, import_obsidian10.moment)(note.dateAdded);
  }
  if (note.dateModified) {
    note.dateModified = (0, import_obsidian10.moment)(note.dateModified);
  }
}
function processAttachment(attachment) {
  var _a2;
  if (attachment.dateAdded) {
    attachment.dateAdded = (0, import_obsidian10.moment)(attachment.dateAdded);
  }
  if (attachment.dateModified) {
    attachment.dateModified = (0, import_obsidian10.moment)(attachment.dateModified);
  }
  if (attachment.uri) {
    attachment.itemKey = attachment.uri.split("/").pop();
    attachment.desktopURI = attachment.select || getLocalURI("select", attachment.uri);
    if ((_a2 = attachment.path) == null ? void 0 : _a2.endsWith(".pdf")) {
      attachment.pdfURI = getLocalURI("open-pdf", attachment.uri);
    }
  }
}
function processAnnotation(annotation, attachment, imageRelativePath) {
  annotation.date = (0, import_obsidian10.moment)(annotation.date);
  annotation.attachment = attachment;
  annotation.source = "pdf";
  if (annotation.imagePath) {
    annotation.imageBaseName = import_path5.default.basename(annotation.imagePath);
    annotation.imageExtension = import_path5.default.extname(annotation.imagePath).slice(1);
    annotation.imageRelativePath = (0, import_obsidian10.normalizePath)(
      import_path5.default.join(imageRelativePath, annotation.imageBaseName)
    );
  }
  annotation.desktopURI = getLocalURI("open-pdf", attachment.uri, {
    page: annotation.pageLabel
  });
}
function convertNativeAnnotation(annotation, attachment, imageOutputPath, imageRelativePath, imageBaseName, copy2 = false) {
  var _a2;
  const rect = annotation.annotationPosition.rects[0];
  const annot = {
    date: (0, import_obsidian10.moment)(annotation.dateModified),
    attachment,
    page: annotation.annotationPosition.pageIndex + 1,
    pageLabel: annotation.annotationPageLabel,
    id: annotation.key,
    type: annotation.annotationType,
    x: rect[0],
    y: rect[1],
    color: annotation.annotationColor,
    colorCategory: getColorCategory(annotation.annotationColor),
    desktopURI: getLocalURI("open-pdf", attachment.uri, {
      page: annotation.annotationPageLabel,
      annotation: annotation.key
    }),
    source: "zotero"
  };
  if (annotation.annotationText) {
    annot.annotatedText = annotation.annotationText;
  }
  if (annotation.annotationComment) {
    annot.comment = annotation.annotationComment;
  }
  if (annotation.annotationImagePath) {
    const parsed = import_path5.default.parse(annotation.annotationImagePath);
    annot.imageBaseName = `${imageBaseName}-${annot.page}-x${Math.round(
      annot.x
    )}-y${Math.round(annot.y)}${parsed.ext}`;
    annot.imageRelativePath = (0, import_obsidian10.normalizePath)(
      import_path5.default.join(imageRelativePath, annot.imageBaseName)
    );
    annot.imageExtension = parsed.ext.slice(1);
    const imagePath = import_path5.default.join(imageOutputPath, annot.imageBaseName);
    if (copy2) {
      if (!(0, import_fs3.existsSync)(imageOutputPath)) {
        (0, import_fs3.mkdirSync)(imageOutputPath, { recursive: true });
      }
      try {
        (0, import_fs3.copyFileSync)(
          import_path5.default.join(parsed.dir, `${annotation.key}${parsed.ext}`),
          imagePath
        );
      } catch (e3) {
        new import_obsidian10.Notice(
          "Error: unable to copy annotation image from Zotero into your vault",
          7e3
        );
        console.error(e3);
      }
    }
    annot.imagePath = imagePath;
  }
  if ((_a2 = annotation.tags) == null ? void 0 : _a2.length) {
    annot.tags = annotation.tags;
    annot.allTags = annotation.tags.map((t3) => t3.tag).join(", ");
    annot.hashTags = annotation.tags.map((t3) => `#${t3.tag.replace(/\s+/g, "-")}`).join(", ");
  }
  return annot;
}
function concatAnnotations(annots) {
  const output = [];
  const re = /^\+\s*/;
  annots.forEach((a3) => {
    if (typeof a3.comment === "string" && re.test(a3.comment)) {
      a3.comment = a3.comment.replace(re, "");
      const last = output[output.length - 1];
      if (last) {
        last.annotatedText = last.annotatedText ? last.annotatedText + "..." + a3.annotatedText : a3.annotatedText;
        last.comment = last.comment ? last.comment + "..." + a3.comment : a3.comment;
        return;
      }
    }
    output.push(a3);
  });
  return output;
}
async function getRelations(item, importDate, database, cslStyle) {
  var _a2;
  if (!((_a2 = item.relations) == null ? void 0 : _a2.length))
    return [];
  const libId = item.libraryID;
  const relatedItems = await getItemJSONFromRelations(
    libId,
    item.relations,
    database
  );
  for (let i4 = 0, len = relatedItems.length; i4 < len; i4++) {
    const item2 = relatedItems[i4];
    if (getCiteKeyFromAny(item2)) {
      await processItem(item2, importDate, database, cslStyle, true);
    }
  }
  return relatedItems;
}
async function processItem(item, importDate, database, cslStyle, skipRelations) {
  const citekey = getCiteKeyFromAny(item);
  item.importDate = importDate;
  item.exportDate = importDate;
  item.desktopURI = item.select || getLocalURI("select", item.uri, item.itemKey);
  if (item.accessDate) {
    item.accessDate = (0, import_obsidian10.moment)(item.accessDate);
  }
  if (item.dateAdded) {
    item.dateAdded = (0, import_obsidian10.moment)(item.dateAdded);
  }
  if (item.dateModified) {
    item.dateModified = (0, import_obsidian10.moment)(item.dateModified);
  }
  if (citekey) {
    if (!item.citekey) {
      item.citekey = citekey.key;
    }
    if (!item.citationKey) {
      item.citationKey = citekey.key;
    }
    try {
      item.date = await getIssueDateFromCiteKey(citekey, database);
    } catch (e3) {
    }
    try {
      item.collections = await getCollectionFromCiteKey(citekey, database);
    } catch (e3) {
    }
    try {
      item.bibliography = await getBibFromCiteKey(citekey, database, cslStyle);
    } catch (e3) {
      item.bibliography = "Error generating bibliography";
    }
  }
  if (item.notes) {
    for (const note of item.notes) {
      await processNote(citekey, note);
    }
  }
  if (item.attachments) {
    for (const attachment of item.attachments) {
      processAttachment(attachment);
    }
  }
  if (!skipRelations) {
    item.relations = await getRelations(item, importDate, database, cslStyle);
  }
}
function generateHelpfulTemplateError(e3, template2) {
  const message = e3.message;
  try {
    if (message) {
      const match2 = message.match(/\[Line (\d+), Column (\d+)]/);
      if (match2) {
        const lines = template2.split(/\n/g);
        const line2 = lines[Number(match2[1]) - 1];
        const indicator = " ".repeat(Number(match2[2]) - 1) + "^";
        return `${message}

${line2}
${indicator}`;
      }
    }
  } catch (e4) {
  }
  return message;
}
function errorToHelpfulNotification(e3, templatePath, template2) {
  new import_obsidian10.Notice(
    createFragment((f4) => {
      f4.createSpan({
        text: `Error parsing template "${templatePath}": `
      });
      f4.createEl("code", {
        text: generateHelpfulTemplateError(e3, template2)
      });
    }),
    1e4
  );
}
function errorToHelpfulError(e3, templatePath, template2) {
  return new Error(
    `Error parsing template "${templatePath}": ${generateHelpfulTemplateError(
      e3,
      template2
    )}`
  );
}
async function renderTemplates(params, templateData, existingAnnotations, shouldThrow) {
  const { template: template2, headerTemplate, annotationTemplate, footerTemplate } = await getTemplates(params);
  if (!template2 && !headerTemplate && !annotationTemplate && !footerTemplate) {
    throw new Error(
      `No templates found for export ${params.exportFormat.name}`
    );
  }
  let main = "";
  if (template2) {
    try {
      main = template2 ? await renderTemplate(
        params.exportFormat.templatePath,
        template2,
        templateData
      ) : "";
    } catch (e3) {
      if (shouldThrow) {
        throw errorToHelpfulError(
          e3,
          params.exportFormat.templatePath,
          template2
        );
      } else {
        errorToHelpfulNotification(
          e3,
          params.exportFormat.templatePath,
          template2
        );
        return false;
      }
    }
    return appendExportDate(main);
  }
  let header = "";
  let annotations = "";
  let footer = "";
  try {
    header = headerTemplate ? await renderTemplate(
      params.exportFormat.headerTemplatePath,
      headerTemplate,
      templateData
    ) : "";
  } catch (e3) {
    if (shouldThrow) {
      throw errorToHelpfulError(
        e3,
        params.exportFormat.headerTemplatePath,
        headerTemplate
      );
    } else {
      errorToHelpfulNotification(
        e3,
        params.exportFormat.headerTemplatePath,
        headerTemplate
      );
      return false;
    }
  }
  try {
    annotations = annotationTemplate ? await renderTemplate(
      params.exportFormat.annotationTemplatePath,
      annotationTemplate,
      templateData
    ) : "";
  } catch (e3) {
    if (shouldThrow) {
      throw errorToHelpfulError(
        e3,
        params.exportFormat.annotationTemplatePath,
        annotationTemplate
      );
    } else {
      errorToHelpfulNotification(
        e3,
        params.exportFormat.annotationTemplatePath,
        annotationTemplate
      );
      return false;
    }
  }
  try {
    footer = footerTemplate ? await renderTemplate(
      params.exportFormat.footerTemplatePath,
      footerTemplate,
      templateData
    ) : "";
  } catch (e3) {
    if (shouldThrow) {
      throw errorToHelpfulError(
        e3,
        params.exportFormat.footerTemplatePath,
        footerTemplate
      );
    } else {
      errorToHelpfulNotification(
        e3,
        params.exportFormat.footerTemplatePath,
        footerTemplate
      );
      return false;
    }
  }
  const output = [];
  if (headerTemplate && header.trim()) {
    output.push(header);
  }
  const haveAnnotations = annotationTemplate && (existingAnnotations + annotations).trim();
  if (haveAnnotations) {
    output.push(wrapAnnotationTemplate(existingAnnotations + annotations));
  }
  if (footerTemplate && footer.trim()) {
    output.push(footer);
  }
  return haveAnnotations ? appendExportDate(output.join("")) : output.join("");
}
function getATemplatePath({ exportFormat }) {
  return exportFormat.templatePath || exportFormat.headerTemplatePath || exportFormat.annotationTemplatePath || exportFormat.footerTemplatePath || "";
}
async function exportToMarkdown(params) {
  var _a2, _b;
  const importDate = (0, import_obsidian10.moment)();
  const { database, exportFormat, settings } = params;
  const sourcePath = getATemplatePath(params);
  const canExtract = doesEXEExist();
  const citeKeys = await getCiteKeys(database);
  if (!citeKeys.length)
    return [];
  const libraryID = citeKeys[0].library;
  let itemData;
  try {
    itemData = await getItemJSONFromCiteKeys(citeKeys, database, libraryID);
  } catch (e3) {
    return [];
  }
  const createdOrUpdatedMarkdownFiles = [];
  for (let i4 = 0, len = itemData.length; i4 < len; i4++) {
    await processItem(itemData[i4], importDate, database, exportFormat.cslStyle);
  }
  const vaultRoot = getVaultRoot();
  for (let i4 = 0, len = itemData.length; i4 < len; i4++) {
    const attachments = itemData[i4].attachments;
    const hasPDF = attachments.some((a3) => {
      var _a3;
      return (_a3 = a3.path) == null ? void 0 : _a3.endsWith(".pdf");
    });
    if (!hasPDF) {
      const pathTemplateData = await applyBasicTemplates(sourcePath, {
        ...itemData[i4],
        annotations: []
      });
      const markdownPath = (0, import_obsidian10.normalizePath)(
        sanitizeFilePath(
          removeStartingSlash(
            await renderTemplate(
              sourcePath,
              exportFormat.outputPathTemplate,
              pathTemplateData
            )
          )
        )
      );
      const existingMarkdownFile = app.vault.getAbstractFileByPath(markdownPath);
      let existingMarkdown = "";
      let lastImportDate = (0, import_obsidian10.moment)(0);
      if (existingMarkdownFile) {
        existingMarkdown = await app.vault.cachedRead(
          existingMarkdownFile
        );
        lastImportDate = getLastExport(existingMarkdown);
      }
      const isFirstImport = lastImportDate.valueOf() === 0;
      const templateData = await applyBasicTemplates(
        markdownPath,
        {
          ...itemData[i4],
          annotations: [],
          lastImportDate,
          isFirstImport,
          // legacy
          lastExportDate: lastImportDate
        }
      );
      const rendered = await renderTemplates(
        params,
        PersistExtension.prepareTemplateData(templateData, existingMarkdown),
        ""
      );
      if (!rendered)
        return [];
      if (existingMarkdown) {
        app.vault.modify(existingMarkdownFile, rendered);
      } else {
        await mkMDDir(markdownPath);
        app.vault.create(markdownPath, rendered);
      }
      createdOrUpdatedMarkdownFiles.push(markdownPath);
      continue;
    }
    let mappedAttachments = {};
    try {
      const citekey = getCiteKeyFromAny(itemData[i4]);
      if (citekey) {
        const fullAttachmentData = await getAttachmentsFromCiteKey(
          citekey,
          database
        );
        mappedAttachments = (fullAttachmentData || []).reduce((col, a3) => {
          if (a3 == null ? void 0 : a3.path) {
            col[a3.path] = a3;
          }
          return col;
        }, {});
      }
    } catch (e3) {
    }
    for (let j4 = 0, jLen = attachments.length; j4 < jLen; j4++) {
      const pdfInputPath = attachments[j4].path;
      if (!(pdfInputPath == null ? void 0 : pdfInputPath.endsWith(".pdf")))
        continue;
      const pathTemplateData = await applyBasicTemplates(sourcePath, {
        ...attachments[j4],
        ...itemData[i4]
      });
      const imageRelativePath = exportFormat.imageOutputPathTemplate ? (0, import_obsidian10.normalizePath)(
        sanitizeFilePath(
          removeStartingSlash(
            await renderTemplate(
              sourcePath,
              exportFormat.imageOutputPathTemplate,
              pathTemplateData
            )
          )
        )
      ) : "";
      const imageOutputPath = import_path5.default.resolve(vaultRoot, imageRelativePath);
      const imageBaseName = exportFormat.imageBaseNameTemplate ? sanitizeFilePath(
        removeStartingSlash(
          await renderTemplate(
            sourcePath,
            exportFormat.imageBaseNameTemplate,
            pathTemplateData
          )
        )
      ) : "image";
      const markdownPath = (0, import_obsidian10.normalizePath)(
        sanitizeFilePath(
          removeStartingSlash(
            await renderTemplate(
              sourcePath,
              exportFormat.outputPathTemplate,
              pathTemplateData
            )
          )
        )
      );
      const existingMarkdownFile = app.vault.getAbstractFileByPath(markdownPath);
      let existingMarkdown = "";
      let lastImportDate = (0, import_obsidian10.moment)(0);
      let existingAnnotations = "";
      if (existingMarkdownFile) {
        existingMarkdown = await app.vault.cachedRead(
          existingMarkdownFile
        );
        lastImportDate = getLastExport(existingMarkdown);
        existingAnnotations = getExistingAnnotations(existingMarkdown);
      }
      const isFirstImport = lastImportDate.valueOf() === 0;
      let annots = [];
      (_b = (_a2 = mappedAttachments[attachments[j4].path]) == null ? void 0 : _a2.annotations) == null ? void 0 : _b.forEach(
        (annot) => {
          var _a3;
          if (!((_a3 = annot.annotationPosition.rects) == null ? void 0 : _a3.length))
            return;
          annots.push(
            convertNativeAnnotation(
              annot,
              attachments[j4],
              imageOutputPath,
              imageRelativePath,
              imageBaseName,
              true
            )
          );
        }
      );
      if (settings.shouldConcat && annots.length) {
        annots = concatAnnotations(annots);
      }
      if (canExtract) {
        try {
          const res = await extractAnnotations(pdfInputPath, {
            imageBaseName,
            imageDPI: settings.pdfExportImageDPI,
            imageFormat: settings.pdfExportImageFormat,
            imageOutputPath,
            imageQuality: settings.pdfExportImageQuality,
            attemptOCR: settings.pdfExportImageOCR,
            ocrLang: settings.pdfExportImageOCRLang,
            tesseractPath: settings.pdfExportImageTesseractPath,
            tessDataDir: settings.pdfExportImageTessDataDir
          });
          let extracted = JSON.parse(res);
          extracted.forEach((a3) => {
            processAnnotation(a3, attachments[j4], imageRelativePath);
          });
          if (settings.shouldConcat && extracted.length) {
            extracted = concatAnnotations(extracted);
          }
          annots.push(...extracted);
        } catch (e3) {
          return [];
        }
      }
      if (annots.length) {
        attachments[j4].annotations = annots;
      }
      const templateData = await applyBasicTemplates(
        markdownPath,
        {
          ...itemData[i4],
          annotations: annots ? annots : [],
          lastImportDate,
          isFirstImport,
          // legacy
          lastExportDate: lastImportDate
        }
      );
      const rendered = await renderTemplates(
        params,
        PersistExtension.prepareTemplateData(templateData, existingMarkdown),
        existingAnnotations
      );
      if (!rendered)
        return [];
      if (existingMarkdownFile) {
        app.vault.modify(existingMarkdownFile, rendered);
      } else {
        await mkMDDir(markdownPath);
        app.vault.create(markdownPath, rendered);
      }
      createdOrUpdatedMarkdownFiles.push(markdownPath);
    }
  }
  return createdOrUpdatedMarkdownFiles;
}
async function renderCiteTemplate(params) {
  const importDate = (0, import_obsidian10.moment)();
  const { database, format: format3 } = params;
  const citeKeys = await getCiteKeys(database);
  if (!citeKeys.length)
    return null;
  const libraryID = citeKeys[0].library;
  let itemData;
  try {
    itemData = await getItemJSONFromCiteKeys(citeKeys, database, libraryID);
  } catch (e3) {
    return null;
  }
  if (itemData.length === 0) {
    return null;
  }
  const output = [];
  for (let i4 = 0, len = itemData.length; i4 < len; i4++) {
    await processItem(itemData[i4], importDate, database, format3.cslStyle);
    const attachments = itemData[i4].attachments || [];
    const firstPDF = attachments.find((a3) => {
      var _a2;
      return !!((_a2 = a3.path) == null ? void 0 : _a2.endsWith(".pdf"));
    });
    const templateData = {
      attachment: firstPDF || attachments.length ? attachments[0] : null,
      ...itemData[i4]
    };
    output.push(await renderTemplate("", format3.template, templateData));
  }
  return output.join(" ");
}
function getAStyle(settings) {
  const exportStyle = settings.exportFormats.find((f4) => !!f4.cslStyle);
  if (exportStyle) {
    return exportStyle.cslStyle;
  }
  const citeStyle = settings.citeFormats.find((f4) => !!f4.cslStyle);
  if (citeStyle) {
    return citeStyle.cslStyle;
  }
}
async function dataExplorerPrompt(settings) {
  var _a2, _b;
  const database = { database: settings.database, port: settings.port };
  const citeKeys = await getCiteKeys(database);
  const canExtract = doesEXEExist();
  if (!citeKeys.length)
    return null;
  const libraryID = citeKeys[0].library;
  let itemData;
  try {
    itemData = await getItemJSONFromCiteKeys(citeKeys, database, libraryID);
  } catch (e3) {
    return null;
  }
  const importDate = (0, import_obsidian10.moment)();
  const style = getAStyle(settings);
  for (let i4 = 0, len = itemData.length; i4 < len; i4++) {
    await processItem(itemData[i4], importDate, database, style);
  }
  const vaultRoot = getVaultRoot();
  for (let i4 = 0, len = itemData.length; i4 < len; i4++) {
    const attachments = itemData[i4].attachments;
    let mappedAttachments = {};
    try {
      const citekey = getCiteKeyFromAny(itemData[i4]);
      if (citekey) {
        const fullAttachmentData = await getAttachmentsFromCiteKey(
          citekey,
          database
        );
        mappedAttachments = (fullAttachmentData || []).reduce((col, a3) => {
          if (a3 == null ? void 0 : a3.path) {
            col[a3.path] = a3;
          }
          return col;
        }, {});
      }
    } catch (e3) {
      console.error(e3);
    }
    for (let j4 = 0, jLen = attachments.length; j4 < jLen; j4++) {
      const pdfInputPath = attachments[j4].path;
      if (!(pdfInputPath == null ? void 0 : pdfInputPath.endsWith(".pdf")))
        continue;
      let annots = [];
      (_b = (_a2 = mappedAttachments[attachments[j4].path]) == null ? void 0 : _a2.annotations) == null ? void 0 : _b.forEach(
        (annot) => {
          var _a3;
          if (!((_a3 = annot.annotationPosition.rects) == null ? void 0 : _a3.length))
            return;
          annots.push(
            convertNativeAnnotation(
              annot,
              attachments[j4],
              import_path5.default.join(vaultRoot, "output_path"),
              "base_name",
              "output_path"
            )
          );
        }
      );
      if (settings.shouldConcat && annots.length) {
        annots = concatAnnotations(annots);
      }
      if (canExtract) {
        try {
          const res = await extractAnnotations(pdfInputPath, {
            noWrite: true,
            imageBaseName: "base_name",
            imageDPI: settings.pdfExportImageDPI,
            imageFormat: settings.pdfExportImageFormat,
            imageOutputPath: import_path5.default.join(vaultRoot, "output_path"),
            imageQuality: settings.pdfExportImageQuality,
            attemptOCR: settings.pdfExportImageOCR,
            ocrLang: settings.pdfExportImageOCRLang,
            tesseractPath: settings.pdfExportImageTesseractPath,
            tessDataDir: settings.pdfExportImageTessDataDir
          });
          let extracted = JSON.parse(res);
          extracted.forEach((a3) => {
            processAnnotation(a3, attachments[j4], "output_path");
          });
          if (settings.shouldConcat && extracted.length) {
            extracted = concatAnnotations(extracted);
          }
          annots.push(...extracted);
        } catch (e3) {
          return false;
        }
      }
      if (annots.length) {
        attachments[j4].annotations = annots;
      }
    }
  }
  await Promise.all(
    itemData.map(async (data) => {
      const firstPDF = data.attachments.find(
        (a3) => {
          var _a3;
          return (_a3 = a3.path) == null ? void 0 : _a3.endsWith(".pdf");
        }
      );
      data.annotations = (firstPDF == null ? void 0 : firstPDF.annotations) ? firstPDF.annotations : [];
      data.lastImportDate = (0, import_obsidian10.moment)(0);
      data.isFirstImport = true;
      data.lastExportDate = (0, import_obsidian10.moment)(0);
      await applyBasicTemplates("", data);
    })
  );
  return itemData;
}

// src/DataExplorerView.tsx
var viewType = "zdc-debug";
var tomorrowLight = {
  scheme: "Tomorrow",
  author: "Chris Kempson (http://chriskempson.com)",
  base00: "#ffffff",
  base01: "#e0e0e0",
  base02: "#d6d6d6",
  base03: "#8e908c",
  base04: "#969896",
  base05: "#4d4d4c",
  base06: "#282a2e",
  base07: "#1d1f21",
  base08: "#c82829",
  base09: "#f5871f",
  base0A: "#eab700",
  base0B: "#718c00",
  base0C: "#3e999f",
  base0D: "#4271ae",
  base0E: "#8959a8",
  base0F: "#a3685a"
};
var tomorrowDark = {
  scheme: "Tomorrow Night",
  author: "Chris Kempson (http://chriskempson.com)",
  base00: "#1d1f21",
  base01: "#282a2e",
  base02: "#373b41",
  base03: "#969896",
  base04: "#b4b7b4",
  base05: "#c5c8c6",
  base06: "#e0e0e0",
  base07: "#ffffff",
  base08: "#cc6666",
  base09: "#de935f",
  base0A: "#f0c674",
  base0B: "#b5bd68",
  base0C: "#8abeb7",
  base0D: "#81a2be",
  base0E: "#b294bb",
  base0F: "#a3685a"
};
function TemplatePreview({
  plugin,
  formatIndex,
  templateData
}) {
  const [templateError, setTemplateError] = Cn.useState(null);
  const [template2, setTemplate] = Cn.useState(null);
  const [forceRef, setForceRef] = Cn.useState(0);
  Cn.useEffect(() => {
    const fmt = plugin.settings.exportFormats[formatIndex];
    const mainFile = fmt.templatePath ? plugin.app.vault.getAbstractFileByPath(
      sanitizeObsidianPath(fmt.templatePath)
    ) : null;
    const onUpdate = (file) => {
      if (!file)
        return;
      if (file === mainFile) {
        setForceRef(Date.now());
      }
    };
    const onSettingsUpdate = () => {
      setForceRef(Date.now());
    };
    plugin.emitter.on("fileUpdated", onUpdate);
    plugin.emitter.on("settingsUpdated", onSettingsUpdate);
    return () => {
      plugin.emitter.off("fileUpdated", onUpdate);
      plugin.emitter.off("settingsUpdated", onSettingsUpdate);
    };
  }, [formatIndex]);
  Cn.useEffect(() => {
    setTemplateError(null);
    if (formatIndex === null)
      return;
    const params = {
      settings: plugin.settings,
      database: {
        database: plugin.settings.database,
        port: plugin.settings.port
      },
      exportFormat: plugin.settings.exportFormats[formatIndex]
    };
    const render = async () => {
      const sourcePath = getATemplatePath(params);
      try {
        const renderedPath = await renderTemplate(
          sourcePath,
          params.exportFormat.outputPathTemplate,
          templateData
        );
        const markdownPath = (0, import_obsidian11.normalizePath)(
          sanitizeFilePath(removeStartingSlash(renderedPath))
        );
        const existingMarkdownFile = app.vault.getAbstractFileByPath(markdownPath);
        let existingMarkdown = "";
        let lastImportDate = (0, import_obsidian11.moment)(0);
        if (existingMarkdownFile) {
          existingMarkdown = await app.vault.cachedRead(
            existingMarkdownFile
          );
          lastImportDate = getLastExport(existingMarkdown);
        }
        const output = await renderTemplates(
          params,
          PersistExtension.prepareTemplateData(
            {
              ...templateData,
              lastImportDate,
              // legacy
              lastExportDate: lastImportDate
            },
            existingMarkdown
          ),
          "",
          true
        );
        setTemplate(output ? output : null);
      } catch (e3) {
        setTemplateError(e3.message);
      }
    };
    render();
  }, [formatIndex, forceRef]);
  if (!template2 && !templateError)
    return null;
  return /* @__PURE__ */ Cn.createElement("div", { className: `zt-json-viewer__preview${templateError ? " error" : ""}` }, /* @__PURE__ */ Cn.createElement("pre", null, /* @__PURE__ */ Cn.createElement("code", null, templateError || template2)));
}
function DataExporer({ plugin }) {
  const [error, setError] = Cn.useState(null);
  const [data, setData] = Cn.useState(null);
  const [previewFormatIndex, setPreviewFormatIndex] = Cn.useState(null);
  const promptForSelection = Cn.useCallback(() => {
    dataExplorerPrompt(plugin.settings).then((res) => {
      if (!res || res.length === 0) {
        setError("No data retrieved");
      } else {
        setError(null);
        setData(res[0]);
      }
    });
  }, []);
  return /* @__PURE__ */ Cn.createElement("div", { className: "zt-json-viewer" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-json-viewer__btns" }, /* @__PURE__ */ Cn.createElement("div", null, /* @__PURE__ */ Cn.createElement("button", { onClick: promptForSelection }, "Prompt For Selection")), /* @__PURE__ */ Cn.createElement("div", null, /* @__PURE__ */ Cn.createElement(
    "select",
    {
      className: "dropdown",
      onChange: (e3) => {
        if (e3.target.value) {
          setPreviewFormatIndex(
            Number(e3.target.value)
          );
        } else {
          setPreviewFormatIndex(null);
        }
      }
    },
    /* @__PURE__ */ Cn.createElement("option", { value: "" }, "Preview Import Format"),
    plugin.settings.exportFormats.map((e3, index2) => {
      return /* @__PURE__ */ Cn.createElement("option", { key: index2, value: index2 }, e3.name);
    })
  ))), error ? /* @__PURE__ */ Cn.createElement("div", null, error) : /* @__PURE__ */ Cn.createElement("div", null, data && /* @__PURE__ */ Cn.createElement(Cn.Fragment, null, previewFormatIndex !== null && /* @__PURE__ */ Cn.createElement(
    TemplatePreview,
    {
      plugin,
      formatIndex: previewFormatIndex,
      templateData: data
    }
  ), /* @__PURE__ */ Cn.createElement("div", { className: "zt-json-viewer__data" }, /* @__PURE__ */ Cn.createElement(
    JSONTree,
    {
      data,
      sortObjectKeys: (a3, b4) => a3.localeCompare(b4),
      isCustomNode: (v4) => v4 instanceof import_obsidian11.moment,
      valueRenderer: (v4) => {
        if (v4 instanceof import_obsidian11.moment) {
          return `moment(${v4.toLocaleString()})`;
        }
        if (typeof v4 === "string" && v4.length > 800) {
          return v4.slice(0, 800) + "...";
        }
        return v4;
      },
      labelRenderer: (keyPath) => {
        return keyPath.length === 1 ? "Template Data" : keyPath[0];
      },
      theme: document.body.hasClass("theme-dark") ? tomorrowDark : tomorrowLight,
      invertTheme: false
    }
  )))));
}
var DataExplorerView = class extends import_obsidian11.ItemView {
  constructor(plugin, leaf) {
    super(leaf);
    this.plugin = plugin;
    this.mountJsonViewer();
  }
  getViewType() {
    return viewType;
  }
  getIcon() {
    return "gear";
  }
  getDisplayText() {
    return "Zotero Data Explorer";
  }
  mountJsonViewer() {
    Cn.unmountComponentAtNode(this.contentEl);
    Cn.render(/* @__PURE__ */ Cn.createElement(DataExporer, { plugin: this.plugin }), this.contentEl);
  }
  unmountJsonViewer() {
    Cn.unmountComponentAtNode(this.contentEl);
  }
  async onClose() {
    this.unmountJsonViewer();
  }
};

// node_modules/fuse.js/dist/fuse.esm.js
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path8 = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path8 = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path8 = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path: path8, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path8) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path9, index2) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path9[index2]) {
      list.push(obj2);
    } else {
      let key = path9[index2];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index2 === path9.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i4 = 0, len = value.length; i4 < len; i4 += 1) {
          deepGet(value[i4], path9, index2 + 1);
        }
      } else if (path9.length) {
        deepGet(value, path9, index2 + 1);
      }
    }
  };
  deepGet(obj, isString(path8) ? path8.split(".") : path8, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a3, b4) => a3.score === b4.score ? a3.idx < b4.idx ? -1 : 1 : a3.score < b4.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m4 = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n3 = parseFloat(Math.round(norm2 * m4) / m4);
      cache.set(numTokens, n3);
      return n3;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i4 = idx, len = this.size(); i4 < len; i4 += 1) {
      this.records[i4].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k4) => {
              stack.push({
                nestedArrIndex: k4,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i4 = 0;
  for (let len = matchmask.length; i4 < len; i4 += 1) {
    let match2 = matchmask[i4];
    if (match2 && start === -1) {
      start = i4;
    } else if (!match2 && start !== -1) {
      end = i4 - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i4 - 1] && i4 - start >= minMatchCharLength) {
    indices.push([start, i4 - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i4 = 0;
      while (i4 < patternLen) {
        matchMask[index2 + i4] = 1;
        i4 += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i4 = 0; i4 < patternLen; i4 += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i4,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i4) - 1;
    for (let j4 = finish; j4 >= start; j4 -= 1) {
      let currentLocation = j4 - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j4] = (bitArr[j4 + 1] << 1 | 1) & charMatch;
      if (i4) {
        bitArr[j4] |= (lastBitArr[j4 + 1] | lastBitArr[j4]) << 1 | 1 | lastBitArr[j4 + 1];
      }
      if (bitArr[j4] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i4,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i4 + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i4 = 0, len = pattern.length; i4 < len; i4 += 1) {
    const char2 = pattern.charAt(i4);
    mask[char2] = (mask[char2] || 0) | 1 << len - i4 - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i4 = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i4 < end) {
        addChunk(this.pattern.substr(i4, MAX_BITS), i4);
        i4 += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index2 = text.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text.indexOf(this.pattern, location)) > -1) {
      location = index2 + patternLen;
      indices.push([index2, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options3 = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i4 = 0, len = query.length; i4 < len; i4 += 1) {
      const queryItem = query[i4];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token2 = searcher.isMultiMatch(queryItem);
        if (token2) {
          results.push(new searcher(token2, options3));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token2 = searcher.isSingleMatch(queryItem);
        if (token2) {
          results.push(new searcher(token2, options3));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_3, options3) {
    return options3.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i4 = 0, qLen = query.length; i4 < qLen; i4 += 1) {
      const searchers2 = query[i4];
      allIndices.length = 0;
      numMatches = 0;
      for (let j4 = 0, pLen = searchers2.length; j4 < pLen; j4 += 1) {
        const searcher = searchers2[j4];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args2) {
  registeredSearchers.push(...args2);
}
function createSearcher(pattern, options3) {
  for (let i4 = 0, len = registeredSearchers.length; i4 < len; i4 += 1) {
    let searcherClass = registeredSearchers[i4];
    if (searcherClass.condition(pattern, options3)) {
      return new searcherClass(pattern, options3);
    }
  }
  return new BitapSearch(pattern, options3);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options3, { auto = true } = {}) {
  const next2 = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next2(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options3);
      }
      return obj;
    }
    let node2 = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node2.children.push(next2(item));
        });
      }
    });
    return node2;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next2(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match2) => {
    if (!isDefined(match2.indices) || !match2.indices.length) {
      return;
    }
    const { indices, value } = match2;
    let obj = {
      indices,
      value
    };
    if (match2.key) {
      obj.key = match2.key.src;
    }
    if (match2.idx > -1) {
      obj.refIndex = match2.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format2(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options3 = {}, index2) {
    this.options = { ...Config, ...options3 };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i4 = 0, len = this._docs.length; i4 < len; i4 += 1) {
      const doc = this._docs[i4];
      if (predicate(doc, i4)) {
        this.removeAt(i4);
        i4 -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format2(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node2, item, idx) => {
      if (!node2.children) {
        const { keyId, searcher } = node2;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i4 = 0, len = node2.children.length; i4 < len; i4 += 1) {
        const child = node2.children[i4];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node2.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/citeSuggest/citeSuggest.ts
var import_nunjucks2 = __toESM(require_nunjucks());
var import_obsidian12 = require("obsidian");
var CiteSuggest = class extends import_obsidian12.EditorSuggest {
  constructor(app2, plugin) {
    super(app2);
    this.limit = 20;
    this.haveSearchableItems = false;
    this.handleSearch = (0, import_obsidian12.debounce)(
      async () => {
        const context = this.context;
        if (context === null)
          return;
        const { citekeys, fromCache } = await getAllCiteKeys({
          database: this.plugin.settings.database,
          port: this.plugin.settings.port
        });
        if (context !== this.context)
          return;
        if (!fromCache || !this.haveSearchableItems) {
          this.fuse.setCollection(citekeys);
          this.haveSearchableItems = true;
          const results = this.fuse.search(context.query, { limit: this.limit });
          this.showSuggestions(results);
        }
      },
      200,
      true
    );
    this.app = app2;
    this.plugin = plugin;
    this.scope.register(["Mod"], "Enter", (evt) => {
      this.suggestions.useSelectedItem(evt);
      return false;
    });
    this.scope.register(["Alt"], "Enter", (evt) => {
      this.suggestions.useSelectedItem(evt);
      return false;
    });
    this.setInstructions([
      {
        command: import_obsidian12.Platform.isMacOS ? "\u2318 \u21B5" : "ctrl \u21B5",
        purpose: "Wrap cite key with brackets"
      },
      {
        command: import_obsidian12.Platform.isMacOS ? "\u2325 \u21B5" : "alt \u21B5",
        purpose: "Insert using template"
      }
    ]);
    this.fuse = new Fuse([], {
      includeMatches: true,
      threshold: 0.35,
      keys: [
        { name: "citekey", weight: 0.7 },
        { name: "title", weight: 0.3 }
      ]
    });
  }
  async getSuggestions(context) {
    if (!context.query || context.query.includes(" ")) {
      return null;
    }
    if (!await isZoteroRunning({
      database: this.plugin.settings.database,
      port: this.plugin.settings.port
    }, true)) {
      return null;
    }
    this.handleSearch();
    return this.haveSearchableItems ? this.fuse.search(context.query, { limit: this.limit }) : [{ loading: true }];
  }
  renderSuggestion(suggestion, el) {
    const frag = createFragment();
    if (suggestion.loading) {
      frag.createSpan({ cls: "zt-suggest-loading-wrapper" }).createSpan({ cls: "zt-suggest-loading" });
      el.setText(frag);
      return;
    }
    const sugg = suggestion;
    const item = sugg.item;
    if (!sugg.matches || !sugg.matches.length) {
      frag.createSpan({ text: `@${item.citekey}` });
      frag.createSpan({ text: item.title, cls: "zt-suggest-title" });
      return el.setText(frag);
    }
    const citekey = frag.createSpan({ text: "@" });
    const title = frag.createSpan("zt-suggest-title");
    let prevTitleIndex = 0;
    let prevCiteIndex = 0;
    sugg.matches.forEach((m4) => {
      m4.indices.forEach((indices) => {
        const start = indices[0];
        const stop = indices[1] + 1;
        const target = m4.key === "title" ? title : citekey;
        const prev2 = m4.key === "title" ? prevTitleIndex : prevCiteIndex;
        target.appendText(m4.value.substring(prev2, start));
        target.append(
          createEl("strong", {
            text: m4.value.substring(start, stop)
          })
        );
        if (m4.key === "title") {
          prevTitleIndex = stop;
        } else {
          prevCiteIndex = stop;
        }
      });
    });
    title.appendText(item.title.substring(prevTitleIndex));
    citekey.appendText(item.citekey.substring(prevCiteIndex));
    el.setText(frag);
  }
  selectSuggestion(suggestion, event) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian12.MarkdownView);
    if (!activeView) {
      return;
    }
    let replaceStr = "";
    if (event.metaKey || event.ctrlKey) {
      replaceStr = `[@${suggestion.item.citekey}]`;
    } else if (event.altKey) {
      const template2 = this.plugin.settings.citeSuggestTemplate;
      replaceStr = import_nunjucks2.default.renderString(template2, {
        citekey: suggestion.item.citekey
      });
    } else {
      replaceStr = `@${suggestion.item.citekey}`;
    }
    activeView.editor.replaceRange(
      replaceStr,
      this.context.start,
      this.context.end
    );
    this.close();
  }
  onTrigger(cursor2, editor) {
    var _a2;
    if (!this.plugin.settings.shouldShowCiteSuggest) {
      return null;
    }
    const triggerPhrase = "@";
    let startPos = ((_a2 = this.context) == null ? void 0 : _a2.start) || {
      line: cursor2.line,
      ch: cursor2.ch - triggerPhrase.length
    };
    if (!editor.getRange(startPos, cursor2).startsWith(triggerPhrase)) {
      const restartPos = {
        line: cursor2.line,
        ch: cursor2.ch - (triggerPhrase.length + 1)
      };
      if (this.context || !editor.getRange(restartPos, cursor2).startsWith(triggerPhrase)) {
        return null;
      }
      startPos = restartPos;
    }
    const precedingChar = editor.getRange(
      {
        line: startPos.line,
        ch: startPos.ch - 1
      },
      startPos
    );
    if (precedingChar && !/[ .[;-]/.test(precedingChar)) {
      return null;
    }
    const query = editor.getRange(startPos, cursor2).substring(triggerPhrase.length);
    return {
      start: startPos,
      end: cursor2,
      query
    };
  }
};

// src/pandocReference/ReferenceListView.ts
var import_obsidian14 = require("obsidian");

// node_modules/lru-cache/dist/mjs/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn2) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn2) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
var _a;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", false);
    }
    addEventListener(_3, fn2) {
      this._onabort.push(fn2);
    }
  };
  AC = class AbortController {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      var _a2, _b;
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn2 of this.signal._onabort) {
        fn2(reason);
      }
      (_b = (_a2 = this.signal).onabort) == null ? void 0 : _b.call(_a2, reason);
    }
  };
  let printACPolyfillWarning = ((_a = PROCESS.env) == null ? void 0 : _a.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n3) => n3 && n3 === Math.floor(n3) && n3 > 0 && isFinite(n3);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class _Stack {
  constructor(max, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s5 = new _Stack(max, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s5;
  }
  push(n3) {
    this.heap[this.length++] = n3;
  }
  pop() {
    return this.heap[--this.length];
  }
};
_constructing = new WeakMap();
// private constructor
__privateAdd(_Stack, _constructing, false);
var Stack = _Stack;
var _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _initializeTTLTracking, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, _initializeSizeTracking, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, _indexes, indexes_fn, _rindexes, rindexes_fn, _isValidIndex, isValidIndex_fn, _evict, evict_fn, _backgroundFetch, backgroundFetch_fn, _isBackgroundFetch, isBackgroundFetch_fn, _connect, connect_fn, _moveToTail, moveToTail_fn;
var _LRUCache = class _LRUCache {
  constructor(options3) {
    __privateAdd(this, _initializeTTLTracking);
    __privateAdd(this, _initializeSizeTracking);
    __privateAdd(this, _indexes);
    __privateAdd(this, _rindexes);
    __privateAdd(this, _isValidIndex);
    __privateAdd(this, _evict);
    __privateAdd(this, _backgroundFetch);
    __privateAdd(this, _isBackgroundFetch);
    __privateAdd(this, _connect);
    __privateAdd(this, _moveToTail);
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    __privateAdd(this, _max, void 0);
    __privateAdd(this, _maxSize, void 0);
    __privateAdd(this, _dispose, void 0);
    __privateAdd(this, _disposeAfter, void 0);
    __privateAdd(this, _fetchMethod, void 0);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size, void 0);
    __privateAdd(this, _calculatedSize, void 0);
    __privateAdd(this, _keyMap, void 0);
    __privateAdd(this, _keyList, void 0);
    __privateAdd(this, _valList, void 0);
    __privateAdd(this, _next, void 0);
    __privateAdd(this, _prev, void 0);
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _free, void 0);
    __privateAdd(this, _disposed, void 0);
    __privateAdd(this, _sizes, void 0);
    __privateAdd(this, _starts, void 0);
    __privateAdd(this, _ttls, void 0);
    __privateAdd(this, _hasDispose, void 0);
    __privateAdd(this, _hasFetchMethod, void 0);
    __privateAdd(this, _hasDisposeAfter, void 0);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i) => {
    });
    __privateAdd(this, _addItemSize, (_i, _s, _st) => {
    });
    __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options3;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    __privateSet(this, _max, max);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max).fill(void 0));
    __privateSet(this, _valList, new Array(max).fill(void 0));
    __privateSet(this, _next, new UintArray(max));
    __privateSet(this, _prev, new UintArray(max));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _initializeSizeTracking, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c4) {
    return {
      // properties
      starts: __privateGet(c4, _starts),
      ttls: __privateGet(c4, _ttls),
      sizes: __privateGet(c4, _sizes),
      keyMap: __privateGet(c4, _keyMap),
      keyList: __privateGet(c4, _keyList),
      valList: __privateGet(c4, _valList),
      next: __privateGet(c4, _next),
      prev: __privateGet(c4, _prev),
      get head() {
        return __privateGet(c4, _head);
      },
      get tail() {
        return __privateGet(c4, _tail);
      },
      free: __privateGet(c4, _free),
      // methods
      isBackgroundFetch: (p5) => {
        var _a2;
        return __privateMethod(_a2 = c4, _isBackgroundFetch, isBackgroundFetch_fn).call(_a2, p5);
      },
      backgroundFetch: (k4, index2, options3, context) => {
        var _a2;
        return __privateMethod(_a2 = c4, _backgroundFetch, backgroundFetch_fn).call(_a2, k4, index2, options3, context);
      },
      moveToTail: (index2) => {
        var _a2;
        return __privateMethod(_a2 = c4, _moveToTail, moveToTail_fn).call(_a2, index2);
      },
      indexes: (options3) => {
        var _a2;
        return __privateMethod(_a2 = c4, _indexes, indexes_fn).call(_a2, options3);
      },
      rindexes: (options3) => {
        var _a2;
        return __privateMethod(_a2 = c4, _rindexes, rindexes_fn).call(_a2, options3);
      },
      isStale: (index2) => {
        var _a2;
        return __privateGet(_a2 = c4, _isStale).call(_a2, index2);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i4] !== void 0 && __privateGet(this, _keyList)[i4] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield [__privateGet(this, _keyList)[i4], __privateGet(this, _valList)[i4]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i4] !== void 0 && __privateGet(this, _keyList)[i4] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield [__privateGet(this, _keyList)[i4], __privateGet(this, _valList)[i4]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const k4 = __privateGet(this, _keyList)[i4];
      if (k4 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield k4;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const k4 = __privateGet(this, _keyList)[i4];
      if (k4 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield k4;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v4 = __privateGet(this, _valList)[i4];
      if (v4 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield __privateGet(this, _valList)[i4];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v4 = __privateGet(this, _valList)[i4];
      if (v4 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield __privateGet(this, _valList)[i4];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn2, getOptions = {}) {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v4 = __privateGet(this, _valList)[i4];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4) ? v4.__staleWhileFetching : v4;
      if (value === void 0)
        continue;
      if (fn2(value, __privateGet(this, _keyList)[i4], this)) {
        return this.get(__privateGet(this, _keyList)[i4], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn2, thisp = this) {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v4 = __privateGet(this, _valList)[i4];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4) ? v4.__staleWhileFetching : v4;
      if (value === void 0)
        continue;
      fn2.call(thisp, value, __privateGet(this, _keyList)[i4], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn2, thisp = this) {
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v4 = __privateGet(this, _valList)[i4];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4) ? v4.__staleWhileFetching : v4;
      if (value === void 0)
        continue;
      fn2.call(thisp, value, __privateGet(this, _keyList)[i4], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i4)) {
        this.delete(__privateGet(this, _keyList)[i4]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i4];
      const v4 = __privateGet(this, _valList)[i4];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4) ? v4.__staleWhileFetching : v4;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i4];
        const age = perf.now() - __privateGet(this, _starts)[i4];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i4];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k4, v4, setOptions = {}) {
    var _a2, _b, _c;
    if (v4 === void 0) {
      this.delete(k4);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = __privateGet(this, _requireSize).call(this, k4, v4, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k4);
      return this;
    }
    let index2 = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k4);
    if (index2 === void 0) {
      index2 = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _evict, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index2] = k4;
      __privateGet(this, _valList)[index2] = v4;
      __privateGet(this, _keyMap).set(k4, index2);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index2;
      __privateGet(this, _prev)[index2] = __privateGet(this, _tail);
      __privateSet(this, _tail, index2);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index2, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index2);
      const oldVal = __privateGet(this, _valList)[index2];
      if (v4 !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, oldVal, k4, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([oldVal, k4, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index2);
        __privateGet(this, _addItemSize).call(this, index2, size, status);
        __privateGet(this, _valList)[index2] = v4;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index2, ttl, start);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index2);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a2;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _evict, evict_fn).call(this, true);
        if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_a2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a2.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k4, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index2 = __privateGet(this, _keyMap).get(k4);
    if (index2 !== void 0) {
      const v4 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4) && v4.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index2)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index2);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index2);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k4, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index2 = __privateGet(this, _keyMap).get(k4);
    if (index2 !== void 0 && (allowStale || !__privateGet(this, _isStale).call(this, index2))) {
      const v4 = __privateGet(this, _valList)[index2];
      return __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4) ? v4.__staleWhileFetching : v4;
    }
  }
  async fetch(k4, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k4, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options3 = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = __privateGet(this, _keyMap).get(k4);
    if (index2 === void 0) {
      if (status)
        status.fetch = "miss";
      const p5 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k4, index2, options3, context);
      return p5.__returned = p5;
    } else {
      const v4 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4)) {
        const stale = allowStale && v4.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v4.__staleWhileFetching : v4.__returned = v4;
      }
      const isStale = __privateGet(this, _isStale).call(this, index2);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index2);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index2);
        return v4;
      }
      const p5 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k4, index2, options3, context);
      const hasStale = p5.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p5.__staleWhileFetching : p5.__returned = p5;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k4, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index2 = __privateGet(this, _keyMap).get(k4);
    if (index2 !== void 0) {
      const value = __privateGet(this, _valList)[index2];
      const fetching = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, value);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index2);
      if (__privateGet(this, _isStale).call(this, index2)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k4);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index2);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k4) {
    var _a2, _b, _c, _d;
    let deleted = false;
    if (__privateGet(this, _size) !== 0) {
      const index2 = __privateGet(this, _keyMap).get(k4);
      if (index2 !== void 0) {
        deleted = true;
        if (__privateGet(this, _size) === 1) {
          this.clear();
        } else {
          __privateGet(this, _removeItemSize).call(this, index2);
          const v4 = __privateGet(this, _valList)[index2];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4)) {
            v4.__abortController.abort(new Error("deleted"));
          } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
            if (__privateGet(this, _hasDispose)) {
              (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v4, k4, "delete");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([v4, k4, "delete"]);
            }
          }
          __privateGet(this, _keyMap).delete(k4);
          __privateGet(this, _keyList)[index2] = void 0;
          __privateGet(this, _valList)[index2] = void 0;
          if (index2 === __privateGet(this, _tail)) {
            __privateSet(this, _tail, __privateGet(this, _prev)[index2]);
          } else if (index2 === __privateGet(this, _head)) {
            __privateSet(this, _head, __privateGet(this, _next)[index2]);
          } else {
            __privateGet(this, _next)[__privateGet(this, _prev)[index2]] = __privateGet(this, _next)[index2];
            __privateGet(this, _prev)[__privateGet(this, _next)[index2]] = __privateGet(this, _prev)[index2];
          }
          __privateWrapper(this, _size)._--;
          __privateGet(this, _free).push(index2);
        }
      }
    }
    if (__privateGet(this, _hasDisposeAfter) && ((_c = __privateGet(this, _disposed)) == null ? void 0 : _c.length)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var _a2, _b, _c;
    for (const index2 of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      const v4 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4)) {
        v4.__abortController.abort(new Error("deleted"));
      } else {
        const k4 = __privateGet(this, _keyList)[index2];
        if (__privateGet(this, _hasDispose)) {
          (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v4, k4, "delete");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([v4, k4, "delete"]);
        }
      }
    }
    __privateGet(this, _keyMap).clear();
    __privateGet(this, _valList).fill(void 0);
    __privateGet(this, _keyList).fill(void 0);
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      __privateGet(this, _ttls).fill(0);
      __privateGet(this, _starts).fill(0);
    }
    if (__privateGet(this, _sizes)) {
      __privateGet(this, _sizes).fill(0);
    }
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateGet(this, _free).length = 0;
    __privateSet(this, _calculatedSize, 0);
    __privateSet(this, _size, 0);
    if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
      }
    }
  }
};
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_initializeTTLTracking = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index2, ttl, start = perf.now()) => {
    starts[index2] = ttl !== 0 ? start : 0;
    ttls[index2] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t3 = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index2)) {
          this.delete(__privateGet(this, _keyList)[index2]);
        }
      }, ttl + 1);
      if (t3.unref) {
        t3.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index2) => {
    starts[index2] = ttls[index2] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index2) => {
    if (ttls[index2]) {
      const ttl = ttls[index2];
      const start = starts[index2];
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      const age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n3 = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n3;
      const t3 = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t3.unref) {
        t3.unref();
      }
    }
    return n3;
  };
  this.getRemainingTTL = (key) => {
    const index2 = __privateGet(this, _keyMap).get(key);
    if (index2 === void 0) {
      return 0;
    }
    const ttl = ttls[index2];
    const start = starts[index2];
    if (ttl === 0 || start === 0) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start;
    return ttl - age;
  };
  __privateSet(this, _isStale, (index2) => {
    return ttls[index2] !== 0 && starts[index2] !== 0 && (cachedNow || getNow()) - starts[index2] > ttls[index2];
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
_initializeSizeTracking = new WeakSet();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index2) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index2]);
    sizes[index2] = 0;
  });
  __privateSet(this, _requireSize, (k4, v4, size, sizeCalculation) => {
    if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4)) {
      return 0;
    }
    if (!isPosInt(size)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size = sizeCalculation(v4, k4);
        if (!isPosInt(size)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size;
  });
  __privateSet(this, _addItemSize, (index2, size, status) => {
    sizes[index2] = size;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index2];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _evict, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index2]);
    if (status) {
      status.entrySize = size;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
_indexes = new WeakSet();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i4 = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i4)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i4)) {
        yield i4;
      }
      if (i4 === __privateGet(this, _head)) {
        break;
      } else {
        i4 = __privateGet(this, _prev)[i4];
      }
    }
  }
};
_rindexes = new WeakSet();
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i4 = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i4)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i4)) {
        yield i4;
      }
      if (i4 === __privateGet(this, _tail)) {
        break;
      } else {
        i4 = __privateGet(this, _next)[i4];
      }
    }
  }
};
_isValidIndex = new WeakSet();
isValidIndex_fn = function(index2) {
  return index2 !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index2]) === index2;
};
_evict = new WeakSet();
evict_fn = function(free) {
  var _a2, _b;
  const head = __privateGet(this, _head);
  const k4 = __privateGet(this, _keyList)[head];
  const v4 = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4)) {
    v4.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v4, k4, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([v4, k4, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k4);
  __privateWrapper(this, _size)._--;
  return head;
};
_backgroundFetch = new WeakSet();
backgroundFetch_fn = function(k4, index2, options3, context) {
  const v4 = index2 === void 0 ? void 0 : __privateGet(this, _valList)[index2];
  if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v4)) {
    return v4;
  }
  const ac = new AC();
  const { signal } = options3;
  signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options: options3,
    context
  };
  const cb = (v5, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options3.ignoreFetchAbort && v5 !== void 0;
    if (options3.status) {
      if (aborted && !updateCache) {
        options3.status.fetchAborted = true;
        options3.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options3.status.fetchAbortIgnored = true;
      } else {
        options3.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p5;
    if (__privateGet(this, _valList)[index2] === p5) {
      if (v5 === void 0) {
        if (bf2.__staleWhileFetching) {
          __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
        } else {
          this.delete(k4);
        }
      } else {
        if (options3.status)
          options3.status.fetchUpdated = true;
        this.set(k4, v5, fetchOpts.options);
      }
    }
    return v5;
  };
  const eb = (er) => {
    if (options3.status) {
      options3.status.fetchRejected = true;
      options3.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options3.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options3.allowStaleOnFetchRejection;
    const noDelete = allowStale || options3.noDeleteOnFetchRejection;
    const bf2 = p5;
    if (__privateGet(this, _valList)[index2] === p5) {
      const del = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del) {
        this.delete(k4);
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options3.status && bf2.__staleWhileFetching !== void 0) {
        options3.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a2;
    const fmp = (_a2 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a2.call(this, k4, v4, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v5) => res(v5 === void 0 ? void 0 : v5), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options3.ignoreFetchAbort || options3.allowStaleOnFetchAbort) {
        res(void 0);
        if (options3.allowStaleOnFetchAbort) {
          res = (v5) => cb(v5, true);
        }
      }
    });
  };
  if (options3.status)
    options3.status.fetchDispatched = true;
  const p5 = new Promise(pcall).then(cb, eb);
  const bf = Object.assign(p5, {
    __abortController: ac,
    __staleWhileFetching: v4,
    __returned: void 0
  });
  if (index2 === void 0) {
    this.set(k4, bf, { ...fetchOpts.options, status: void 0 });
    index2 = __privateGet(this, _keyMap).get(k4);
  } else {
    __privateGet(this, _valList)[index2] = bf;
  }
  return bf;
};
_isBackgroundFetch = new WeakSet();
isBackgroundFetch_fn = function(p5) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b4 = p5;
  return !!b4 && b4 instanceof Promise && b4.hasOwnProperty("__staleWhileFetching") && b4.__abortController instanceof AC;
};
_connect = new WeakSet();
connect_fn = function(p5, n3) {
  __privateGet(this, _prev)[n3] = p5;
  __privateGet(this, _next)[p5] = n3;
};
_moveToTail = new WeakSet();
moveToTail_fn = function(index2) {
  if (index2 !== __privateGet(this, _tail)) {
    if (index2 === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index2]);
    } else {
      __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _prev)[index2], __privateGet(this, _next)[index2]);
    }
    __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _tail), index2);
    __privateSet(this, _tail, index2);
  }
};
var LRUCache = _LRUCache;

// src/pandocReference/ViewManager.ts
var import_obsidian13 = require("obsidian");

// src/pandocReference/regExps.ts
var citeRegExp = /(?<=^|[.;\s-[])(?:(\[)([^[\]@\n\r]*)((?:@[^@\s[\];,'"|]+(?:; *)?)+)([^;[\]]*)(\])|(@[^@\s[\];,'"|]+)(?:( *)(\[)([^[\]]+)(\]))?)/g;
var multiCiteRegExp = /(@[^@\s[\];,'"|]+)(; *)?/g;
var citekeyRegExp = /(@[^@\s[\];,'"|]+)/g;

// src/pandocReference/helpers.ts
function areSetsEqual(as, bs) {
  if (as.size !== bs.size)
    return false;
  for (const a3 of as)
    if (!bs.has(a3))
      return false;
  return true;
}
function extractCiteKeys(md) {
  var _a2;
  const matches = md.matchAll(citekeyRegExp);
  const output = /* @__PURE__ */ new Set();
  for (const match2 of matches) {
    const key = (_a2 = match2[1]) == null ? void 0 : _a2.slice(1);
    if (!output.has(key)) {
      output.add(key);
    }
  }
  return output;
}

// src/pandocReference/ViewManager.ts
var ViewManager = class {
  constructor(plugin) {
    this.lastStyle = null;
    this.lastLinks = null;
    this.plugin = plugin;
    this.cache = new LRUCache({ max: 20 });
  }
  async getReferenceList(file, content) {
    const citeKeys = extractCiteKeys(content);
    if (citeKeys.size === 0) {
      return null;
    }
    const cachedDoc = this.cache.has(file) ? this.cache.get(file) : null;
    const {
      citekeyReferenceCslStyle,
      citekeyReferenceHideLinks,
      database,
      port
    } = this.plugin.settings;
    if (!cachedDoc || !areSetsEqual(cachedDoc.keys, citeKeys) || citekeyReferenceCslStyle !== this.lastStyle || citekeyReferenceHideLinks !== this.lastLinks) {
      this.lastStyle = citekeyReferenceCslStyle;
      this.lastLinks = citekeyReferenceHideLinks;
      const setNull = () => {
        const result = {
          keys: citeKeys,
          bib: null
        };
        this.cache.set(file, result);
        return null;
      };
      try {
        const keys = Array.from(citeKeys);
        const db = {
          database,
          port
        };
        const { citekeys } = await getAllCiteKeys(db);
        const match2 = citekeys.find((c4) => c4.citekey === keys[0]);
        if (!match2)
          return setNull();
        const htmlStr = await getBibFromCiteKeys(
          keys.map((k4) => ({ key: k4, library: match2.libraryID })),
          db,
          citekeyReferenceCslStyle,
          "html",
          true
        );
        if (!htmlStr)
          return setNull();
        const parser = new DOMParser();
        const html = parser.parseFromString(htmlStr, "text/html");
        const entries = html.body.findAll(".csl-entry");
        const bib = createDiv({}, (el) => {
          el.append(...entries);
        });
        const result = {
          keys: citeKeys,
          bib
        };
        this.cache.set(file, result);
        return result.bib;
      } catch (e3) {
        if (!e3.message.includes("references container not found")) {
          console.error(e3);
        }
        return null;
      }
    }
    return cachedDoc.bib;
  }
  getReferenceListForSource(filePath) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (file && file instanceof import_obsidian13.TFile && this.cache.has(file)) {
      return this.cache.get(file).bib;
    }
  }
};

// src/pandocReference/ReferenceListView.ts
var viewType2 = "ZIReferenceListView";
function copyElToClipboard(el) {
  require("electron").clipboard.write({
    html: el.outerHTML,
    text: (0, import_obsidian14.htmlToMarkdown)(el.outerHTML)
  });
}
var ReferenceListView = class extends import_obsidian14.ItemView {
  constructor(plugin, leaf) {
    super(leaf);
    this.handleSettingsUpdate = () => {
      this.contentEl.toggleClass(
        "collapsed-links",
        !!this.plugin.settings.citekeyReferenceHideLinks
      );
      this.processReferences();
    };
    this.processReferences = async () => {
      const isRunning = await isZoteroRunning(
        {
          database: this.plugin.settings.database,
          port: this.plugin.settings.port
        },
        true
      );
      if (!isRunning) {
        return this.setMessage(
          "Cannot connect to Zotero. Please ensure it is running and the Better BibTeX plugin is installed"
        );
      }
      const activeView = app.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
      if (activeView) {
        try {
          const title = this.contentEl.find(".pwc-reference-list__title-text");
          if (title) {
            if (this.loader)
              this.loader.detach();
            this.loader = title.createSpan("zt-suggest-loading-wrapper", (el) => {
              el.createSpan("zt-suggest-loading");
            });
          }
          const fileContent = await app.vault.cachedRead(activeView.file);
          const bib = await this.viewManager.getReferenceList(
            activeView.file,
            fileContent
          );
          this.setViewContent(bib);
        } catch (e3) {
          console.error(e3);
        }
      } else {
        this.setNoContentMessage();
      }
    };
    this.plugin = plugin;
    this.viewManager = new ViewManager(plugin);
    this.registerEvent(
      app.metadataCache.on("changed", (file) => {
        const activeView = app.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
        if (activeView && file === activeView.file) {
          this.processReferences();
        }
      })
    );
    this.registerEvent(
      app.workspace.on("active-leaf-change", (leaf2) => {
        if (leaf2) {
          app.workspace.iterateRootLeaves((rootLeaf) => {
            if (rootLeaf === leaf2) {
              if (leaf2.view instanceof import_obsidian14.MarkdownView) {
                this.processReferences();
              } else {
                this.setNoContentMessage();
              }
            }
          });
        }
      })
    );
    this.plugin.emitter.on("settingsUpdated", this.handleSettingsUpdate);
    this.contentEl.addClass("pwc-reference-list");
    this.contentEl.toggleClass(
      "collapsed-links",
      !!this.plugin.settings.citekeyReferenceHideLinks
    );
    this.loader = this.contentEl.createSpan(
      "zt-suggest-loading-wrapper",
      (el) => {
        el.createSpan("zt-suggest-loading");
      }
    );
    activeWindow.setTimeout(() => {
      this.processReferences();
    }, 100);
  }
  async onClose() {
    this.viewManager.cache.clear();
    this.plugin.emitter.off("settingsUpdated", this.handleSettingsUpdate);
    return super.onClose();
  }
  setViewContent(bib) {
    if (bib && this.contentEl.firstChild !== bib) {
      if (this.plugin.settings.citekeyReferenceHideLinks) {
        bib.findAll("a").forEach((l4) => {
          l4.setAttribute("aria-label", l4.innerText);
        });
      }
      bib.findAll(".csl-entry").forEach((e3) => {
        e3.setAttribute("aria-label", "Click to copy");
        e3.onClickEvent(() => copyElToClipboard(e3));
        const leafRoot = this.leaf.getRoot();
        if (leafRoot) {
          const tooltipPos = leafRoot.side === "right" ? "left" : "right";
          e3.setAttribute("aria-label-position", tooltipPos);
        }
      });
      this.contentEl.empty();
      this.contentEl.createDiv(
        {
          cls: "pwc-reference-list__title"
        },
        (div) => {
          div.createDiv({
            cls: "pwc-reference-list__title-text",
            text: this.getDisplayText()
          });
          div.createDiv(
            {
              cls: "pwc-copy-list",
              attr: {
                "aria-label": "Copy list"
              }
            },
            (btn) => {
              (0, import_obsidian14.setIcon)(btn, "select-all-text");
              btn.onClickEvent(() => copyElToClipboard(bib));
            }
          );
        }
      );
      this.contentEl.append(bib);
    } else if (!bib) {
      this.setNoContentMessage();
    }
  }
  setNoContentMessage() {
    this.setMessage("No citations found in the active document.");
  }
  setMessage(message) {
    this.contentEl.empty();
    this.contentEl.createDiv({
      cls: "pwc-no-content",
      text: message
    });
    this.contentEl.createDiv("pwc-btn-wrapper").createEl("button", { text: "Refresh" }, (btn) => {
      btn.addEventListener("click", () => {
        this.contentEl.empty();
        this.loader = this.contentEl.createSpan(
          "zt-suggest-loading-wrapper",
          (el) => {
            el.createSpan("zt-suggest-loading");
          }
        );
        activeWindow.setTimeout(() => {
          this.processReferences();
        }, 200);
      });
    });
  }
  getViewType() {
    return viewType2;
  }
  getDisplayText() {
    return "References";
  }
  getIcon() {
    return "quote-glyph";
  }
};

// src/pandocReference/editorExtension.ts
var import_language = require("@codemirror/language");
var import_language2 = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_obsidian15 = require("obsidian");
var ignoreListRegEx = /code|math|templater|hashtag/;
var citeMark = (citekey, sourceFile, isPrefix) => {
  const cls = ["cm-pandoc-citation", "pandoc-citation"];
  if (isPrefix)
    cls.push("pandoc-citation-at");
  return import_view.Decoration.mark({
    class: cls.join(" "),
    attributes: {
      "data-citekey": citekey,
      "data-source": sourceFile || ""
    }
  });
};
var citeMarkFormatting = import_view.Decoration.mark({
  class: "cm-pandoc-citation-formatting"
});
var citeMarkExtra = import_view.Decoration.mark({
  class: "cm-pandoc-citation-extra"
});
var citeKeyPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = this.mkDeco(view);
    }
    update(update) {
      if (update.viewportChanged || update.docChanged || update.transactions.some(
        (tr) => tr.effects.some((e3) => e3.is(setCiteKeyCache))
      )) {
        this.decorations = this.mkDeco(update.view);
      }
    }
    mkDeco(view) {
      const b4 = new import_state.RangeSetBuilder();
      const obsView = view.state.field(import_obsidian15.editorViewField);
      let tree;
      for (const { from: from2, to } of view.visibleRanges) {
        const range = view.state.sliceDoc(from2, to);
        let match2;
        while (match2 = citeRegExp.exec(range)) {
          let pos = from2 + match2.index;
          if (!tree)
            tree = (0, import_language.syntaxTree)(view.state);
          const nodeProps = tree.resolveInner(pos, 1).type.prop(import_language2.tokenClassNodeProp);
          if (nodeProps && ignoreListRegEx.test(nodeProps)) {
            continue;
          }
          for (let i4 = 1; i4 <= 10; i4++) {
            switch (i4) {
              case 3:
                if (match2[i4]) {
                  const multiCite = match2[i4];
                  let m22;
                  while (m22 = multiCiteRegExp.exec(multiCite)) {
                    b4.add(
                      pos,
                      pos + 1,
                      citeMark(m22[1], obsView == null ? void 0 : obsView.file.path, true)
                    );
                    const withoutPrefix = m22[1].slice(1);
                    b4.add(
                      pos + 1,
                      pos + 1 + withoutPrefix.length,
                      citeMark(m22[1], obsView == null ? void 0 : obsView.file.path, false)
                    );
                    pos += m22[1].length;
                    if (m22[2]) {
                      b4.add(pos, pos + m22[2].length, citeMarkFormatting);
                      pos += m22[2].length;
                    }
                  }
                }
                continue;
              case 6:
                if (match2[i4]) {
                  b4.add(
                    pos,
                    pos + 1,
                    citeMark(match2[i4], obsView == null ? void 0 : obsView.file.path, true)
                  );
                  const withoutPrefix = match2[i4].slice(1);
                  b4.add(
                    pos + 1,
                    pos + 1 + withoutPrefix.length,
                    citeMark(match2[i4], obsView == null ? void 0 : obsView.file.path, false)
                  );
                  pos += match2[i4].length;
                }
                continue;
              case 1:
              case 5:
              case 8:
              case 10:
                if (match2[i4]) {
                  b4.add(pos, pos + match2[i4].length, citeMarkFormatting);
                  pos += match2[i4].length;
                }
                continue;
              case 2:
              case 4:
              case 7:
              case 9:
                if (match2[i4]) {
                  b4.add(pos, pos + match2[i4].length, citeMarkExtra);
                  pos += match2[i4].length;
                }
                continue;
            }
          }
        }
      }
      return b4.finish();
    }
  },
  {
    decorations: (v4) => v4.decorations
  }
);
var setCiteKeyCache = import_state.StateEffect.define();
var citeKeyCacheField = import_state.StateField.define({
  create(state) {
    const obsView = state.field(import_obsidian15.editorViewField);
    const viewManager = state.field(viewManagerField);
    if ((obsView == null ? void 0 : obsView.file) && (viewManager == null ? void 0 : viewManager.cache.has(obsView.file))) {
      return viewManager.cache.get(obsView.file);
    }
    return null;
  },
  update(state, tr) {
    for (const e3 of tr.effects) {
      if (e3.is(setCiteKeyCache)) {
        state = e3.value;
      }
    }
    return state;
  }
});
var viewManagerField = import_state.StateField.define({
  create() {
    return null;
  },
  update(state) {
    return state;
  }
});

// src/pandocReference/markdownPostprocessor.ts
function getCiteClass(isPrefix, isResolved, isUnresolved) {
  const cls = ["pandoc-citation"];
  if (isPrefix)
    cls.push("pandoc-citation-at");
  if (isResolved)
    cls.push("is-resolved");
  if (isUnresolved)
    cls.push("is-unresolved");
  return cls.join(" ");
}
function processCiteKeys(plugin) {
  return (el, ctx) => {
    const walker = activeDocument.createNodeIterator(el, NodeFilter.SHOW_TEXT);
    const toRemove = [];
    let node2;
    while (node2 = walker.nextNode()) {
      const content = node2.nodeValue;
      if (node2.parentElement && node2.parentElement.tagName === "CODE") {
        continue;
      }
      let frag = createFragment();
      let match2;
      let pos = 0;
      let didMatch = false;
      while (match2 = citeRegExp.exec(content)) {
        if (!didMatch)
          didMatch = true;
        frag.appendText(content.substring(pos, match2.index));
        pos = match2.index;
        for (let i4 = 1; i4 <= 10; i4++) {
          switch (i4) {
            case 3:
              if (match2[i4]) {
                const multiCite = match2[i4];
                let m22;
                while (m22 = multiCiteRegExp.exec(multiCite)) {
                  const { isResolved, isUnresolved } = {
                    isResolved: false,
                    isUnresolved: false
                  };
                  frag.createSpan({
                    cls: getCiteClass(true, isResolved, isUnresolved),
                    text: m22[1][0],
                    attr: {
                      "data-citekey": m22[1],
                      "data-source": ctx.sourcePath
                    }
                  });
                  frag.createSpan({
                    cls: getCiteClass(false, isResolved, isUnresolved),
                    text: m22[1].slice(1),
                    attr: {
                      "data-citekey": m22[1],
                      "data-source": ctx.sourcePath
                    }
                  });
                  pos += m22[1].length;
                  if (m22[2]) {
                    frag.createSpan({
                      cls: "pandoc-citation-formatting",
                      text: m22[2]
                    });
                    pos += m22[2].length;
                  }
                }
              }
              continue;
            case 6:
              if (match2[i4]) {
                const { isResolved, isUnresolved } = {
                  isResolved: false,
                  isUnresolved: false
                };
                frag.createSpan({
                  cls: getCiteClass(true, isResolved, isUnresolved),
                  text: match2[i4][0],
                  attr: {
                    "data-citekey": match2[i4],
                    "data-source": ctx.sourcePath
                  }
                });
                frag.createSpan({
                  cls: getCiteClass(false, isResolved, isUnresolved),
                  text: match2[i4].slice(1),
                  attr: {
                    "data-citekey": match2[i4],
                    "data-source": ctx.sourcePath
                  }
                });
                pos += match2[i4].length;
              }
              continue;
            case 1:
            case 5:
            case 8:
            case 10:
              if (match2[i4]) {
                frag.createSpan({
                  cls: "pandoc-citation-formatting",
                  text: match2[i4]
                });
                pos += match2[i4].length;
              }
              continue;
            case 2:
            case 4:
            case 7:
            case 9:
              if (match2[i4]) {
                frag.createSpan({
                  cls: "pandoc-citation-extra",
                  text: match2[i4]
                });
                pos += match2[i4].length;
              }
              continue;
          }
        }
      }
      if (didMatch) {
        frag.appendText(content.substring(frag.textContent.length));
        toRemove.push(node2);
        node2.parentNode.insertBefore(frag, node2);
        frag = null;
      }
    }
    toRemove.forEach((n3) => n3.parentNode.removeChild(n3));
  };
}

// src/pandocReference/tooltip.ts
var import_obsidian16 = require("obsidian");
var TooltipManager = class {
  constructor(plugin) {
    this.tooltipDb = 0;
    this.scrollHandler = () => {
      if (this.win) {
        this.hideTooltip();
        this.unbindScroll();
      }
    };
    this.plugin = plugin;
    this.cache = new LRUCache({ max: 40 });
    plugin.register(this.initDelegatedEvents());
    plugin.register(() => {
      this.unbindScroll();
      this.hideTooltip();
    });
  }
  initDelegatedEvents() {
    const over = (e3) => {
      var _a2;
      if (!this.plugin.settings.shouldShowCitekeyTooltips)
        return;
      if (e3.target instanceof HTMLElement) {
        const target = e3.target;
        clearTimeout(this.tooltipDb);
        this.tooltipDb = window.setTimeout(() => {
          this.showTooltip(target);
        }, (_a2 = this.plugin.settings.citekeyTooltipDelay) != null ? _a2 : 500);
      }
    };
    const out = () => {
      if (!this.plugin.settings.shouldShowCitekeyTooltips)
        return;
      this.hideTooltip();
    };
    document.body.on("pointerover", ".pandoc-citation", over);
    document.body.on("pointerout", ".pandoc-citation", out);
    return () => {
      document.body.off("pointerover", ".pandoc-citation", over);
      document.body.off("pointerout", ".pandoc-citation", out);
    };
  }
  async showTooltip(el) {
    if (this.tooltip) {
      this.hideTooltip();
    }
    if (!el.dataset.citekey || !el.dataset.source)
      return;
    const file = app.vault.getAbstractFileByPath(el.dataset.source);
    if (!file && !(file instanceof import_obsidian16.TFile)) {
      return;
    }
    const citekey = el.dataset.citekey.slice(1);
    const database = {
      database: this.plugin.settings.database,
      port: this.plugin.settings.port
    };
    const modClasses = this.plugin.settings.citekeyReferenceHideLinks ? " collapsed-links" : "";
    const prev2 = el.previousElementSibling;
    const rect = (prev2 == null ? void 0 : prev2.hasClass("pandoc-citation")) ? prev2.getBoundingClientRect() : el.getBoundingClientRect();
    this.tooltip = document.body.createDiv(
      { cls: `pwc-tooltip${modClasses}` },
      (div) => {
        div.createSpan("zt-suggest-loading-wrapper").createSpan("zt-suggest-loading");
        setTimeout(() => {
          const viewport = window.visualViewport;
          const divRect = div.getBoundingClientRect();
          div.style.left = rect.x + divRect.width + 10 > viewport.width ? `${rect.x - (rect.x + divRect.width + 10 - viewport.width)}px` : `${rect.x}px`;
          div.style.top = rect.bottom + divRect.height + 10 > viewport.height ? `${rect.y - divRect.height - 5}px` : `${rect.bottom + 5}px`;
        });
      }
    );
    if (this.cache.has(citekey)) {
      return this.populateTooltip(this.cache.get(citekey), rect, citekey);
    }
    if (!await isZoteroRunning(database, true)) {
      return this.populateTooltip(null, rect, citekey, true);
    }
    const libraryID = await getLibForCiteKey(citekey, database);
    if (!this.tooltip)
      return;
    if (libraryID === null) {
      return this.populateTooltip(null, rect, citekey);
    }
    const content = await getBibFromCiteKey(
      { key: citekey, library: libraryID },
      database,
      this.plugin.settings.citekeyReferenceCslStyle,
      "html",
      true
    );
    if (!this.tooltip)
      return;
    if (!content) {
      return this.populateTooltip(null, rect, citekey);
    }
    const parser = new DOMParser();
    const html = parser.parseFromString(content, "text/html");
    const bib = html.body.find(".csl-entry");
    this.cache.set(citekey, bib);
    this.populateTooltip(bib, rect, citekey);
  }
  populateTooltip(bib, rect, citekey, notRunning) {
    const { tooltip } = this;
    tooltip.empty();
    if (this.plugin.settings.citekeyReferenceHideLinks) {
      tooltip.addClass("collapsed-links");
    }
    if (bib) {
      tooltip.append(bib);
    } else {
      tooltip.addClass("is-missing");
      tooltip.createEl("em", {
        text: notRunning ? "Cannot connect to Zotero" : "No citation found for " + citekey
      });
    }
    setTimeout(() => {
      const viewport = window.visualViewport;
      const divRect = tooltip.getBoundingClientRect();
      tooltip.style.left = rect.x + divRect.width + 10 > viewport.width ? `${rect.x - (rect.x + divRect.width + 10 - viewport.width)}px` : `${rect.x}px`;
      tooltip.style.top = rect.bottom + divRect.height + 10 > viewport.height ? `${rect.y - divRect.height - 5}px` : `${rect.bottom + 5}px`;
    });
    this.win = activeWindow;
    this.win.addEventListener("scroll", this.scrollHandler, {
      capture: true
    });
  }
  unbindScroll() {
    if (this.win) {
      this.win.removeEventListener("scroll", this.scrollHandler, {
        capture: true
      });
      this.win = null;
    }
  }
  hideTooltip() {
    var _a2;
    clearTimeout(this.tooltipDb);
    if (this.tooltip) {
      (_a2 = this.tooltip) == null ? void 0 : _a2.remove();
      this.tooltip = null;
    }
  }
};

// src/settings/AssetDownloader.tsx
var import_download = __toESM(require_download());
var import_obsidian18 = require("obsidian");
var import_os2 = __toESM(require("os"));

// src/settings/Icon.tsx
var import_obsidian17 = require("obsidian");
function Icon({ name, className }) {
  return /* @__PURE__ */ Cn.createElement(
    "span",
    {
      "data-icon": name,
      className,
      ref: (c4) => {
        if (c4) {
          (0, import_obsidian17.setIcon)(c4, name);
        }
      }
    }
  );
}

// src/settings/SettingItem.tsx
function SettingItemInfo({ name, description }) {
  return /* @__PURE__ */ Cn.createElement("div", { className: "setting-item-info" }, /* @__PURE__ */ Cn.createElement("div", { className: "setting-item-name" }, name), /* @__PURE__ */ Cn.createElement("div", { className: "setting-item-description" }, description));
}
function SettingItem({
  name,
  description,
  children,
  isHeading
}) {
  return /* @__PURE__ */ Cn.createElement(
    "div",
    {
      className: `zt-setting-item setting-item${isHeading ? " setting-item-heading" : ""}`
    },
    /* @__PURE__ */ Cn.createElement(SettingItemInfo, { name, description }),
    /* @__PURE__ */ Cn.createElement("div", { className: "setting-item-control" }, children)
  );
}

// src/settings/AssetDownloader.tsx
var currentVersion = "1.0.15";
var options = {
  darwin: {
    x64: `https://github.com/mgmeyers/pdfannots2json/releases/download/${currentVersion}/pdfannots2json.Mac.Intel.tar.gz`,
    arm64: `https://github.com/mgmeyers/pdfannots2json/releases/download/${currentVersion}/pdfannots2json.Mac.M1.tar.gz`
  },
  linux: {
    x64: `https://github.com/mgmeyers/pdfannots2json/releases/download/${currentVersion}/pdfannots2json.Linux.x64.tar.gz`
  },
  win32: {
    x64: `https://github.com/mgmeyers/pdfannots2json/releases/download/${currentVersion}/pdfannots2json.Windows.x64.zip`
  }
};
function getDownloadUrl() {
  const platform = options[import_os2.default.platform()];
  if (!platform)
    return null;
  const url2 = platform[import_os2.default.arch()];
  if (!url2)
    return null;
  return url2;
}
async function downloadAndExtract() {
  const url2 = getDownloadUrl();
  console.log("Obsidian Zotero Integration: Downloading " + url2);
  if (!url2)
    return false;
  try {
    if (doesLegacyEXEExist()) {
      removeLegacyEXE();
    }
    if (doesEXEExist()) {
      removeEXE();
    }
    await (0, import_download.default)(url2, getExeRoot(), {
      extract: true
    });
  } catch (e3) {
    console.error(e3);
    new import_obsidian18.Notice(
      "Error downloading PDF utility. Check the console for more details.",
      1e4
    );
  }
  return true;
}
function AssetDownloader(props) {
  const [isUpToDate, setIsUpToDate] = Cn.useState(null);
  const [isLoading, setIsLoading] = Cn.useState(false);
  const [exists, setExists] = Cn.useState(false);
  const [overridePath, setOverridePath] = Cn.useState(
    props.settings.exeOverridePath
  );
  const setOverride = Cn.useMemo(
    () => (0, import_obsidian18.debounce)(
      (path8) => {
        setOverridePath(path8);
        props.updateSetting("exeOverridePath", path8);
      },
      150,
      true
    ),
    []
  );
  Cn.useEffect(() => {
    const exists2 = doesEXEExist(overridePath);
    setExists(exists2);
    if (exists2) {
      checkEXEVersion(overridePath).then((version) => {
        setIsUpToDate(`v${currentVersion}` === version);
      }).catch(() => {
      });
    }
  }, [overridePath]);
  const handleDownload = Cn.useCallback(() => {
    setIsLoading(true);
    downloadAndExtract().then((success) => {
      setIsLoading(false);
      if (success) {
        setIsUpToDate(true);
        setExists(true);
      }
    });
  }, []);
  const desc = [
    "Extracting data from PDFs requires an external tool.",
    "This plugin will still work without it, but annotations will not be included in exports."
  ];
  const overrideDesc = /* @__PURE__ */ Cn.createElement(Cn.Fragment, null, "Override the path to the PDF utility. Specify an absolute path to the pdfannots2json executable.", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      href: "https://github.com/mgmeyers/pdfannots2json/releases",
      target: "_blank",
      rel: "noreferrer"
    },
    "Download the executable here."
  ), " ", "You may need to provide Obsidian the appropriate OS permissions to access the executable.");
  const Override = /* @__PURE__ */ Cn.createElement(SettingItem, { name: "PDF Utility Path Override", description: overrideDesc }, /* @__PURE__ */ Cn.createElement(
    "input",
    {
      onChange: (e3) => setOverride(e3.target.value),
      type: "text",
      spellCheck: false,
      value: overridePath
    }
  ), /* @__PURE__ */ Cn.createElement(
    "div",
    {
      className: "clickable-icon setting-editor-extra-setting-button",
      "aria-label": "Select the pdfannots2json executable",
      onClick: () => {
        const path8 = require("electron").remote.dialog.showOpenDialogSync({
          properties: ["openFile"]
        });
        if (path8 && path8.length) {
          setOverride(path8[0]);
        }
      }
    },
    /* @__PURE__ */ Cn.createElement(Icon, { name: "lucide-folder-open" })
  ));
  if (exists && isUpToDate) {
    return /* @__PURE__ */ Cn.createElement(Cn.Fragment, null, /* @__PURE__ */ Cn.createElement(SettingItem, { name: "PDF Utility", description: desc.join(" ") }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-asset-success" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-asset-success__icon" }, /* @__PURE__ */ Cn.createElement(Icon, { name: "check-small" })), /* @__PURE__ */ Cn.createElement("div", { className: "zt-asset-success__message" }, "PDF utility is up to date."))), Override);
  }
  const descFrag = /* @__PURE__ */ Cn.createElement(Cn.Fragment, null, desc.join(" "), " ", exists && /* @__PURE__ */ Cn.createElement("strong", { className: "mod-warning" }, "The PDF extraction tool requires updating. Please re-download."), !exists && !overridePath && /* @__PURE__ */ Cn.createElement("strong", null, "Click the button to download."));
  return /* @__PURE__ */ Cn.createElement(Cn.Fragment, null, /* @__PURE__ */ Cn.createElement(SettingItem, { name: "PDF Utility", description: descFrag }, !overridePath && /* @__PURE__ */ Cn.createElement("button", { disabled: isLoading, onClick: handleDownload }, isLoading ? "Downloading..." : "Download")), Override);
}

// src/settings/settings.tsx
var import_obsidian19 = require("obsidian");

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i4 = 0; i4 < props.length; i4++) {
    var descriptor = props[i4];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o4, p5) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o5, p6) {
    o5.__proto__ = p6;
    return o5;
  };
  return _setPrototypeOf(o4, p5);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o4) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o5) {
    return o5.__proto__ || Object.getPrototypeOf(o5);
  };
  return _getPrototypeOf(o4);
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

// node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i4 = 0; i4 < document.styleSheets.length; i4++) {
    if (document.styleSheets[i4].ownerNode === tag) {
      return document.styleSheets[i4];
    }
  }
}
function createStyleElement(options3) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options3.key);
  if (options3.nonce !== void 0) {
    tag.setAttribute("nonce", options3.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options3) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options3.speedy === void 0 ? false : options3.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options3.nonce;
    this.key = options3.key;
    this.container = options3.container;
    this.prepend = options3.prepend;
    this.insertionPoint = options3.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (true) {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e3) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e3);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if (true) {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search2) {
  return value.indexOf(search2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse2("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse2(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index2, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse2(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse2(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i4 = 0, j4 = 0, k4 = 0; i4 < index2; ++i4)
    for (var x5 = 0, y4 = substr(value, post + 1, post = abs(j4 = points[i4])), z4 = value; x5 < size; ++x5)
      if (z4 = trim(j4 > 0 ? rule[x5] + " " + y4 : replace(y4, /&\f/g, rule[x5])))
        props[k4++] = z4;
  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i4 = 0; i4 < length2; i4++)
    output += callback(children[i4], i4, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i4 = 0; i4 < length2; i4++)
      output += collection[i4](element, index2, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn2(arg);
    return cache[arg];
  };
}

// node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i4 = 0, k4 = 0; i4 < rules.length; i4++) {
    for (var j4 = 0; j4 < parentRules.length; j4++, k4++) {
      element.props[k4] = points[i4] ? rules[i4].replace(/&\f/g, parentRules[j4]) : parentRules[j4] + " " + rules[i4];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache) {
  return function(element, index2, children) {
    if (element.type !== "rule" || cache.compat)
      return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i4 = commentContainer.length - 1; i4 >= 0; i4--) {
        var node2 = commentContainer[i4];
        if (node2.line < element.line) {
          break;
        }
        if (node2.column < element.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index2, children) {
  for (var i4 = index2 - 1; i4 >= 0; i4--) {
    if (!isImportRule(children[i4])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index2, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index2, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options3) {
  var key = options3.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options3.stylisPlugins || defaultStylisPlugins;
  if (true) {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options3.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i4 = 1; i4 < attrib.length; i4++) {
          inserted[attrib[i4]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (true) {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, true ? function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (serialized.map !== void 0) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options3.nonce,
      speedy: options3.speedy,
      prepend: options3.prepend,
      insertionPoint: options3.insertionPoint
    }),
    nonce: options3.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h4 = 0;
  var k4, i4 = 0, len = str.length;
  for (; len >= 4; ++i4, len -= 4) {
    k4 = str.charCodeAt(i4) & 255 | (str.charCodeAt(++i4) & 255) << 8 | (str.charCodeAt(++i4) & 255) << 16 | (str.charCodeAt(++i4) & 255) << 24;
    k4 = /* Math.imul(k, m): */
    (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16);
    k4 ^= /* k >>> r: */
    k4 >>> 24;
    h4 = /* Math.imul(k, m): */
    (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h4 ^= (str.charCodeAt(i4 + 2) & 255) << 16;
    case 2:
      h4 ^= (str.charCodeAt(i4 + 1) & 255) << 8;
    case 1:
      h4 ^= str.charCodeAt(i4) & 255;
      h4 = /* Math.imul(h, m): */
      (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  }
  h4 ^= h4 >>> 13;
  h4 = /* Math.imul(h, m): */
  (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  return ((h4 ^ h4 >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p22) {
          cursor = {
            name: p1,
            styles: p22,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
if (true) {
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        if (interpolation.map !== void 0) {
          styles += interpolation.map;
        }
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (true) {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (true) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match2, p1, p22) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p22.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i4 = 0; i4 < obj.length; i4++) {
      string += handleInterpolation(mergedProps, registered, obj[i4]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && true) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (_key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if (true) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
var serializeStyles = function serializeStyles2(args2, registered, mergedProps) {
  if (args2.length === 1 && typeof args2[0] === "object" && args2[0] !== null && args2[0].styles !== void 0) {
    return args2[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args2[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (strings[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += strings[0];
  }
  for (var i4 = 1; i4 < args2.length; i4++) {
    styles += handleInterpolation(mergedProps, registered, args2[i4]);
    if (stringMode) {
      if (strings[i4] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += strings[i4];
    }
  }
  var sourceMap;
  if (true) {
    styles = styles.replace(sourceMapPattern, function(match3) {
      sourceMap = match3;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles) + identifierName;
  if (true) {
    return {
      name,
      styles,
      map: sourceMap,
      next: cursor,
      toString: function toString2() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name,
    styles,
    next: cursor
  };
};

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = Sn ? Sn : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || y2;

// node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var isBrowser2 = true;
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ G(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
if (true) {
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ k3(function(props, ref) {
    var cache = q2(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
if (!isBrowser2) {
  withEmotionCache = function withEmotionCache3(func) {
    return function(props) {
      var cache = q2(EmotionCacheContext);
      if (cache === null) {
        cache = createCache({
          key: "css"
        });
        return /* @__PURE__ */ y(EmotionCacheContext.Provider, {
          value: cache
        }, func(props, cache));
      } else {
        return func(props, cache);
      }
    };
  };
}
var ThemeContext = /* @__PURE__ */ G({});
if (true) {
  ThemeContext.displayName = "EmotionThemeContext";
}
var getLastPart = function getLastPart2(functionName) {
  var parts = functionName.split(".");
  return parts[parts.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line2) {
  var match2 = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line2);
  if (match2)
    return getLastPart(match2[1]);
  match2 = /^([A-Za-z0-9$.]+)@/.exec(line2);
  if (match2)
    return getLastPart(match2[1]);
  return void 0;
};
var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
var sanitizeIdentifier = function sanitizeIdentifier2(identifier2) {
  return identifier2.replace(/\$/g, "-");
};
var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
  if (!stackTrace)
    return void 0;
  var lines = stackTrace.split("\n");
  for (var i4 = 0; i4 < lines.length; i4++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i4]);
    if (!functionName)
      continue;
    if (internalReactFunctionNames.has(functionName))
      break;
    if (/^[A-Z]/.test(functionName))
      return sanitizeIdentifier(functionName);
  }
  return void 0;
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  if (typeof props.css === "string" && // check if there is a css declaration
  props.css.indexOf(":") !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type;
  if (!!props.css && (typeof props.css !== "object" || typeof props.css.name !== "string" || props.css.name.indexOf("-") === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label)
      newProps[labelPropName] = label;
  }
  return newProps;
};
var Insertion = function Insertion2(_ref3) {
  var cache = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, q2(ThemeContext));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /* @__PURE__ */ y(k, null, /* @__PURE__ */ y(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ y(WrappedComponent, newProps));
});
if (true) {
  Emotion.displayName = "EmotionCssPropInternal";
}
var Emotion$1 = Emotion;

// node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var pkg = {
  name: "@emotion/react",
  version: "11.11.1",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        "default": "./dist/emotion-react.esm.js"
      },
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.2",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.0",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var jsx = function jsx2(type, props) {
  var args2 = arguments;
  if (props == null || !hasOwnProperty.call(props, "css")) {
    return y.apply(void 0, args2);
  }
  var argsLength = args2.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i4 = 2; i4 < argsLength; i4++) {
    createElementArgArray[i4] = args2[i4];
  }
  return y.apply(null, createElementArgArray);
};
var warnedAboutCssPropForGlobal = false;
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (props.className || props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props.styles;
  var serialized = serializeStyles([styles], void 0, q2(ThemeContext));
  if (!isBrowser2) {
    var _ref3;
    var serializedNames = serialized.name;
    var serializedStyles = serialized.styles;
    var next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames += " " + next2.name;
      serializedStyles += next2.styles;
      next2 = next2.next;
    }
    var shouldCache = cache.compat === true;
    var rules = cache.insert("", {
      name: serializedNames,
      styles: serializedStyles
    }, cache.sheet, shouldCache);
    if (shouldCache) {
      return null;
    }
    return /* @__PURE__ */ y("style", (_ref3 = {}, _ref3["data-emotion"] = cache.key + "-global " + serializedNames, _ref3.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref3.nonce = cache.sheet.nonce, _ref3));
  }
  var sheetRef = _2();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
if (true) {
  Global.displayName = "EmotionGlobal";
}
function css() {
  for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
    args2[_key] = arguments[_key];
  }
  return serializeStyles(args2);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames = function classnames2(args2) {
  var len = args2.length;
  var i4 = 0;
  var cls = "";
  for (; i4 < len; i4++) {
    var arg = args2[i4];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k4 in arg) {
            if (arg[k4] && k4) {
              toAdd && (toAdd += " ");
              toAdd += k4;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css5, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css5(registeredStyles);
}
var Insertion3 = function Insertion4(_ref3) {
  var cache = _ref3.cache, serializedArr = _ref3.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i4 = 0; i4 < serializedArr.length; i4++) {
      insertStyles(cache, serializedArr[i4], false);
    }
  });
  return null;
};
var ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css5 = function css6() {
    if (hasRendered && true) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
      args2[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args2, cache.registered);
    serializedArr.push(serialized);
    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && true) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args2[_key2] = arguments[_key2];
    }
    return merge(cache.registered, css5, classnames(args2));
  };
  var content = {
    css: css5,
    cx,
    theme: q2(ThemeContext)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /* @__PURE__ */ y(k, null, /* @__PURE__ */ y(Insertion3, {
    cache,
    serializedArr
  }), ele);
});
if (true) {
  ClassNames.displayName = "EmotionClassNames";
}
if (true) {
  isBrowser3 = true;
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser3 && !isTestEnv) {
    globalContext = // $FlowIgnore
    typeof globalThis !== "undefined" ? globalThis : isBrowser3 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser3;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key = sourceKeys[i4];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i4;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
      key = sourceSymbolKeys[i4];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

// node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs
function s3(t3) {
  return { ...t3, top: t3.y, left: t3.x, right: t3.x + t3.width, bottom: t3.y + t3.height };
}
var d3 = ["top", "right", "bottom", "left"];
var p3 = d3.reduce((t3, e3) => t3.concat(e3, e3 + "-start", e3 + "-end"), []);

// node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
function n2(t3) {
  var e3;
  return (null == (e3 = t3.ownerDocument) ? void 0 : e3.defaultView) || window;
}
function o3(t3) {
  return n2(t3).getComputedStyle(t3);
}
function i3(t3) {
  return t3 instanceof n2(t3).Node;
}
function r4(t3) {
  return i3(t3) ? (t3.nodeName || "").toLowerCase() : "#document";
}
function c3(t3) {
  return t3 instanceof n2(t3).HTMLElement;
}
function l3(t3) {
  return t3 instanceof n2(t3).Element;
}
function s4(t3) {
  return "undefined" != typeof ShadowRoot && (t3 instanceof n2(t3).ShadowRoot || t3 instanceof ShadowRoot);
}
function f3(t3) {
  const { overflow: e3, overflowX: n3, overflowY: i4, display: r5 } = o3(t3);
  return /auto|scroll|overlay|hidden|clip/.test(e3 + i4 + n3) && !["inline", "contents"].includes(r5);
}
function d4() {
  return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function h3(t3) {
  return ["html", "body", "#document"].includes(r4(t3));
}
var p4 = Math.min;
var m3 = Math.max;
var g4 = Math.round;
var y3 = Math.floor;
var w4 = (t3) => ({ x: t3, y: t3 });
function x4(t3) {
  const e3 = o3(t3);
  let n3 = parseFloat(e3.width) || 0, i4 = parseFloat(e3.height) || 0;
  const r5 = c3(t3), l4 = r5 ? t3.offsetWidth : n3, s5 = r5 ? t3.offsetHeight : i4, f4 = g4(n3) !== l4 || g4(i4) !== s5;
  return f4 && (n3 = l4, i4 = s5), { width: n3, height: i4, $: f4 };
}
function v3(t3) {
  return l3(t3) ? t3 : t3.contextElement;
}
function b3(t3) {
  const e3 = v3(t3);
  if (!c3(e3))
    return w4(1);
  const n3 = e3.getBoundingClientRect(), { width: o4, height: i4, $: r5 } = x4(e3);
  let l4 = (r5 ? g4(n3.width) : n3.width) / o4, s5 = (r5 ? g4(n3.height) : n3.height) / i4;
  return l4 && Number.isFinite(l4) || (l4 = 1), s5 && Number.isFinite(s5) || (s5 = 1), { x: l4, y: s5 };
}
var L3 = w4(0);
function T4(t3, e3, o4) {
  var i4, r5;
  if (void 0 === e3 && (e3 = true), !d4())
    return L3;
  const c4 = t3 ? n2(t3) : window;
  return !o4 || e3 && o4 !== c4 ? L3 : { x: (null == (i4 = c4.visualViewport) ? void 0 : i4.offsetLeft) || 0, y: (null == (r5 = c4.visualViewport) ? void 0 : r5.offsetTop) || 0 };
}
function R2(e3, o4, i4, r5) {
  void 0 === o4 && (o4 = false), void 0 === i4 && (i4 = false);
  const c4 = e3.getBoundingClientRect(), s5 = v3(e3);
  let f4 = w4(1);
  o4 && (r5 ? l3(r5) && (f4 = b3(r5)) : f4 = b3(e3));
  const u3 = T4(s5, i4, r5);
  let a3 = (c4.left + u3.x) / f4.x, d5 = (c4.top + u3.y) / f4.y, h4 = c4.width / f4.x, p5 = c4.height / f4.y;
  if (s5) {
    const t3 = n2(s5), e4 = r5 && l3(r5) ? n2(r5) : r5;
    let o5 = t3.frameElement;
    for (; o5 && r5 && e4 !== t3; ) {
      const t4 = b3(o5), e5 = o5.getBoundingClientRect(), i5 = getComputedStyle(o5), r6 = e5.left + (o5.clientLeft + parseFloat(i5.paddingLeft)) * t4.x, c5 = e5.top + (o5.clientTop + parseFloat(i5.paddingTop)) * t4.y;
      a3 *= t4.x, d5 *= t4.y, h4 *= t4.x, p5 *= t4.y, a3 += r6, d5 += c5, o5 = n2(o5).frameElement;
    }
  }
  return s3({ width: h4, height: p5, x: a3, y: d5 });
}
function S2(t3) {
  return ((i3(t3) ? t3.ownerDocument : t3.document) || window.document).documentElement;
}
function F4(t3) {
  if ("html" === r4(t3))
    return t3;
  const e3 = t3.assignedSlot || t3.parentNode || s4(t3) && t3.host || S2(t3);
  return s4(e3) ? e3.host : e3;
}
function O3(t3) {
  const e3 = F4(t3);
  return h3(e3) ? t3.ownerDocument ? t3.ownerDocument.body : t3.body : c3(e3) && f3(e3) ? e3 : O3(e3);
}
function D3(t3, e3) {
  var o4;
  void 0 === e3 && (e3 = []);
  const i4 = O3(t3), r5 = i4 === (null == (o4 = t3.ownerDocument) ? void 0 : o4.body), c4 = n2(i4);
  return r5 ? e3.concat(c4, c4.visualViewport || [], f3(i4) ? i4 : []) : e3.concat(i4, D3(i4));
}
function V3(t3, e3, n3, o4) {
  void 0 === o4 && (o4 = {});
  const { ancestorScroll: i4 = true, ancestorResize: r5 = true, elementResize: c4 = "function" == typeof ResizeObserver, layoutShift: l4 = "function" == typeof IntersectionObserver, animationFrame: s5 = false } = o4, f4 = v3(t3), u3 = i4 || r5 ? [...f4 ? D3(f4) : [], ...D3(e3)] : [];
  u3.forEach((t4) => {
    i4 && t4.addEventListener("scroll", n3, { passive: true }), r5 && t4.addEventListener("resize", n3);
  });
  const a3 = f4 && l4 ? function(t4, e4) {
    let n4, o5 = null;
    const i5 = S2(t4);
    function r6() {
      clearTimeout(n4), o5 && o5.disconnect(), o5 = null;
    }
    return function c5(l5, s6) {
      void 0 === l5 && (l5 = false), void 0 === s6 && (s6 = 1), r6();
      const { left: f5, top: u4, width: a4, height: d6 } = t4.getBoundingClientRect();
      if (l5 || e4(), !a4 || !d6)
        return;
      const h5 = { rootMargin: -y3(u4) + "px " + -y3(i5.clientWidth - (f5 + a4)) + "px " + -y3(i5.clientHeight - (u4 + d6)) + "px " + -y3(f5) + "px", threshold: m3(0, p4(1, s6)) || 1 };
      let g6 = true;
      function w7(t5) {
        const e5 = t5[0].intersectionRatio;
        if (e5 !== s6) {
          if (!g6)
            return c5();
          e5 ? c5(false, e5) : n4 = setTimeout(() => {
            c5(false, 1e-7);
          }, 100);
        }
        g6 = false;
      }
      try {
        o5 = new IntersectionObserver(w7, { ...h5, root: i5.ownerDocument });
      } catch (t5) {
        o5 = new IntersectionObserver(w7, h5);
      }
      o5.observe(t4);
    }(true), r6;
  }(f4, n3) : null;
  let d5, h4 = -1, g5 = null;
  c4 && (g5 = new ResizeObserver((t4) => {
    let [o5] = t4;
    o5 && o5.target === f4 && g5 && (g5.unobserve(e3), cancelAnimationFrame(h4), h4 = requestAnimationFrame(() => {
      g5 && g5.observe(e3);
    })), n3();
  }), f4 && !s5 && g5.observe(f4), g5.observe(e3));
  let w6 = s5 ? R2(t3) : null;
  return s5 && function e4() {
    const o5 = R2(t3);
    !w6 || o5.x === w6.x && o5.y === w6.y && o5.width === w6.width && o5.height === w6.height || n3();
    w6 = o5, d5 = requestAnimationFrame(e4);
  }(), n3(), () => {
    u3.forEach((t4) => {
      i4 && t4.removeEventListener("scroll", n3), r5 && t4.removeEventListener("resize", n3);
    }), a3 && a3(), g5 && g5.disconnect(), g5 = null, s5 && cancelAnimationFrame(d5);
  };
}

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var index = y2;
var use_isomorphic_layout_effect_browser_esm_default = index;

// node_modules/react-select/dist/index-6ea50319.esm.js
var _excluded$3 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var noop = function noop2() {
};
function applyPrefixToName(prefix2, name) {
  if (!name) {
    return prefix2;
  } else if (name[0] === "-") {
    return prefix2 + name;
  } else {
    return prefix2 + "__" + name;
  }
}
function classNames(prefix2, state) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNameList[_key - 2] = arguments[_key];
  }
  var arr = [].concat(classNameList);
  if (state && prefix2) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix2, key)));
      }
    }
  }
  return arr.filter(function(i4) {
    return i4;
  }).map(function(i4) {
    return String(i4).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (isArray2(value))
    return value.filter(Boolean);
  if (_typeof(value) === "object" && value !== null)
    return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getClassNames;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$3);
  return _objectSpread2({}, innerProps);
};
var getStyleProps = function getStyleProps2(props, name, classNamesState) {
  var cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles(name, props),
    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
  };
};
function handleInputChange(inputValue, actionMeta, onInputChange) {
  if (onInputChange) {
    var _newValue = onInputChange(inputValue, actionMeta);
    if (typeof _newValue === "string")
      return _newValue;
  }
  return inputValue;
}
function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
}
function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }
  return el.clientHeight;
}
function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }
  return el.scrollTop;
}
function scrollTo(el, top) {
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }
  el.scrollTop = top;
}
function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  if (style.position === "fixed")
    return document.documentElement;
  for (var parent = element; parent = parent.parentElement; ) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === "static") {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}
function easeOutCubic(t3, b4, c4, d5) {
  return c4 * ((t3 = t3 / d5 - 1) * t3 * t3 + 1) + b4;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e3) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e3) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options2 = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w5 = typeof window !== "undefined" ? window : {};
if (w5.addEventListener && w5.removeEventListener) {
  w5.addEventListener("p", noop, options2);
  w5.removeEventListener("p", noop, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item) {
  return item != null;
}
function isArray2(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps2(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    properties[_key2 - 1] = arguments[_key2];
  }
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref23 = _slicedToArray(_ref3, 1), key = _ref23[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
    newProps[key] = val;
    return newProps;
  }, {});
};
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p5) {
  return p5 === "auto" ? "bottom" : p5;
};
var menuCSS = function menuCSS2(_ref23, unstyled) {
  var _objectSpread22;
  var placement = _ref23.placement, _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread22 = {
    label: "menu"
  }, _defineProperty(_objectSpread22, alignToControl(placement), "100%"), _defineProperty(_objectSpread22, "position", "absolute"), _defineProperty(_objectSpread22, "width", "100%"), _defineProperty(_objectSpread22, "zIndex", 1), _objectSpread22), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
};
var PortalPlacementContext = /* @__PURE__ */ G(null);
var MenuPlacer = function MenuPlacer2(props) {
  var children = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme = props.theme;
  var _ref3 = q2(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement;
  var ref = _2(null);
  var _useState = h2(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
  var _useState3 = h2(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var controlHeight2 = theme.spacing.controlHeight;
  use_isomorphic_layout_effect_browser_esm_default(function() {
    var menuEl = ref.current;
    if (!menuEl)
      return;
    var isFixedPosition = menuPosition === "fixed";
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll,
      isFixedPosition,
      controlHeight: controlHeight2
    });
    setMaxHeight(state.maxHeight);
    setPlacement(state.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]);
  return children({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
};
var Menu = function Menu2(props) {
  var children = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "menu", {
    menu: true
  }), {
    ref: innerRef
  }, innerProps), children);
};
var Menu$1 = Menu;
var menuListCSS = function menuListCSS2(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
};
var MenuList = function MenuList2(props) {
  var children = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({}, getStyleProps(props, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children);
};
var noticeCSS = function noticeCSS2(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), innerProps), children);
};
NoOptionsMessage.defaultProps = {
  children: "No options"
};
var LoadingMessage = function LoadingMessage2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), innerProps), children);
};
LoadingMessage.defaultProps = {
  children: "Loading..."
};
var menuPortalCSS = function menuPortalCSS2(_ref6) {
  var rect = _ref6.rect, offset = _ref6.offset, position2 = _ref6.position;
  return {
    left: rect.left,
    position: position2,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal2(props) {
  var appendTo = props.appendTo, children = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition;
  var menuPortalRef = _2(null);
  var cleanupRef = _2(null);
  var _useState5 = h2(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
  var portalPlacementContext = F2(function() {
    return {
      setPortalPlacement
    };
  }, []);
  var _useState7 = h2(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
  var updateComputedPosition = T2(function() {
    if (!controlElement)
      return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
    var offset = rect[placement] + scrollDistance;
    if (offset !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = T2(function() {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = V3(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: "ResizeObserver" in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = T2(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition)
    return null;
  var menuWrapper = jsx("div", _extends({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": true
  }), innerProps), children);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? /* @__PURE__ */ z3(menuWrapper, appendTo) : menuWrapper);
};
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children);
};
var valueContainerCSS = function valueContainerCSS2(_ref23, unstyled) {
  var spacing2 = _ref23.theme.spacing, isMulti = _ref23.isMulti, hasValue = _ref23.hasValue, controlShouldRenderValue = _ref23.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
};
var ValueContainer = function ValueContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends({}, getStyleProps(props, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "indicatorsContainer", {
    indicators: true
  }), innerProps), children);
};
var _templateObject;
var _excluded$2 = ["size"];
function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref2 = false ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+XG4pID0+IHtcbiAgY29uc3QgeyBpbm5lclByb3BzLCBpc1J0bCB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2xvYWRpbmdJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgICAgey4uLmlubmVyUHJvcHN9XG4gICAgPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezB9IG9mZnNldD17aXNSdGx9IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MTYwfSBvZmZzZXQgLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXszMjB9IG9mZnNldD17IWlzUnRsfSAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcbkxvYWRpbmdJbmRpY2F0b3IuZGVmYXVsdFByb3BzID0geyBzaXplOiA0IH07XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var Svg = function Svg2(_ref3) {
  var size = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2);
  return jsx("svg", _extends({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), innerProps), children || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), innerProps), children || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay = _ref6.delay, offset = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, false ? "" : ";label:LoadingDot;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+XG4pID0+IHtcbiAgY29uc3QgeyBpbm5lclByb3BzLCBpc1J0bCB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2xvYWRpbmdJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgICAgey4uLmlubmVyUHJvcHN9XG4gICAgPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezB9IG9mZnNldD17aXNSdGx9IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MTYwfSBvZmZzZXQgLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXszMjB9IG9mZnNldD17IWlzUnRsfSAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcbkxvYWRpbmdJbmRpY2F0b3IuZGVmYXVsdFByb3BzID0geyBzaXplOiA0IH07XG4iXX0= */")
  });
};
var LoadingIndicator = function LoadingIndicator2(props) {
  var innerProps = props.innerProps, isRtl = props.isRtl;
  return jsx("div", _extends({}, getStyleProps(props, "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
LoadingIndicator.defaultProps = {
  size: 4
};
var css$1 = function css2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
};
var Control = function Control2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: true,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps), children);
};
var Control$1 = Control;
var _excluded$1 = ["data"];
var groupCSS = function groupCSS2(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group = function Group2(props) {
  var children = props.children, cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({}, getStyleProps(props, "group", {
    group: true
  }), innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles,
    getClassNames,
    cx
  }), label), jsx("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var GroupHeading = function GroupHeading2(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends({}, getStyleProps(props, "groupHeading", {
    "group-heading": true
  }), innerProps));
};
var Group$1 = Group;
var _excluded = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
};
var spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
};
var inputStyle = function inputStyle2(isHidden) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: "100%"
  }, spacingStyle);
};
var Input = function Input2(props) {
  var cx = props.cx, value = props.value;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded);
  return jsx("div", _extends({}, getStyleProps(props, "input", {
    "input-container": true
  }), {
    "data-value": value || ""
  }), jsx("input", _extends({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var Input$1 = Input;
var multiValueCSS = function multiValueCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref23.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends({
    role: "button"
  }, innerProps), children || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps;
  var Container = components2.Container, Label = components2.Label, Remove = components2.Remove;
  return jsx(Container, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx(Label, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps
  }, children), jsx(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(children || "option")
    }, removeProps3),
    selectProps
  }));
};
var MultiValue$1 = MultiValue;
var optionCSS = function optionCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: !isDisabled ? isSelected ? colors2.primary : colors2.primary50 : void 0
    }
  });
};
var Option = function Option2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "option", {
    option: true,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children);
};
var Option$1 = Option;
var placeholderCSS = function placeholderCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var Placeholder = function Placeholder2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "placeholder", {
    placeholder: true
  }), innerProps), children);
};
var Placeholder$1 = Placeholder;
var css3 = function css4(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var SingleValue = function SingleValue2(props) {
  var children = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": isDisabled
  }), innerProps), children);
};
var SingleValue$1 = SingleValue;
var components = {
  ClearIndicator,
  Control: Control$1,
  DropdownIndicator,
  DownChevron,
  CrossIcon,
  Group: Group$1,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$1,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i4 = 0; i4 < newInputs.length; i4++) {
    if (!isEqual(newInputs[i4], lastInputs[i4])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}

// node_modules/react-select/dist/Select-ce3716e1.esm.js
function _EMOTION_STRINGIFIED_CSS_ERROR__$2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref = false ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$2
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
};
var A11yText$1 = A11yText;
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action = props.action, _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, labels = props.labels, isDisabled = props.isDisabled;
    switch (action) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels.length > 1 ? "s" : "", " ").concat(labels.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context, focused = props.focused, options3 = props.options, _props$label2 = props.label, label = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex2(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu") {
      var disabled = isDisabled ? " disabled" : "";
      var status = "".concat(isSelected ? "selected" : "focused").concat(disabled);
      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options3, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id = props.id;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options3 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = F2(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = F2(function() {
    var message = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected = removedValue || option || asOption(value);
      var label = selected ? getOptionLabel4(selected) : "";
      var multiSelected = selectedOptions || removedValues || void 0;
      var labels = multiSelected ? multiSelected.map(getOptionLabel4) : [];
      var onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled3(selected, selectValue),
        label,
        labels
      }, ariaSelection);
      message = messages.onChange(onChangeProps);
    }
    return message;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]);
  var ariaFocused = F2(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue]);
  var ariaResults = F2(function() {
    var resultsMsg = "";
    if (menuIsOpen && options3.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options3, screenReaderStatus2]);
  var ariaGuidance = F2(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  var ScreenReaderText = jsx(k, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext));
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
  return jsx(k, null, jsx(A11yText$1, {
    id
  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var LiveRegion$1 = LiveRegion;
var diacritics = [{
  base: "A",
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: "AA",
  letters: "\uA732"
}, {
  base: "AE",
  letters: "\xC6\u01FC\u01E2"
}, {
  base: "AO",
  letters: "\uA734"
}, {
  base: "AU",
  letters: "\uA736"
}, {
  base: "AV",
  letters: "\uA738\uA73A"
}, {
  base: "AY",
  letters: "\uA73C"
}, {
  base: "B",
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: "C",
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: "D",
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: "DZ",
  letters: "\u01F1\u01C4"
}, {
  base: "Dz",
  letters: "\u01F2\u01C5"
}, {
  base: "E",
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: "F",
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: "G",
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: "H",
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: "I",
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: "J",
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: "K",
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: "L",
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: "LJ",
  letters: "\u01C7"
}, {
  base: "Lj",
  letters: "\u01C8"
}, {
  base: "M",
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: "N",
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: "NJ",
  letters: "\u01CA"
}, {
  base: "Nj",
  letters: "\u01CB"
}, {
  base: "O",
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: "OI",
  letters: "\u01A2"
}, {
  base: "OO",
  letters: "\uA74E"
}, {
  base: "OU",
  letters: "\u0222"
}, {
  base: "P",
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: "Q",
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: "R",
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: "S",
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: "T",
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: "TZ",
  letters: "\uA728"
}, {
  base: "U",
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: "V",
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: "VY",
  letters: "\uA760"
}, {
  base: "W",
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: "X",
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: "Y",
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: "Z",
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: "a",
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: "aa",
  letters: "\uA733"
}, {
  base: "ae",
  letters: "\xE6\u01FD\u01E3"
}, {
  base: "ao",
  letters: "\uA735"
}, {
  base: "au",
  letters: "\uA737"
}, {
  base: "av",
  letters: "\uA739\uA73B"
}, {
  base: "ay",
  letters: "\uA73D"
}, {
  base: "b",
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: "c",
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: "d",
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: "dz",
  letters: "\u01F3\u01C6"
}, {
  base: "e",
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: "f",
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: "g",
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: "h",
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: "hv",
  letters: "\u0195"
}, {
  base: "i",
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: "j",
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: "k",
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: "l",
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: "lj",
  letters: "\u01C9"
}, {
  base: "m",
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: "n",
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: "nj",
  letters: "\u01CC"
}, {
  base: "o",
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: "oi",
  letters: "\u01A3"
}, {
  base: "ou",
  letters: "\u0223"
}, {
  base: "oo",
  letters: "\uA74F"
}, {
  base: "p",
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: "q",
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: "r",
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: "s",
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: "t",
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: "tz",
  letters: "\uA729"
}, {
  base: "u",
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: "v",
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: "vy",
  letters: "\uA761"
}, {
  base: "w",
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: "x",
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: "y",
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: "z",
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d5) {
  return d5.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (i4 = 0; i4 < diacritics.length; i4++) {
  diacritic = diacritics[i4];
  for (j4 = 0; j4 < diacritic.letters.length; j4++) {
    diacriticToBase[diacritic.letters[j4]] = diacritic.base;
  }
}
var diacritic;
var j4;
var i4;
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match2) {
    return diacriticToBase[match2];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config) {
  return function(option, rawInput) {
    if (option.data.__isNew__)
      return true;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};
var _excluded2 = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded2);
  var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends({
    ref: innerRef
  }, filteredProps, {
    css: /* @__PURE__ */ css({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, false ? "" : ";label:DummyInput;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgcmVtb3ZlUHJvcHMgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIER1bW15SW5wdXQoe1xuICBpbm5lclJlZixcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW5wdXQnXSAmIHtcbiAgcmVhZG9ubHkgaW5uZXJSZWY6IFJlZjxIVE1MSW5wdXRFbGVtZW50Pjtcbn0pIHtcbiAgLy8gUmVtb3ZlIGFuaW1hdGlvbiBwcm9wcyBub3QgbWVhbnQgZm9yIEhUTUwgZWxlbWVudHNcbiAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IHJlbW92ZVByb3BzKFxuICAgIHByb3BzLFxuICAgICdvbkV4aXRlZCcsXG4gICAgJ2luJyxcbiAgICAnZW50ZXInLFxuICAgICdleGl0JyxcbiAgICAnYXBwZWFyJ1xuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGlucHV0XG4gICAgICByZWY9e2lubmVyUmVmfVxuICAgICAgey4uLmZpbHRlcmVkUHJvcHN9XG4gICAgICBjc3M9e3tcbiAgICAgICAgbGFiZWw6ICdkdW1teUlucHV0JyxcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBhbnkgZGVmYXVsdCBzdHlsZXNcbiAgICAgICAgYmFja2dyb3VuZDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHRoaXMgaGlkZXMgdGhlIGZsYXNoaW5nIGN1cnNvclxuICAgICAgICBjYXJldENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgICAgICBncmlkQXJlYTogJzEgLyAxIC8gMiAvIDMnLFxuICAgICAgICBvdXRsaW5lOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHdpdGhvdXQgYHdpZHRoYCBicm93c2VycyB3b24ndCBhbGxvdyBmb2N1c1xuICAgICAgICB3aWR0aDogMSxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIGRlc2t0b3BcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGN1cnNvciBvbiBtb2JpbGUgd2hpbHN0IG1haW50YWluaW5nIFwic2Nyb2xsIGludG8gdmlld1wiIGJlaGF2aW91clxuICAgICAgICBsZWZ0OiAtMTAwLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoLjAxKScsXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG4iXX0= */")
  }));
}
var cancelScroll = function cancelScroll2(event) {
  event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = _2(false);
  var isTop = _2(false);
  var touchStart = _2(0);
  var scrollTarget = _2(null);
  var handleEventDelta = T2(function(event, delta) {
    if (scrollTarget.current === null)
      return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave)
        onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave)
        onTopLeave(event);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = T2(function(event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = T2(function(event) {
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = T2(function(event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = T2(function(el) {
    if (!el)
      return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el.addEventListener("wheel", onWheel, notPassive);
    el.addEventListener("touchstart", onTouchStart, notPassive);
    el.addEventListener("touchmove", onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = T2(function(el) {
    if (!el)
      return;
    el.removeEventListener("wheel", onWheel, false);
    el.removeEventListener("touchstart", onTouchStart, false);
    el.removeEventListener("touchmove", onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  p2(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e3) {
  e3.preventDefault();
}
function allowTouchMove(e3) {
  e3.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = _2({});
  var scrollTarget = _2(null);
  var addScrollLock = T2(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = T2(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  p2(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
function _EMOTION_STRINGIFIED_CSS_ERROR__$1() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var blurSelectInput = function blurSelectInput2() {
  return document.activeElement && document.activeElement.blur();
};
var _ref2$1 = false ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQStDVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9ICgpID0+XG4gIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmJsdXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2Nyb2xsTWFuYWdlcih7XG4gIGNoaWxkcmVuLFxuICBsb2NrRW5hYmxlZCxcbiAgY2FwdHVyZUVuYWJsZWQgPSB0cnVlLFxuICBvbkJvdHRvbUFycml2ZSxcbiAgb25Cb3R0b21MZWF2ZSxcbiAgb25Ub3BBcnJpdmUsXG4gIG9uVG9wTGVhdmUsXG59OiBQcm9wcykge1xuICBjb25zdCBzZXRTY3JvbGxDYXB0dXJlVGFyZ2V0ID0gdXNlU2Nyb2xsQ2FwdHVyZSh7XG4gICAgaXNFbmFibGVkOiBjYXB0dXJlRW5hYmxlZCxcbiAgICBvbkJvdHRvbUFycml2ZSxcbiAgICBvbkJvdHRvbUxlYXZlLFxuICAgIG9uVG9wQXJyaXZlLFxuICAgIG9uVG9wTGVhdmUsXG4gIH0pO1xuICBjb25zdCBzZXRTY3JvbGxMb2NrVGFyZ2V0ID0gdXNlU2Nyb2xsTG9jayh7IGlzRW5hYmxlZDogbG9ja0VuYWJsZWQgfSk7XG5cbiAgY29uc3QgdGFyZ2V0UmVmOiBSZWZDYWxsYmFjazxIVE1MRWxlbWVudD4gPSAoZWxlbWVudCkgPT4ge1xuICAgIHNldFNjcm9sbENhcHR1cmVUYXJnZXQoZWxlbWVudCk7XG4gICAgc2V0U2Nyb2xsTG9ja1RhcmdldChlbGVtZW50KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxGcmFnbWVudD5cbiAgICAgIHtsb2NrRW5hYmxlZCAmJiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBvbkNsaWNrPXtibHVyU2VsZWN0SW5wdXR9XG4gICAgICAgICAgY3NzPXt7IHBvc2l0aW9uOiAnZml4ZWQnLCBsZWZ0OiAwLCBib3R0b206IDAsIHJpZ2h0OiAwLCB0b3A6IDAgfX1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgICB7Y2hpbGRyZW4odGFyZ2V0UmVmKX1cbiAgICA8L0ZyYWdtZW50PlxuICApO1xufVxuIl19 */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$1
};
function ScrollManager(_ref3) {
  var children = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(k, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children(targetRef));
}
function _EMOTION_STRINGIFIED_CSS_ERROR__2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref22 = false ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__2
};
var RequiredInput = function RequiredInput2(_ref3) {
  var name = _ref3.name, onFocus2 = _ref3.onFocus;
  return jsx("input", {
    required: true,
    name,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus2,
    css: _ref22,
    value: "",
    onChange: function onChange2() {
    }
  });
};
var RequiredInput$1 = RequiredInput;
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css3,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function toCategorizedOption(props, option, selectValue, index2) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel2(props, option);
  var value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label,
    value,
    index: index2
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label,
    value,
    data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options3) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options3.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options3[0];
}
var getOptionLabel2 = function getOptionLabel3(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue2 = function getOptionValue3(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i4) {
    return getOptionValue2(props, i4) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0)
    return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = "";
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue, action, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function(i4) {
          return _this.getOptionValue(i4) !== candidate;
        })), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), "select-option", newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), "select-option");
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: "select-option",
          option: newValue,
          name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i4) {
        return _this.getOptionValue(i4) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
        args2[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args2));
    };
    _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    };
    _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    };
    _this.getStyles = function(key, props) {
      var unstyled = _this.props.unstyled;
      var base = defaultStyles[key](props, unstyled);
      base.boxSizing = "border-box";
      var custom = _this.props.styles[key];
      return custom ? custom(base, props) : base;
    };
    _this.getClassNames = function(key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    };
    _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event) {
      if (event.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled)
        return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref23) {
      var touches = _ref23.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function(event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function(event) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled)
        return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue)
            return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue)
              return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing)
            return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption)
              return;
            if (_this.isComposing)
              return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption)
            return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen)
            return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen)
            return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen)
            return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen)
            return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusedOption = focusableOptions[optionIndex];
    }
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
        // ensure focus is restored correctly when the control becomes enabled
        isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
        isFocused && menuIsOpen && !prevProps.menuIsOpen
      ) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        this.setState({
          isFocused: true
        });
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef)
        return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef)
        return;
      this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti)
        return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length)
        return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options3 = this.getFocusableOptions();
      if (!options3.length)
        return;
      var nextFocus = 0;
      var focusedIndex = options3.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options3.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options3.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0)
          nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options3.length - 1)
          nextFocus = options3.length - 1;
      } else if (direction === "last") {
        nextFocus = options3.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options3[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function getTheme() {
        if (!this.props.theme) {
          return defaultTheme;
        }
        if (typeof this.props.theme === "function") {
          return this.props.theme(defaultTheme);
        }
        return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
      }
    )
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options3 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options3,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0)
        return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data) {
      return this.props.formatGroupLabel(data);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function startListeningComposition() {
        if (document && document.addEventListener) {
          document.addEventListener("compositionstart", this.onCompositionStart, false);
          document.addEventListener("compositionend", this.onCompositionEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function startListeningToTouch() {
        if (document && document.addEventListener) {
          document.addEventListener("touchstart", this.onTouchStart, false);
          document.addEventListener("touchmove", this.onTouchMove, false);
          document.addEventListener("touchend", this.onTouchEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function renderInput() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required;
        var _this$getComponents = this.getComponents(), Input3 = _this$getComponents.Input;
        var _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection;
        var commonProps = this.commonProps;
        var id = inputId || this.getElementId("input");
        var ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox"
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox"),
          "aria-owns": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": true
        }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        if (!isSearchable) {
          return /* @__PURE__ */ y(DummyInput, _extends({
            id,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop,
            onFocus: this.onInputFocus,
            disabled: isDisabled,
            tabIndex,
            inputMode: "none",
            form,
            value: ""
          }, ariaAttributes));
        }
        return /* @__PURE__ */ y(Input3, _extends({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /* @__PURE__ */ y(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function(opt, index2) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return /* @__PURE__ */ y(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key,
            index: index2,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e3) {
                e3.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /* @__PURE__ */ y(SingleValue3, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ y(ClearIndicator3, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ y(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /* @__PURE__ */ y(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ y(DropdownIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu3 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option3 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render = function render2(props, id) {
        var type = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label = props.label, value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /* @__PURE__ */ y(Option3, _extends({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label,
          type,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item) {
          if (item.type === "group") {
            var _data = item.data, options3 = item.options, groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ y(Group3, _extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options3,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function(option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === "option") {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage2({
          inputValue
        });
        if (message === null)
          return null;
        menuUI = /* @__PURE__ */ y(LoadingMessage3, commonProps, message);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = /* @__PURE__ */ y(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = /* @__PURE__ */ y(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ y(Menu3, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId("listbox")
          },
          isLoading,
          placement
        }), /* @__PURE__ */ y(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ y(MenuList3, _extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ y(MenuPortal3, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name = _this$props13.name, required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled) {
        return /* @__PURE__ */ y(RequiredInput$1, {
          name,
          onFocus: this.onValueInputFocus
        });
      }
      if (!name || isDisabled)
        return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return /* @__PURE__ */ y("input", {
            name,
            type: "hidden",
            value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function(opt, i4) {
            return /* @__PURE__ */ y("input", {
              key: "i-".concat(i4),
              name,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /* @__PURE__ */ y("input", {
            name,
            type: "hidden",
            value: ""
          });
          return /* @__PURE__ */ y("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return /* @__PURE__ */ y("input", {
          name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ y(LiveRegion$1, _extends({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ y(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ y(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ y(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ y(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused;
      var options3 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options3 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: "initial-input-focus"
        };
        hasKeptFocus = !prevWasFocused;
      }
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
        newAriaSelection = null;
      }
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select2;
}(b);
Select.defaultProps = defaultProps;

// node_modules/react-select/dist/useStateManager-7e1e8489.esm.js
var _excluded3 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded3);
  var _useState = h2(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
  var _useState3 = h2(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
  var _useState5 = h2(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
  var onChange2 = T2(function(value2, actionMeta) {
    if (typeof propsOnChange === "function") {
      propsOnChange(value2, actionMeta);
    }
    setStateValue(value2);
  }, [propsOnChange]);
  var onInputChange = T2(function(value2, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === "function") {
      newValue = propsOnInputChange(value2, actionMeta);
    }
    setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]);
  var onMenuOpen = T2(function() {
    if (typeof propsOnMenuOpen === "function") {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = T2(function() {
    if (typeof propsOnMenuClose === "function") {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}

// node_modules/react-select/dist/useAsync-9eb532f6.esm.js
var _excluded4 = ["defaultOptions", "cacheOptions", "loadOptions", "options", "isLoading", "onInputChange", "filterOption"];
function useAsync(_ref3) {
  var _ref$defaultOptions = _ref3.defaultOptions, propsDefaultOptions = _ref$defaultOptions === void 0 ? false : _ref$defaultOptions, _ref$cacheOptions = _ref3.cacheOptions, cacheOptions = _ref$cacheOptions === void 0 ? false : _ref$cacheOptions, propsLoadOptions = _ref3.loadOptions;
  _ref3.options;
  var _ref$isLoading = _ref3.isLoading, propsIsLoading = _ref$isLoading === void 0 ? false : _ref$isLoading, propsOnInputChange = _ref3.onInputChange, _ref$filterOption = _ref3.filterOption, filterOption = _ref$filterOption === void 0 ? null : _ref$filterOption, restSelectProps = _objectWithoutProperties(_ref3, _excluded4);
  var propsInputValue = restSelectProps.inputValue;
  var lastRequest = _2(void 0);
  var mounted = _2(false);
  var _useState = h2(Array.isArray(propsDefaultOptions) ? propsDefaultOptions : void 0), _useState2 = _slicedToArray(_useState, 2), defaultOptions = _useState2[0], setDefaultOptions = _useState2[1];
  var _useState3 = h2(typeof propsInputValue !== "undefined" ? propsInputValue : ""), _useState4 = _slicedToArray(_useState3, 2), stateInputValue = _useState4[0], setStateInputValue = _useState4[1];
  var _useState5 = h2(propsDefaultOptions === true), _useState6 = _slicedToArray(_useState5, 2), isLoading = _useState6[0], setIsLoading = _useState6[1];
  var _useState7 = h2(void 0), _useState8 = _slicedToArray(_useState7, 2), loadedInputValue = _useState8[0], setLoadedInputValue = _useState8[1];
  var _useState9 = h2([]), _useState10 = _slicedToArray(_useState9, 2), loadedOptions = _useState10[0], setLoadedOptions = _useState10[1];
  var _useState11 = h2(false), _useState12 = _slicedToArray(_useState11, 2), passEmptyOptions = _useState12[0], setPassEmptyOptions = _useState12[1];
  var _useState13 = h2({}), _useState14 = _slicedToArray(_useState13, 2), optionsCache = _useState14[0], setOptionsCache = _useState14[1];
  var _useState15 = h2(void 0), _useState16 = _slicedToArray(_useState15, 2), prevDefaultOptions = _useState16[0], setPrevDefaultOptions = _useState16[1];
  var _useState17 = h2(void 0), _useState18 = _slicedToArray(_useState17, 2), prevCacheOptions = _useState18[0], setPrevCacheOptions = _useState18[1];
  if (cacheOptions !== prevCacheOptions) {
    setOptionsCache({});
    setPrevCacheOptions(cacheOptions);
  }
  if (propsDefaultOptions !== prevDefaultOptions) {
    setDefaultOptions(Array.isArray(propsDefaultOptions) ? propsDefaultOptions : void 0);
    setPrevDefaultOptions(propsDefaultOptions);
  }
  p2(function() {
    mounted.current = true;
    return function() {
      mounted.current = false;
    };
  }, []);
  var loadOptions = T2(function(inputValue, callback) {
    if (!propsLoadOptions)
      return callback();
    var loader2 = propsLoadOptions(inputValue, callback);
    if (loader2 && typeof loader2.then === "function") {
      loader2.then(callback, function() {
        return callback();
      });
    }
  }, [propsLoadOptions]);
  p2(function() {
    if (propsDefaultOptions === true) {
      loadOptions(stateInputValue, function(options4) {
        if (!mounted.current)
          return;
        setDefaultOptions(options4 || []);
        setIsLoading(!!lastRequest.current);
      });
    }
  }, []);
  var onInputChange = T2(function(newValue, actionMeta) {
    var inputValue = handleInputChange(newValue, actionMeta, propsOnInputChange);
    if (!inputValue) {
      lastRequest.current = void 0;
      setStateInputValue("");
      setLoadedInputValue("");
      setLoadedOptions([]);
      setIsLoading(false);
      setPassEmptyOptions(false);
      return;
    }
    if (cacheOptions && optionsCache[inputValue]) {
      setStateInputValue(inputValue);
      setLoadedInputValue(inputValue);
      setLoadedOptions(optionsCache[inputValue]);
      setIsLoading(false);
      setPassEmptyOptions(false);
    } else {
      var request3 = lastRequest.current = {};
      setStateInputValue(inputValue);
      setIsLoading(true);
      setPassEmptyOptions(!loadedInputValue);
      loadOptions(inputValue, function(options4) {
        if (!mounted)
          return;
        if (request3 !== lastRequest.current)
          return;
        lastRequest.current = void 0;
        setIsLoading(false);
        setLoadedInputValue(inputValue);
        setLoadedOptions(options4 || []);
        setPassEmptyOptions(false);
        setOptionsCache(options4 ? _objectSpread2(_objectSpread2({}, optionsCache), {}, _defineProperty({}, inputValue, options4)) : optionsCache);
      });
    }
  }, [cacheOptions, loadOptions, loadedInputValue, optionsCache, propsOnInputChange]);
  var options3 = passEmptyOptions ? [] : stateInputValue && loadedInputValue ? loadedOptions : defaultOptions || [];
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    options: options3,
    isLoading: isLoading || propsIsLoading,
    onInputChange,
    filterOption
  });
}

// node_modules/react-select/async/dist/react-select-async.esm.js
var AsyncSelect = /* @__PURE__ */ k3(function(props, ref) {
  var stateManagedProps = useAsync(props);
  var selectProps = useStateManager(stateManagedProps);
  return /* @__PURE__ */ y(Select, _extends({
    ref
  }, selectProps));
});
var AsyncSelect$1 = AsyncSelect;

// src/settings/settings.tsx
var import_which = __toESM(require_lib3());

// src/settings/cslList.ts
var cslListRaw = [
  {
    value: "academy-of-management-review",
    label: "Academy of Management Review"
  },
  {
    value: "accident-analysis-and-prevention",
    label: "Accident Analysis and Prevention"
  },
  {
    value: "aci-materials-journal",
    label: "ACI Materials Journal"
  },
  {
    value: "acm-sig-proceedings-long-author-list",
    label: 'ACM SIG Proceedings ("et al." for 15+ authors)'
  },
  {
    value: "acm-sig-proceedings",
    label: 'ACM SIG Proceedings ("et al." for 3+ authors)'
  },
  {
    value: "acm-sigchi-proceedings-extended-abstract-format",
    label: "ACM SIGCHI Proceedings - Extended Abstract Format"
  },
  {
    value: "acm-sigchi-proceedings",
    label: "ACM SIGCHI Proceedings (2016)"
  },
  {
    value: "acm-siggraph",
    label: "ACM SIGGRAPH"
  },
  {
    value: "acme-an-international-journal-for-critical-geographies",
    label: "ACME: An International Journal for Critical Geographies"
  },
  {
    value: "acta-amazonica",
    label: "Acta Amazonica"
  },
  {
    value: "acta-anaesthesiologica-scandinavica",
    label: "Acta Anaesthesiologica Scandinavica"
  },
  {
    value: "acta-anaesthesiologica-taiwanica",
    label: "Acta Anaesthesiologica Taiwanica"
  },
  {
    value: "acta-botanica-croatica",
    label: "Acta Botanica Croatica"
  },
  {
    value: "acta-chiropterologica",
    label: "Acta Chiropterologica"
  },
  {
    value: "acta-chirurgiae-orthopaedicae-et-traumatologiae-cechoslovaca",
    label: "Acta chirurgiae orthopaedicae et traumatologiae \u010Cechoslovaca"
  },
  {
    value: "acta-hydrotechnica",
    label: "Acta hydrotechnica"
  },
  {
    value: "acta-ichthyologica-et-piscatoria",
    label: "Acta Ichthyologica et Piscatoria"
  },
  {
    value: "acta-medica-peruana",
    label: "Acta M\xE9dica Peruana"
  },
  {
    value: "acta-naturae",
    label: "Acta Naturae"
  },
  {
    value: "acta-neurobiologiae-experimentalis",
    label: "Acta Neurobiologiae Experimentalis"
  },
  {
    value: "acta-neurochirurgica",
    label: "Acta Neurochirurgica"
  },
  {
    value: "acta-ophthalmologica",
    label: "Acta Ophthalmologica"
  },
  {
    value: "acta-ornithologica",
    label: "Acta Ornithologica"
  },
  {
    value: "acta-orthopaedica-belgica",
    label: "Acta Orthop\xE6dica Belgica"
  },
  {
    value: "acta-orthopaedica",
    label: "Acta Orthopaedica"
  },
  {
    value: "acta-paediatrica",
    label: "Acta Paediatrica"
  },
  {
    value: "acta-palaeontologica-polonica",
    label: "Acta Palaeontologica Polonica"
  },
  {
    value: "acta-pharmaceutica-sinica-b",
    label: "Acta Pharmaceutica Sinica B"
  },
  {
    value: "acta-pharmaceutica",
    label: "Acta Pharmaceutica"
  },
  {
    value: "acta-philosophica",
    label: "Acta Philosophica"
  },
  {
    value: "acta-physica-sinica",
    label: "Acta Physica Sinica (\u7269\u7406\u5B66\u62A5)"
  },
  {
    value: "acta-physiologica",
    label: "Acta Physiologica"
  },
  {
    value: "acta-polytechnica",
    label: "Acta Polytechnica"
  },
  {
    value: "acta-radiologica",
    label: "Acta Radiologica"
  },
  {
    value: "acta-scientiae-veterinariae",
    label: "Acta Scientiae Veterinariae"
  },
  {
    value: "acta-societatis-botanicorum-poloniae",
    label: "Acta Societatis Botanicorum Poloniae"
  },
  {
    value: "acta-universitatis-agriculturae-et-silviculturae-mendelianae-brunensis",
    label: "Acta Universitatis Agriculturae et Silviculturae Mendelianae Brunensis"
  },
  {
    value: "acta-universitatis-agriculturae-sueciae",
    label: "Acta Universitatis Agriculturae Sueciae (Swedish University of Agricultural Sciences)"
  },
  {
    value: "acta-zoologica-academiae-scientiarum-hungaricae",
    label: "Acta Zoologica Academiae Scientiarum Hungaricae"
  },
  {
    value: "administrative-science-quarterly",
    label: "Administrative Science Quarterly"
  },
  {
    value: "advanced-engineering-materials",
    label: "Advanced Engineering Materials"
  },
  {
    value: "advanced-functional-materials",
    label: "Advanced Functional Materials"
  },
  {
    value: "advanced-healthcare-materials",
    label: "Advanced Healthcare Materials"
  },
  {
    value: "advanced-materials",
    label: "Advanced Materials"
  },
  {
    value: "advanced-optical-materials",
    label: "Advanced Optical Materials"
  },
  {
    value: "advanced-pharmaceutical-bulletin",
    label: "Advanced Pharmaceutical Bulletin"
  },
  {
    value: "advances-in-alzheimers-disease",
    label: "Advances in Alzheimer's Disease"
  },
  {
    value: "advances-in-complex-systems",
    label: "Advances in Complex Systems"
  },
  {
    value: "aerosol-and-air-quality-research",
    label: "Aerosol and Air Quality Research"
  },
  {
    value: "aerosol-science-and-technology",
    label: "Aerosol Science and Technology"
  },
  {
    value: "aerospace-medicine-and-human-performance",
    label: "Aerospace Medicine and Human Performance"
  },
  {
    value: "african-journal-of-marine-science",
    label: "African Journal of Marine Science"
  },
  {
    value: "african-online-scientific-information-systems-harvard",
    label: "African Online Scientific Information Systems - Harvard"
  },
  {
    value: "african-online-scientific-information-systems-vancouver",
    label: "African Online Scientific Information Systems - Vancouver"
  },
  {
    value: "african-zoology",
    label: "African Zoology"
  },
  {
    value: "afro-asia",
    label: "Afro-\xC1sia (Portugu\xEAs - Brasil)"
  },
  {
    value: "age-and-ageing",
    label: "Age and Ageing"
  },
  {
    value: "ageing-and-society",
    label: "Ageing & Society"
  },
  {
    value: "aging-and-disease",
    label: "Aging and Disease"
  },
  {
    value: "aging-cell",
    label: "Aging Cell"
  },
  {
    value: "aging",
    label: "Aging"
  },
  {
    value: "agora",
    label: "Agora"
  },
  {
    value: "agriculturae-conspectus-scientificus",
    label: "Agriculturae Conspectus Scientificus"
  },
  {
    value: "aib-studi",
    label: "AIB studi (Italiano)"
  },
  {
    value: "aids",
    label: "AIDS"
  },
  {
    value: "aims-press",
    label: "AIMS Press"
  },
  {
    value: "aix-marseille-universite-departement-d-etudes-asiatiques",
    label: "Aix-Marseille Universit\xE9 - D\xE9partement d'\xE9tudes asiatiques (Fran\xE7ais)"
  },
  {
    value: "al-jamiah-journal-of-islamic-studies",
    label: "Al-Jami'ah - Journal of Islamic Studies"
  },
  {
    value: "alcohol-and-alcoholism",
    label: "Alcohol and Alcoholism"
  },
  {
    value: "alcoholism-clinical-and-experimental-research",
    label: "Alcoholism: Clinical and Experimental Research"
  },
  {
    value: "alkoholizmus-a-drogove-zavislosti",
    label: "Alkoholizmus a drogov\xE9 z\xE1vislosti"
  },
  {
    value: "allergology-international",
    label: "Allergology International"
  },
  {
    value: "allergy",
    label: "Allergy"
  },
  {
    value: "alternatif-politika",
    label: "Alternatif Politika"
  },
  {
    value: "alternatives-to-animal-experimentation",
    label: "Alternatives to Animal Experimentation"
  },
  {
    value: "ambio",
    label: "AMBIO"
  },
  {
    value: "ameghiniana",
    label: "Ameghiniana"
  },
  {
    value: "american-anthropological-association",
    label: "American Anthropological Association"
  },
  {
    value: "american-association-for-cancer-research",
    label: "American Association for Cancer Research"
  },
  {
    value: "american-association-of-petroleum-geologists",
    label: "American Association of Petroleum Geologists"
  },
  {
    value: "american-chemical-society",
    label: "American Chemical Society"
  },
  {
    value: "american-fisheries-society",
    label: "American Fisheries Society"
  },
  {
    value: "american-geophysical-union",
    label: "American Geophysical Union"
  },
  {
    value: "american-heart-association",
    label: "American Heart Association"
  },
  {
    value: "american-institute-of-aeronautics-and-astronautics",
    label: "American Institute of Aeronautics and Astronautics"
  },
  {
    value: "american-institute-of-physics",
    label: "American Institute of Physics"
  },
  {
    value: "american-journal-of-agricultural-economics",
    label: "American Journal of Agricultural Economics"
  },
  {
    value: "american-journal-of-archaeology",
    label: "American Journal of Archaeology"
  },
  {
    value: "american-journal-of-botany",
    label: "American Journal of Botany"
  },
  {
    value: "american-journal-of-climate-change",
    label: "American Journal of Climate Change"
  },
  {
    value: "american-journal-of-clinical-pathology",
    label: "American Journal of Clinical Pathology"
  },
  {
    value: "american-journal-of-enology-and-viticulture",
    label: "American Journal of Enology and Viticulture"
  },
  {
    value: "american-journal-of-epidemiology",
    label: "American Journal of Epidemiology"
  },
  {
    value: "american-journal-of-health-behavior",
    label: "American Journal of Health Behavior"
  },
  {
    value: "american-journal-of-hypertension",
    label: "American Journal of Hypertension"
  },
  {
    value: "american-journal-of-medical-genetics",
    label: "American Journal of Medical Genetics"
  },
  {
    value: "american-journal-of-neuroradiology",
    label: "American Journal of Neuroradiology"
  },
  {
    value: "american-journal-of-orthodontics-and-dentofacial-orthopedics",
    label: "American Journal of Orthodontics & Dentofacial Orthopedics"
  },
  {
    value: "american-journal-of-plant-sciences",
    label: "American Journal of Plant Sciences"
  },
  {
    value: "american-journal-of-political-science",
    label: "American Journal of Political Science"
  },
  {
    value: "american-journal-of-respiratory-and-critical-care-medicine",
    label: "American Journal of Respiratory and Critical Care Medicine"
  },
  {
    value: "american-journal-of-science",
    label: "American Journal of Science"
  },
  {
    value: "american-journal-of-sociology",
    label: "American Journal of Sociology"
  },
  {
    value: "american-journal-of-sonography",
    label: "American Journal of Sonography"
  },
  {
    value: "american-journal-of-surgical-pathology",
    label: "American Journal of Surgical Pathology"
  },
  {
    value: "american-journal-of-translational-research",
    label: "American Journal of Translational Research"
  },
  {
    value: "american-marketing-association",
    label: "American Marketing Association"
  },
  {
    value: "american-medical-association-10th-edition",
    label: "American Medical Association 10th edition"
  },
  {
    value: "american-medical-association-alphabetical",
    label: "American Medical Association 11th edition (sorted alphabetically)"
  },
  {
    value: "american-medical-association-brackets",
    label: "American Medical Association 11th edition (brackets)"
  },
  {
    value: "american-medical-association-no-et-al",
    label: 'American Medical Association 11th edition (no "et al.")'
  },
  {
    value: "american-medical-association-no-url",
    label: "American Medical Association 11th edition (no URL)"
  },
  {
    value: "american-medical-association",
    label: "American Medical Association 11th edition"
  },
  {
    value: "american-meteorological-society",
    label: "American Meteorological Society"
  },
  {
    value: "american-mineralogist",
    label: "American Mineralogist"
  },
  {
    value: "american-nuclear-society",
    label: "American Nuclear Society"
  },
  {
    value: "american-physical-society-et-al",
    label: "American Physical Society - et al. (if more than 3 authors)"
  },
  {
    value: "american-physics-society-without-titles",
    label: "American Physical Society (without titles)"
  },
  {
    value: "american-physics-society",
    label: "American Physical Society"
  },
  {
    value: "american-physiological-society",
    label: "American Physiological Society"
  },
  {
    value: "american-phytopathological-society",
    label: "American Phytopathological Society"
  },
  {
    value: "american-political-science-association",
    label: "American Political Science Association"
  },
  {
    value: "american-school-of-classical-studies-at-athens",
    label: "American School of Classical Studies at Athens"
  },
  {
    value: "american-society-for-horticultural-science",
    label: "American Society for Horticultural Science"
  },
  {
    value: "american-society-for-microbiology",
    label: "American Society for Microbiology"
  },
  {
    value: "american-society-for-pharmacology-and-experimental-therapeutics",
    label: "American Society for Pharmacology and Experimental Therapeutics"
  },
  {
    value: "american-society-of-agricultural-and-biological-engineers",
    label: "American Society of Agricultural and Biological Engineers"
  },
  {
    value: "american-society-of-civil-engineers",
    label: "American Society of Civil Engineers"
  },
  {
    value: "american-society-of-mechanical-engineers",
    label: "American Society of Mechanical Engineers"
  },
  {
    value: "american-sociological-association",
    label: "American Sociological Association 6th edition"
  },
  {
    value: "american-statistical-association",
    label: "American Statistical Association"
  },
  {
    value: "american-veterinary-medical-association",
    label: "American Veterinary Medical Association"
  },
  {
    value: "amerindia",
    label: "Amerindia"
  },
  {
    value: "amphibia-reptilia",
    label: "Amphibia-Reptilia"
  },
  {
    value: "amsterdam-university-press-academic",
    label: "Amsterdam University Press - Academic"
  },
  {
    value: "anabases",
    label: "Anabases"
  },
  {
    value: "anaesthesia",
    label: "Anaesthesia"
  },
  {
    value: "analytical-sciences",
    label: "Analytical Sciences"
  },
  {
    value: "anatomical-sciences-education",
    label: "Anatomical Sciences Education"
  },
  {
    value: "ancilla-iuris",
    label: "Ancilla Iuris"
  },
  {
    value: "andean-geology",
    label: "Andean Geology"
  },
  {
    value: "anesthesia-and-analgesia",
    label: "Anesthesia and Analgesia"
  },
  {
    value: "anesthesiology",
    label: "Anesthesiology"
  },
  {
    value: "angewandte-chemie",
    label: "Angewandte Chemie International Edition"
  },
  {
    value: "angiologia",
    label: "Angiologia (Espa\xF1ol)"
  },
  {
    value: "anglia",
    label: "Anglia"
  },
  {
    value: "animal-conservation",
    label: "Animal Conservation"
  },
  {
    value: "animal-migration",
    label: "Animal Migration"
  },
  {
    value: "animal-welfare",
    label: "Animal Welfare"
  },
  {
    value: "animal",
    label: "animal"
  },
  {
    value: "annalen-des-naturhistorischen-museums-in-wien",
    label: "Annalen des Naturhistorischen Museums in Wien"
  },
  {
    value: "annales-de-demographie-historique",
    label: "Annales de d\xE9mographie historique"
  },
  {
    value: "annales",
    label: "Annales. Histoire, Sciences sociales (Fran\xE7ais)"
  },
  {
    value: "annals-of-applied-biology",
    label: "Annals of Applied Biology"
  },
  {
    value: "annals-of-behavioral-medicine",
    label: "Annals of Behavioral Medicine"
  },
  {
    value: "annals-of-biomedical-engineering",
    label: "Annals of Biomedical Engineering"
  },
  {
    value: "annals-of-botany",
    label: "Annals of Botany"
  },
  {
    value: "annals-of-eye-science",
    label: "Annals of Eye Science"
  },
  {
    value: "annals-of-joint",
    label: "Annals of Joint"
  },
  {
    value: "annals-of-laboratory-medicine",
    label: "Annals of Laboratory Medicine"
  },
  {
    value: "annals-of-neurology",
    label: "Annals of Neurology"
  },
  {
    value: "annals-of-oncology",
    label: "Annals of Oncology"
  },
  {
    value: "annals-of-public-and-cooperative-economics",
    label: "Annals of Public and Cooperative Economics"
  },
  {
    value: "annals-of-surgery",
    label: "Annals of Surgery"
  },
  {
    value: "annals-of-the-association-of-american-geographers",
    label: "Annals of the Association of American Geographers"
  },
  {
    value: "annals-of-the-new-york-academy-of-sciences",
    label: "Annals of the New York Academy of Sciences"
  },
  {
    value: "annals-of-work-exposures-and-health",
    label: "Annals of Work Exposures and Health"
  },
  {
    value: "annual-review-of-astronomy-and-astrophysics",
    label: "Annual Review of Astronomy and Astrophysics"
  },
  {
    value: "annual-review-of-linguistics",
    label: "Annual Review of Linguistics"
  },
  {
    value: "annual-review-of-medicine",
    label: "Annual Review of Medicine"
  },
  {
    value: "annual-review-of-nuclear-and-particle-science",
    label: "Annual Review of Nuclear and Particle Science"
  },
  {
    value: "annual-reviews-alphabetical",
    label: "Annual Reviews (sorted alphabetically)"
  },
  {
    value: "annual-reviews-author-date",
    label: "Annual Reviews (author-date)"
  },
  {
    value: "annual-reviews-without-titles",
    label: "Annual Reviews (sorted by order of appearance, without titles)"
  },
  {
    value: "annual-reviews",
    label: "Annual Reviews (sorted by order of appearance)"
  },
  {
    value: "antarctic-science",
    label: "Antarctic Science"
  },
  {
    value: "anthropologie-et-societes",
    label: "Anthropologie et Soci\xE9t\xE9s (Fran\xE7ais)"
  },
  {
    value: "anti-trafficking-review",
    label: "Anti-Trafficking Review"
  },
  {
    value: "anticancer-research",
    label: "Anticancer Research"
  },
  {
    value: "antipode",
    label: "Antipode"
  },
  {
    value: "antiquites-africaines",
    label: "Antiquit\xE9s africaines"
  },
  {
    value: "antiquity",
    label: "Antiquity"
  },
  {
    value: "apa-5th-edition",
    label: "American Psychological Association 5th edition"
  },
  {
    value: "apa-6th-edition-no-ampersand",
    label: "American Psychological Association 6th edition (no ampersand)"
  },
  {
    value: "apa-6th-edition",
    label: "American Psychological Association 6th edition"
  },
  {
    value: "apa-annotated-bibliography",
    label: "American Psychological Association 7th edition (annotated bibliography)"
  },
  {
    value: "apa-cv",
    label: "American Psychological Association 7th edition (curriculum vitae, sorted by descending date)"
  },
  {
    value: "apa-fr-provost",
    label: "American Psychological Association 6th edition (Provost) (Fran\xE7ais - Canada)"
  },
  {
    value: "apa-no-ampersand",
    label: "American Psychological Association 7th edition (no ampersand)"
  },
  {
    value: "apa-no-doi-no-issue",
    label: "American Psychological Association 6th edition (no DOIs, no issue numbers)"
  },
  {
    value: "apa-no-initials",
    label: "American Psychological Association 7th edition (no initials)"
  },
  {
    value: "apa-numeric-superscript-brackets",
    label: "American Psychological Association 7th edition (numeric, brackets)"
  },
  {
    value: "apa-numeric-superscript",
    label: "American Psychological Association 7th edition (numeric, superscript)"
  },
  {
    value: "apa-old-doi-prefix",
    label: 'American Psychological Association 6th edition ("doi:" DOI prefix)'
  },
  {
    value: "apa-single-spaced",
    label: "American Psychological Association 7th edition (single-spaced bibliography)"
  },
  {
    value: "apa-tr",
    label: "American Psychological Association 6th edition (T\xFCrk\xE7e)"
  },
  {
    value: "apa-with-abstract",
    label: "American Psychological Association 7th edition (with abstract)"
  },
  {
    value: "apa",
    label: "American Psychological Association 7th edition"
  },
  {
    value: "aporia-the-nursing-journal",
    label: "Aporia: The Nursing Journal"
  },
  {
    value: "applied-clay-science",
    label: "Applied Clay Science"
  },
  {
    value: "applied-spectroscopy-reviews",
    label: "Applied Spectroscopy Reviews"
  },
  {
    value: "applied-spectroscopy",
    label: "Applied Spectroscopy"
  },
  {
    value: "aquatic-conservation",
    label: "Aquatic Conservation: Marine and Freshwater Ecosystems"
  },
  {
    value: "aquatic-invasions",
    label: "Aquatic Invasions"
  },
  {
    value: "aquatic-living-resources",
    label: "Aquatic Living Resources"
  },
  {
    value: "aquitania",
    label: "Aquitania (Fran\xE7ais)"
  },
  {
    value: "arachne",
    label: "Arachne"
  },
  {
    value: "arachnology",
    label: "Arachnology"
  },
  {
    value: "arbok-hins-islenzka-fornleifafelags",
    label: "\xC1rb\xF3k Hins \xEDslenzka fornleifaf\xE9lags (\xCDslenska)"
  },
  {
    value: "archaeologia-austriaca",
    label: "Archaeologia Austriaca"
  },
  {
    value: "archaeometry",
    label: "Archaeometry"
  },
  {
    value: "archaeonautica",
    label: "Archaeonautica"
  },
  {
    value: "archeologia-classica",
    label: "Archeologia Classica (Italiano)"
  },
  {
    value: "archeologicke-rozhledy",
    label: "Archeologick\xE9 rozhledy"
  },
  {
    value: "archeologie-medievale",
    label: "Arch\xE9ologie m\xE9di\xE9vale (Fran\xE7ais)"
  },
  {
    value: "archeologies-et-sciences-de-lantiquite",
    label: "Arch\xE9ologies et Sciences de l'Antiquit\xE9 (Fran\xE7ais)"
  },
  {
    value: "archeosciences",
    label: "ArcheoSciences (Fran\xE7ais)"
  },
  {
    value: "archiv-fur-die-civilistische-praxis",
    label: "Archiv f\xFCr die civilistische Praxis (Deutsch)"
  },
  {
    value: "archiv-fur-geschichte-der-philosophie",
    label: "Archiv f\xFCr Geschichte der Philosophie"
  },
  {
    value: "archives-of-hand-and-microsurgery",
    label: "Archives of Hand and Microsurgery"
  },
  {
    value: "archives-of-physical-medicine-and-rehabilitation",
    label: "Archives of Physical Medicine and Rehabilitation"
  },
  {
    value: "archivos-de-bronconeumologia",
    label: "Archivos de Bronconeumolog\xEDa"
  },
  {
    value: "archivos-de-la-sociedad-espanola-de-oftalmologia",
    label: "Archivos de la Sociedad Espa\xF1ola de Oftalmolog\xEDa (Espa\xF1ol)"
  },
  {
    value: "archivum-latinitatis-medii-aevi",
    label: "Archivum Latinitatis Medii Aevi (Fran\xE7ais)"
  },
  {
    value: "arctic-antarctic-and-alpine-research",
    label: "Arctic, Antarctic, and Alpine Research"
  },
  {
    value: "arctic",
    label: "Arctic"
  },
  {
    value: "arhiv-za-higijenu-rada-i-toksikologiju",
    label: "Arhiv za higijenu rada i toksikologiju (Archives of Industrial Hygiene and Toxicology)"
  },
  {
    value: "art-history",
    label: "Art History"
  },
  {
    value: "art-libraries-society-of-north-america-arlisna-reviews",
    label: "Art Libraries Society of North America: ARLIS/NA Reviews"
  },
  {
    value: "artery-research",
    label: "Artery Research"
  },
  {
    value: "arthritis-and-rheumatism",
    label: "Arthritis & Rheumatism"
  },
  {
    value: "arthropod-systematics-and-phylogeny",
    label: "Arthropod Systematics & Phylogeny"
  },
  {
    value: "arts-university-bournemouth",
    label: "Arts University Bournemouth"
  },
  {
    value: "arzneimitteltherapie",
    label: "Arzneimitteltherapie"
  },
  {
    value: "asa-cssa-sssa",
    label: "American Society of Agronomy, Crop Science Society of America, Soil Science Society of America"
  },
  {
    value: "asaio-journal",
    label: "ASAIO Journal (American Society for Artificial Internal Organs)"
  },
  {
    value: "asia-and-the-pacific-policy-studies",
    label: "Asia & the Pacific Policy Studies"
  },
  {
    value: "asia-pacific-journal-of-human-resources",
    label: "Asia Pacific Journal of Human Resources"
  },
  {
    value: "asian-journal-of-neurosurgery",
    label: "Asian Journal of Neurosurgery"
  },
  {
    value: "asian-myrmecology",
    label: "Asian Myrmecology"
  },
  {
    value: "asian-studies-review",
    label: "Asian Studies Review"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-eceme",
    label: "Escola de Comando e Estado-Maior do Ex\xE9rcito - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-instituto-meira-mattos",
    label: "Escola de Comando e Estado-Maior do Ex\xE9rcito - Instituto Meira Mattos - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-ipea",
    label: "Instituto de Pesquisa Econ\xF4mica Aplicada - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-note",
    label: "Associa\xE7\xE3o Brasileira de Normas T\xE9cnicas (note, Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-ufmg-face-full",
    label: "Universidade Federal de Minas Gerais - Faculdade de Ci\xEAncias Econ\xF4micas - ABNT (autoria completa) (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-ufmg-face-initials",
    label: "Universidade Federal de Minas Gerais - Faculdade de Ci\xEAncias Econ\xF4micas - ABNT (autoria abreviada) (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-ufpr",
    label: "Universidade Federal do Paran\xE1 - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-ufrgs-initials",
    label: "Universidade Federal do Rio Grande do Sul - ABNT (autoria abreviada) (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-ufrgs-note-initials-with-ibid",
    label: "Universidade Federal do Rio Grande do Sul - ABNT (autoria abreviada, nota, com Ibid.) (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-ufrgs",
    label: "Universidade Federal do Rio Grande do Sul - ABNT (autoria completa) (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-ufs",
    label: "Universidade Federal de Sergipe - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-unirio-eipp",
    label: "Universidade Federal do Estado do Rio de Janeiro - Educa\xE7\xE3o Infantil e Pol\xEDticas P\xFAblicas - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas-usp-fmvz",
    label: "Universidade de S\xE3o Paulo - Faculdade de Medicina Veterin\xE1ria e Zootecnia - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-brasileira-de-normas-tecnicas",
    label: "Associa\xE7\xE3o Brasileira de Normas T\xE9cnicas (Portugu\xEAs - Brasil)"
  },
  {
    value: "associacao-nacional-de-pesquisa-e-ensino-em-transportes",
    label: "ANPET - Congresso de Pesquisa e Ensino em Transportes (Portugu\xEAs - Brasil)"
  },
  {
    value: "association-de-science-regionale-de-langue-francaise",
    label: "Association de Science R\xE9gionale de Langue Fran\xE7aise (Fran\xE7ais)"
  },
  {
    value: "association-for-computational-linguistics",
    label: "Association for Computational Linguistics - Conference Proceedings"
  },
  {
    value: "association-for-computing-machinery",
    label: "Association for Computing Machinery"
  },
  {
    value: "atlande",
    label: "Atlande (author-date, Fran\xE7ais)"
  },
  {
    value: "atlas-of-genetics-and-cytogenetics-in-oncology-and-haematology",
    label: "Atlas of Genetics and Cytogenetics in Oncology and Haematology"
  },
  {
    value: "ausonius-editions",
    label: "Ausonius \xC9ditions (Fran\xE7ais)"
  },
  {
    value: "austral-ecology",
    label: "Austral Ecology"
  },
  {
    value: "austral-entomology",
    label: "Austral Entomology"
  },
  {
    value: "australian-archaeology",
    label: "Australian Archaeology"
  },
  {
    value: "australian-critical-care",
    label: "Australian Critical Care"
  },
  {
    value: "australian-dental-journal",
    label: "Australian Dental Journal"
  },
  {
    value: "australian-guide-to-legal-citation-3rd-edition",
    label: "Australian Guide to Legal Citation 3rd edition"
  },
  {
    value: "australian-guide-to-legal-citation",
    label: "Australian Guide to Legal Citation 4th edition"
  },
  {
    value: "australian-historical-studies",
    label: "Australian Historical Studies"
  },
  {
    value: "australian-journal-of-earth-sciences",
    label: "Australian Journal of Earth Sciences"
  },
  {
    value: "australian-journal-of-grape-and-wine-research",
    label: "Australian Journal of Grape and Wine Research"
  },
  {
    value: "australian-road-research-board",
    label: "Australian Road Research Board"
  },
  {
    value: "australian-veterinary-journal",
    label: "Australian Veterinary Journal"
  },
  {
    value: "austrian-journal-of-development-studies",
    label: "Austrian Journal of Development Studies (Journal f\xFCr Entwicklungspolitik)"
  },
  {
    value: "austrian-legal",
    label: "Austrian Legal (Deutsch - \xD6sterreich)"
  },
  {
    value: "avian-conservation-and-ecology",
    label: "Avian Conservation and Ecology"
  },
  {
    value: "avian-diseases",
    label: "Avian Diseases"
  },
  {
    value: "avian-pathology",
    label: "Avian Pathology"
  },
  {
    value: "ayer",
    label: "Ayer (Espa\xF1ol)"
  },
  {
    value: "azr-abkurzungs-und-zitierregeln-der-osterreichischen-rechtssprache-und-europarechtlicher-rechtsquellen",
    label: "AZR - Abk\xFCrzungs- und Zitierregeln der \xF6sterreichischen Rechtssprache und europarechtlicher Rechtsquellen (Deutsch - \xD6sterreich)"
  },
  {
    value: "babes-bolyai-university-faculty-of-orthodox-theology",
    label: "Babes-Bolyai University - Faculty of Orthodox Theology (no ibid., Rom\xE2n\u0103)"
  },
  {
    value: "babesch-annual-papers-on-mediterranean-archaeology",
    label: "BABESCH - Annual Papers on Mediterranean Archaeology"
  },
  {
    value: "baghdad-science-journal",
    label: "Baghdad Science Journal"
  },
  {
    value: "baishideng-publishing-group",
    label: "Baishideng Publishing Group"
  },
  {
    value: "bakhtiniana-journal-of-discourse-studies",
    label: "Bakhtiniana: Journal of Discourse Studies"
  },
  {
    value: "begell-house-apa",
    label: "Begell House - APA"
  },
  {
    value: "begell-house-chicago-author-date",
    label: "Begell House - Chicago Manual of Style"
  },
  {
    value: "behaviour",
    label: "Behaviour"
  },
  {
    value: "beilstein-journal-of-organic-chemistry",
    label: "Beilstein Journal of Organic Chemistry"
  },
  {
    value: "beltz-padagogik",
    label: "Beltz - P\xE4dagogik (Deutsch)"
  },
  {
    value: "berghahn-books-author-date-en-gb",
    label: "Berghahn Books (author-date, English - UK)"
  },
  {
    value: "berlin-school-of-economics-and-law-international-marketing-management",
    label: "Berlin School of Economics and Law - International Marketing Management"
  },
  {
    value: "bern-university-of-applied-sciences-school-of-agricultural-forest-and-food-sciences-hafl",
    label: "Bern University of Applied Sciences - School of Agricultural, Forest and Food Sciences HAFL (author-date)"
  },
  {
    value: "betriebswirtschaftliche-forschung-und-praxis",
    label: "Betriebswirtschaftliche Forschung und Praxis (Deutsch)"
  },
  {
    value: "biblio-3w",
    label: "Biblio 3W (Espa\xF1ol)"
  },
  {
    value: "bibliothecae-it",
    label: "Bibliothecae.it (Italiano)"
  },
  {
    value: "bibliotheque-d-archeologie-mediterraneenne-et-africaine-biama",
    label: "Biblioth\xE8que d'arch\xE9ologie m\xE9diterran\xE9enne et africaine (BiAMA) (Fran\xE7ais)"
  },
  {
    value: "bibliotheque-universitaire-de-medecine-vancouver",
    label: "Biblioth\xE8que universitaire de m\xE9decine - Vancouver (Fran\xE7ais)"
  },
  {
    value: "bibtex",
    label: "BibTeX generic citation style"
  },
  {
    value: "biens-symboliques-symbolic-goods",
    label: "Biens symboliques / Symbolic Goods"
  },
  {
    value: "bioarchaeology-international",
    label: "Bioarchaeology International"
  },
  {
    value: "bioarchaeology-of-the-near-east",
    label: "Bioarchaeology of the Near East"
  },
  {
    value: "biochemical-journal",
    label: "Biochemical Journal"
  },
  {
    value: "biochemical-society-transactions",
    label: "Biochemical Society Transactions"
  },
  {
    value: "biochemistry-and-molecular-biology-education",
    label: "Biochemistry and Molecular Biology Education"
  },
  {
    value: "biochemistry",
    label: "Biochemistry"
  },
  {
    value: "biochimica-et-biophysica-acta",
    label: "Biochimica et Biophysica Acta"
  },
  {
    value: "bioelectromagnetics",
    label: "Bioelectromagnetics"
  },
  {
    value: "bioinformatics",
    label: "Bioinformatics"
  },
  {
    value: "biologia",
    label: "Biologia"
  },
  {
    value: "biological-and-pharmaceutical-bulletin",
    label: "Biological and Pharmaceutical Bulletin"
  },
  {
    value: "biological-journal-of-the-linnean-society",
    label: "Biological Journal of the Linnean Society"
  },
  {
    value: "biological-psychiatry",
    label: "Biological Psychiatry"
  },
  {
    value: "biological-reviews",
    label: "Biological Reviews"
  },
  {
    value: "biology-of-reproduction",
    label: "Biology of Reproduction"
  },
  {
    value: "biomarkers",
    label: "Biomarkers"
  },
  {
    value: "biomed-central",
    label: "BioMed Central"
  },
  {
    value: "biomed-research-international",
    label: "BioMed Research International"
  },
  {
    value: "biometrics",
    label: "Biometrics"
  },
  {
    value: "biophysical-journal",
    label: "Biophysical Journal"
  },
  {
    value: "biophysics-and-physicobiology",
    label: "Biophysics and Physicobiology"
  },
  {
    value: "biopolymers",
    label: "Biopolymers"
  },
  {
    value: "bioresources",
    label: "BioResources"
  },
  {
    value: "bioscience",
    label: "BioScience"
  },
  {
    value: "biosocieties",
    label: "BioSocieties"
  },
  {
    value: "biostatistics",
    label: "Biostatistics"
  },
  {
    value: "biota-neotropica",
    label: "Biota Neotropica"
  },
  {
    value: "biotechniques",
    label: "BioTechniques"
  },
  {
    value: "biotechnology-and-bioengineering",
    label: "Biotechnology and Bioengineering"
  },
  {
    value: "biotropica",
    label: "Biotropica"
  },
  {
    value: "bitonline",
    label: "b.i.t.online (note, Deutsch)"
  },
  {
    value: "biuletyn-polskiego-towarzystwa-jezykoznawczego",
    label: "Biuletyn Polskiego Towarzystwa J\u0119zykoznawczego (Polski)"
  },
  {
    value: "blood",
    label: "Blood"
  },
  {
    value: "bloomsbury-academic",
    label: "Bloomsbury Academic"
  },
  {
    value: "bluebook-inline",
    label: "Bluebook Inline"
  },
  {
    value: "bluebook-law-review",
    label: "Bluebook Law Review"
  },
  {
    value: "bluebook2",
    label: "Bluebook Law Review (2)"
  },
  {
    value: "bmj",
    label: "BMJ"
  },
  {
    value: "body-and-society",
    label: "Body & Society"
  },
  {
    value: "boletin-de-la-sociedad-geologica-mexicana",
    label: "Bolet\xEDn de la Sociedad Geol\xF3gica Mexicana (Espa\xF1ol - Mexico)"
  },
  {
    value: "boletin-de-pediatria",
    label: "Bolet\xEDn de Pediatr\xEDa (Espa\xF1ol)"
  },
  {
    value: "bollettino-d-archeologia-online",
    label: "Bollettino d'archeologia online (Italiano)"
  },
  {
    value: "boreal-environment-research",
    label: "Boreal Environment Research"
  },
  {
    value: "bourgogne-franche-comte-nature",
    label: "Bourgogne-Franche-Comt\xE9 Nature (Fran\xE7ais)"
  },
  {
    value: "brachytherapy",
    label: "Brachytherapy"
  },
  {
    value: "brain-behavior-and-evolution",
    label: "Brain, Behavior and Evolution"
  },
  {
    value: "brazilian-journal-of-experimental-design-data-analysis-and-inferential-statistics",
    label: "Brazilian Journal of Experimental Design, Data Analysis and Inferential Statistics"
  },
  {
    value: "brazilian-journal-of-infectious-diseases",
    label: "Brazilian Journal of Infectious Diseases"
  },
  {
    value: "brazilian-journal-of-psychiatry",
    label: "Brazilian Journal of Psychiatry"
  },
  {
    value: "brazilian-journal-of-veterinary-research-and-animal-science",
    label: "Brazilian Journal of Veterinary Research and Animal Science"
  },
  {
    value: "brazilian-oral-research",
    label: "Brazilian Oral Research"
  },
  {
    value: "brewingscience",
    label: "BrewingScience"
  },
  {
    value: "briefings-in-bioinformatics",
    label: "Briefings in Bioinformatics"
  },
  {
    value: "british-journal-of-anaesthesia",
    label: "British Journal of Anaesthesia"
  },
  {
    value: "british-journal-of-cancer",
    label: "British Journal of Cancer"
  },
  {
    value: "british-journal-of-dermatology",
    label: "British Journal of Dermatology"
  },
  {
    value: "british-journal-of-haematology",
    label: "British Journal of Haematology"
  },
  {
    value: "british-journal-of-industrial-relations",
    label: "British Journal of Industrial Relations"
  },
  {
    value: "british-journal-of-pharmacology",
    label: "British Journal of Pharmacology"
  },
  {
    value: "british-journal-of-political-science",
    label: "British Journal of Political Science"
  },
  {
    value: "british-journal-of-surgery",
    label: "British Journal of Surgery"
  },
  {
    value: "budownictwo-i-architektura-pl",
    label: "Budownictwo i Architektura"
  },
  {
    value: "building-structure",
    label: "Building Structure (\u4E2D\u6587)"
  },
  {
    value: "buletin-agrohorti",
    label: "Buletin Agrohorti"
  },
  {
    value: "bulletin-de-correspondance-hellenique",
    label: "Bulletin de correspondance hell\xE9nique"
  },
  {
    value: "bulletin-de-la-societe-entomologique-de-france",
    label: "Bulletin de la Soci\xE9t\xE9 Entomologique de France"
  },
  {
    value: "bulletin-de-la-societe-prehistorique-francaise",
    label: "Bulletin de la Soci\xE9t\xE9 pr\xE9historique fran\xE7aise (Fran\xE7ais)"
  },
  {
    value: "bulletin-du-centre-detudes-medievales-dauxerre",
    label: "Bulletin du Centre d\u2019\xE9tudes m\xE9di\xE9vales d\u2019Auxerre (Fran\xE7ais)"
  },
  {
    value: "bulletin-of-geosciences",
    label: "Bulletin of Geosciences"
  },
  {
    value: "bulletin-of-marine-science",
    label: "Bulletin of Marine Science"
  },
  {
    value: "bulletin-of-the-american-schools-of-oriental-research",
    label: "Bulletin of the American Schools of Oriental Research"
  },
  {
    value: "bulletin-of-the-seismological-society-of-america",
    label: "Bulletin of the Seismological Society of America"
  },
  {
    value: "bursa-uludag-universitesi-egitim-bilimleri-enstitusu",
    label: "Bursa Uluda\u011F \xDCniversitesi - E\u011Fitim Bilimleri Enstit\xFCs\xFC"
  },
  {
    value: "bursa-uludag-universitesi-fen-bilimleri-enstitusu",
    label: "Bursa Uludag \xDCniversitesi Fen Bilimleri Enstit\xFCs\xFC"
  },
  {
    value: "bursa-uludag-universitesi-saglik-bilimleri-enstitusu",
    label: "Bursa Uluda\u011F \xDCniversitesi - Sa\u011Fl\u0131k Bilimleri Enstit\xFCs\xFC"
  },
  {
    value: "bursa-uludag-universitesi-sosyal-bilimler-enstitusu-metinici-atif",
    label: "Bursa Uluda\u011F \xDCniversitesi - Sosyal Bilimler Enstit\xFCs\xFC (metinici atif)"
  },
  {
    value: "bursa-uludag-universitesi-sosyal-bilimler-enstitusu",
    label: "Bursa Uluda\u011F \xDCniversitesi - Sosyal Bilimler Enstit\xFCs\xFC"
  },
  {
    value: "business-ethics-a-european-review",
    label: "Business Ethics: A European Review"
  },
  {
    value: "byzantina-symmeikta",
    label: "BYZANTINA SYMMEIKTA"
  },
  {
    value: "byzantine-and-modern-greek-studies",
    label: "Byzantine and Modern Greek Studies"
  },
  {
    value: "cahiers-d-ethnomusicologie",
    label: "Cahiers d'ethnomusicologie (Fran\xE7ais)"
  },
  {
    value: "cahiers-du-centre-gustave-glotz",
    label: "Cahiers du Centre Gustave-Glotz (Fran\xE7ais)"
  },
  {
    value: "california-agriculture",
    label: "California Agriculture"
  },
  {
    value: "cambridge-journal-of-economics",
    label: "Cambridge Journal of Economics"
  },
  {
    value: "cambridge-university-press-author-date",
    label: "Cambridge University Press (author-date)"
  },
  {
    value: "cambridge-university-press-law-note",
    label: "Cambridge University Press - Law (note)"
  },
  {
    value: "cambridge-university-press-note",
    label: "Cambridge University Press (note)"
  },
  {
    value: "cambridge-university-press-numeric",
    label: "Cambridge University Press (numeric)"
  },
  {
    value: "campus-adventiste-du-saleve-faculte-adventiste-de-theologie",
    label: "Campus adventiste du Sal\xE8ve - Facult\xE9 adventiste de th\xE9ologie (Fran\xE7ais)"
  },
  {
    value: "canadian-biosystems-engineering",
    label: "Canadian Biosystems Engineering"
  },
  {
    value: "canadian-geotechnical-journal",
    label: "Canadian Geotechnical Journal"
  },
  {
    value: "canadian-journal-of-chemistry",
    label: "Canadian Journal of Chemistry"
  },
  {
    value: "canadian-journal-of-dietetic-practice-and-research",
    label: "Canadian Journal of Dietetic Practice and Research"
  },
  {
    value: "canadian-journal-of-earth-sciences",
    label: "Canadian Journal of Earth Sciences"
  },
  {
    value: "canadian-journal-of-economics",
    label: "Canadian Journal of Economics"
  },
  {
    value: "canadian-journal-of-fisheries-and-aquatic-sciences",
    label: "Canadian Journal of Fisheries and Aquatic Sciences"
  },
  {
    value: "canadian-journal-of-physics",
    label: "Canadian Journal of Physics"
  },
  {
    value: "canadian-journal-of-public-health",
    label: "Canadian Journal of Public Health"
  },
  {
    value: "canadian-journal-of-soil-science",
    label: "Canadian Journal of Soil Science"
  },
  {
    value: "canadian-public-policy",
    label: "Canadian Public Policy"
  },
  {
    value: "cancer-biomarkers",
    label: "Cancer Biomarkers"
  },
  {
    value: "cancer-drug-resistance",
    label: "Cancer Drug Resistance"
  },
  {
    value: "cancer-translational-medicine",
    label: "Cancer Translational Medicine"
  },
  {
    value: "carcinogenesis",
    label: "Carcinogenesis"
  },
  {
    value: "cardiff-university-harvard",
    label: "Cardiff University - Harvard"
  },
  {
    value: "cardiff-university-vancouver",
    label: "Cardiff University - Vancouver"
  },
  {
    value: "cardiocore",
    label: "Cardiocore (Espa\xF1ol)"
  },
  {
    value: "cath-lab-digest",
    label: "Cath Lab Digest"
  },
  {
    value: "catholic-biblical-association",
    label: "Catholic Biblical Association (full note)"
  },
  {
    value: "cell-numeric-superscript",
    label: "Cell journals (numeric, superscript)"
  },
  {
    value: "cell-numeric",
    label: "Cell journals (numeric)"
  },
  {
    value: "cell-research",
    label: "Cell Research"
  },
  {
    value: "cell-structure-and-function",
    label: "Cell Structure and Function"
  },
  {
    value: "cell-transplantation",
    label: "Cell Transplantation"
  },
  {
    value: "cell",
    label: "Cell"
  },
  {
    value: "cellular-and-molecular-bioengineering",
    label: "Cellular and Molecular Bioengineering"
  },
  {
    value: "cellular-and-molecular-gastroenterology-and-hepatology",
    label: "Cellular and Molecular Gastroenterology and Hepatology"
  },
  {
    value: "centaurus",
    label: "Centaurus"
  },
  {
    value: "centre-de-recherche-sur-les-civilisations-de-l-asie-orientale-auteur-date",
    label: "Centre de recherche sur les civilisations de l\u2019Asie orientale (Fran\xE7ais - Auteur, Date)"
  },
  {
    value: "centre-de-recherche-sur-les-civilisations-de-l-asie-orientale",
    label: "Centre de recherche sur les civilisations de l'Asie orientale (Fran\xE7ais - note)"
  },
  {
    value: "cerebral-cortex",
    label: "Cerebral Cortex"
  },
  {
    value: "ceska-zemedelska-univerzita-v-praze-fakulta-agrobiologie-potravinovych-a-prirodnich-zdroju",
    label: "\u010Cesk\xE1 zem\u011Bd\u011Blsk\xE1 univerzita v Praze - Fakulta agrobiologie, potravinov\xFDch a p\u0159\xEDrodn\xEDch zdroj\u016F"
  },
  {
    value: "changer-d-epoque",
    label: "Changer d'\xE9poque (Fran\xE7ais)"
  },
  {
    value: "chemical-and-pharmaceutical-bulletin",
    label: "Chemical and Pharmaceutical Bulletin"
  },
  {
    value: "chemical-biology-and-drug-design",
    label: "Chemical Biology & Drug Design"
  },
  {
    value: "chemical-engineering-progress",
    label: "Chemical Engineering Progress"
  },
  {
    value: "chemical-senses",
    label: "Chemical Senses"
  },
  {
    value: "chemie-ingenieur-technik",
    label: "Chemie Ingenieur Technik"
  },
  {
    value: "chemistry-education-research-and-practice",
    label: "Chemistry Education Research and Practice"
  },
  {
    value: "chest",
    label: "Chest"
  },
  {
    value: "chicago-annotated-bibliography",
    label: "Chicago Manual of Style 17th edition (note, annotated bibliography)"
  },
  {
    value: "chicago-author-date-16th-edition",
    label: "Chicago Manual of Style 16th edition (author-date)"
  },
  {
    value: "chicago-author-date-basque",
    label: "Chicago Manual of Style 16th edition (author-date, Euskara)"
  },
  {
    value: "chicago-author-date-de",
    label: "Chicago Manual of Style 16th edition (author-date, Deutsch)"
  },
  {
    value: "chicago-author-date-fr",
    label: "Chicago Manual of Style 17th edition (author-date, Fran\xE7ais)"
  },
  {
    value: "chicago-author-date",
    label: "Chicago Manual of Style 17th edition (author-date)"
  },
  {
    value: "chicago-figures",
    label: "Chicago Manual of Style 16th edition (figures and illustrations)"
  },
  {
    value: "chicago-fullnote-bibliography-16th-edition",
    label: "Chicago Manual of Style 16th edition (full note)"
  },
  {
    value: "chicago-fullnote-bibliography-fr",
    label: "Chicago Manual of Style 17th edition (full note, Fran\xE7ais)"
  },
  {
    value: "chicago-fullnote-bibliography-short-title-subsequent",
    label: "Chicago Manual of Style 17th edition (full note, short title subsequent)"
  },
  {
    value: "chicago-fullnote-bibliography-with-ibid",
    label: "Chicago Manual of Style 17th edition (full note, with Ibid.)"
  },
  {
    value: "chicago-fullnote-bibliography",
    label: "Chicago Manual of Style 17th edition (full note)"
  },
  {
    value: "chicago-library-list",
    label: "Chicago Manual of Style 17th edition (library list)"
  },
  {
    value: "chicago-note-bibliography-16th-edition",
    label: "Chicago Manual of Style 16th edition (note)"
  },
  {
    value: "chicago-note-bibliography-with-ibid",
    label: "Chicago Manual of Style 17th edition (note, with Ibid.)"
  },
  {
    value: "chicago-note-bibliography",
    label: "Chicago Manual of Style 17th edition (note)"
  },
  {
    value: "chimia",
    label: "CHIMIA"
  },
  {
    value: "china-information",
    label: "China Information"
  },
  {
    value: "china-national-standard-gb-t-7714-2015-author-date",
    label: "China National Standard GB/T 7714-2015 (author-date, \u4E2D\u6587)"
  },
  {
    value: "china-national-standard-gb-t-7714-2015-note",
    label: "China National Standard GB/T 7714-2015 (note, \u4E2D\u6587)"
  },
  {
    value: "china-national-standard-gb-t-7714-2015-numeric",
    label: "China National Standard GB/T 7714-2015 (numeric, \u4E2D\u6587)"
  },
  {
    value: "chinese-gb7714-1987-numeric",
    label: "China National Standard GB/T 7714-1987 (numeric, \u4E2D\u6587)"
  },
  {
    value: "chinese-gb7714-2005-author-date",
    label: "China National Standard GB/T 7714-2005 (author-date, \u4E2D\u6587)"
  },
  {
    value: "chinese-gb7714-2005-numeric",
    label: "China National Standard GB/T 7714-2005 (numeric, \u4E2D\u6587)"
  },
  {
    value: "chinese-journal-of-aeronautics",
    label: "Chinese Journal of Aeronautics"
  },
  {
    value: "chinese-medical-journal",
    label: "Chinese Medical Journal"
  },
  {
    value: "chroniques-des-activites-archeologiques-de-l-ecole-francaise-de-rome",
    label: "Chroniques des activit\xE9s arch\xE9ologiques de l'Ecole fran\xE7aise de Rome"
  },
  {
    value: "chungara-revista-de-antropologia-chilena",
    label: "Chungara Revista de Antropolog\xEDa Chilena (Espa\xF1ol - Chile)"
  },
  {
    value: "circulation-journal",
    label: "Circulation Journal"
  },
  {
    value: "circulation",
    label: "Circulation"
  },
  {
    value: "cirugia-cardiovascular",
    label: "Cirugia Cardiovascular (Espa\xF1ol)"
  },
  {
    value: "citation-compass-apa-note",
    label: "Citation Compass (Kildekompasset) - APA (note)"
  },
  {
    value: "citizen-science-theory-and-practice",
    label: "Citizen Science: Theory and Practice"
  },
  {
    value: "civilta-italiana",
    label: "Civilt\xE0 Italiana (Italiano)"
  },
  {
    value: "civitas-revista-de-ciencias-sociais",
    label: "Civitas: Revista de Ci\xEAncias Sociais"
  },
  {
    value: "cladistics",
    label: "Cladistics"
  },
  {
    value: "clara-architecture-recherche",
    label: "CLARA Architecture/Recherche (Fran\xE7ais)"
  },
  {
    value: "clay-minerals",
    label: "Clay Minerals"
  },
  {
    value: "clays-and-clay-minerals",
    label: "Clays and Clay Minerals"
  },
  {
    value: "climate-change-economics",
    label: "Climate Change Economics"
  },
  {
    value: "clinica-e-investigacion-en-arteriosclerosis",
    label: "Cl\xEDnica e Investigaci\xF3n en Arteriosclerosis (Espa\xF1ol)"
  },
  {
    value: "clinical-anatomy",
    label: "Clinical Anatomy"
  },
  {
    value: "clinical-dysmorphology",
    label: "Clinical Dysmorphology"
  },
  {
    value: "clinical-gastroenterology-and-hepatology",
    label: "Clinical Gastroenterology and Hepatology"
  },
  {
    value: "clinical-hemorheology-and-microcirculation",
    label: "Clinical Hemorheology and Microcirculation"
  },
  {
    value: "clinical-infectious-diseases",
    label: "Clinical Infectious Diseases"
  },
  {
    value: "clinical-journal-of-sport-medicine",
    label: "Clinical Journal of Sport Medicine"
  },
  {
    value: "clinical-journal-of-the-american-society-of-nephrology",
    label: "Clinical Journal of the American Society of Nephrology"
  },
  {
    value: "clinical-management-issues",
    label: "Clinical Management Issues"
  },
  {
    value: "clinical-nuclear-medicine",
    label: "Clinical Nuclear Medicine"
  },
  {
    value: "clinical-oral-implants-research",
    label: "Clinical Oral Implants Research"
  },
  {
    value: "clinical-orthopaedics-and-related-research",
    label: "Clinical Orthopaedics and Related Research"
  },
  {
    value: "clinical-otolaryngology",
    label: "Clinical Otolaryngology"
  },
  {
    value: "clinical-pharmacology-and-therapeutics",
    label: "Clinical Pharmacology & Therapeutics"
  },
  {
    value: "clinical-physiology-and-functional-imaging",
    label: "Clinical Physiology and Functional Imaging"
  },
  {
    value: "clinical-radiology",
    label: "Clinical Radiology"
  },
  {
    value: "clinical-spine-surgery",
    label: "Clinical Spine Surgery"
  },
  {
    value: "clio-medica",
    label: "Clio Medica"
  },
  {
    value: "cns-and-neurological-disorders-drug-targets",
    label: "CNS & Neurological Disorders - Drug Targets"
  },
  {
    value: "cns-spectrums",
    label: "CNS Spectrums"
  },
  {
    value: "cold-spring-harbor-laboratory-press",
    label: "Cold Spring Harbor Laboratory Press"
  },
  {
    value: "collection-de-l-ecole-francaise-de-rome-full-note",
    label: "Collection de l'Ecole fran\xE7aise de Rome (full note, Fran\xE7ais)"
  },
  {
    value: "collection-de-l-ecole-francaise-de-rome-note",
    label: "Collection de l'Ecole fran\xE7aise de Rome (note, Fran\xE7ais)"
  },
  {
    value: "collection-du-centre-jean-berard",
    label: "Collection du Centre Jean-B\xE9rard (Fran\xE7ais)"
  },
  {
    value: "collections-electroniques-de-l-inha-author-date",
    label: "Collections \xE9lectroniques de l'INHA (author-date, Fran\xE7ais)"
  },
  {
    value: "collections-electroniques-de-l-inha-full-note",
    label: "Collections \xE9lectroniques de l'INHA (full note, Fran\xE7ais)"
  },
  {
    value: "college-montmorency",
    label: "Coll\xE8ge Montmorency (note, Fran\xE7ais - Canada)"
  },
  {
    value: "college-of-naturopathic-medicine",
    label: "College of Naturopathic Medicine"
  },
  {
    value: "colombian-journal-of-anesthesiology",
    label: "Colombian Journal of Anesthesiology"
  },
  {
    value: "colorado-state-university-school-of-biomedical-engineering",
    label: "Colorado State University - School of Biomedical Engineering"
  },
  {
    value: "comision-economica-para-america-latina-y-el-caribe",
    label: "Comisi\xF3n Econ\xF3mica para Am\xE9rica Latina y el Caribe (Espa\xF1ol)"
  },
  {
    value: "common-market-law-review",
    label: "Common Market Law Review"
  },
  {
    value: "communication-et-langages",
    label: "Communication et Langages"
  },
  {
    value: "comparativ",
    label: "Comparativ"
  },
  {
    value: "comparative-politics",
    label: "Comparative Politics"
  },
  {
    value: "comparative-population-studies",
    label: "Comparative Population Studies"
  },
  {
    value: "computer-und-recht",
    label: "Computer und Recht (Deutsch)"
  },
  {
    value: "conservation-and-society",
    label: "Conservation & Society"
  },
  {
    value: "conservation-biology",
    label: "Conservation Biology"
  },
  {
    value: "conservation-letters",
    label: "Conservation Letters"
  },
  {
    value: "conservation-physiology",
    label: "Conservation Physiology"
  },
  {
    value: "contemporary-accounting-research",
    label: "Contemporary Accounting Research"
  },
  {
    value: "continuity-and-change",
    label: "Continuity and Change"
  },
  {
    value: "contributions-to-the-archaeology-of-egypt-nubia-and-the-levant",
    label: "Contributions to the Archaeology of Egypt, Nubia and the Levant"
  },
  {
    value: "copeia",
    label: "Copeia"
  },
  {
    value: "copernicus-publications",
    label: "Copernicus Publications"
  },
  {
    value: "coral-reefs",
    label: "Coral Reefs"
  },
  {
    value: "cornea",
    label: "Cornea"
  },
  {
    value: "corrosion",
    label: "Corrosion"
  },
  {
    value: "council-of-science-editors-alphabetical",
    label: "Council of Science Editors, Citation-Name (numeric, sorted alphabetically)"
  },
  {
    value: "council-of-science-editors-author-date",
    label: "Council of Science Editors, Name-Year (author-date)"
  },
  {
    value: "council-of-science-editors-brackets",
    label: "Council of Science Editors, Citation-Sequence (numeric, brackets)"
  },
  {
    value: "council-of-science-editors",
    label: "Council of Science Editors, Citation-Sequence (numeric)"
  },
  {
    value: "cranfield-university-numeric",
    label: "Cranfield University (numeric)"
  },
  {
    value: "creativity-and-innovation-management",
    label: "Creativity and Innovation Management"
  },
  {
    value: "critical-care-medicine",
    label: "Critical Care Medicine"
  },
  {
    value: "critical-reviews-in-plant-sciences",
    label: "Critical Reviews in Plant Sciences"
  },
  {
    value: "critical-reviews-in-solid-state-and-materials-sciences",
    label: "Critical Reviews in Solid State and Materials Sciences"
  },
  {
    value: "crop-breeding-and-applied-biotechnology",
    label: "Crop Breeding and Applied Biotechnology"
  },
  {
    value: "crustaceana",
    label: "Crustaceana"
  },
  {
    value: "cuadernos-de-filologia-clasica",
    label: "Cuadernos de Filolog\xEDa Cl\xE1sica. Estudios Griegos e Indoeuropeos (autor-a\xF1o, Espa\xF1ol)"
  },
  {
    value: "cultivos-tropicales",
    label: "Cultivos Tropicales (Espa\xF1ol)"
  },
  {
    value: "cultural-geographies",
    label: "cultural geographies"
  },
  {
    value: "cultural-studies-of-science-education",
    label: "Cultural Studies of Science Education"
  },
  {
    value: "culture-medicine-and-psychiatry",
    label: "Culture, Medicine, and Psychiatry"
  },
  {
    value: "cureus",
    label: "Cureus"
  },
  {
    value: "current-alzheimer-research",
    label: "Current Alzheimer Research"
  },
  {
    value: "current-gene-therapy",
    label: "Current Gene Therapy"
  },
  {
    value: "current-neurology-aktualnosci-neurologiczne",
    label: "Current Neurology - Aktualno\u015Bci Neurologiczne"
  },
  {
    value: "current-opinion-in-endocrinology-diabetes-and-obesity",
    label: "Current Opinion in Endocrinology, Diabetes and Obesity"
  },
  {
    value: "current-opinion",
    label: "Current Opinion journals"
  },
  {
    value: "current-pharmaceutical-design",
    label: "Current Pharmaceutical Design"
  },
  {
    value: "current-proteomics",
    label: "Current Proteomics"
  },
  {
    value: "current-protocols",
    label: "Current Protocols journals"
  },
  {
    value: "current-science",
    label: "Current Science"
  },
  {
    value: "current-topics-in-medicinal-chemistry",
    label: "Current Topics in Medicinal Chemistry"
  },
  {
    value: "currents-in-biblical-research",
    label: "Currents in Biblical Research"
  },
  {
    value: "cybium",
    label: "Cybium"
  },
  {
    value: "cytometry",
    label: "Cytometry"
  },
  {
    value: "data-science-journal",
    label: "Data Science Journal"
  },
  {
    value: "database",
    label: "Database"
  },
  {
    value: "de-buck",
    label: "De Buck (Nederlands)"
  },
  {
    value: "de-montfort-university-harvard",
    label: "De Montfort University - Harvard"
  },
  {
    value: "decision-sciences",
    label: "Decision Sciences"
  },
  {
    value: "demographic-research",
    label: "Demographic Research"
  },
  {
    value: "der-moderne-staat",
    label: "der moderne staat (Deutsch)"
  },
  {
    value: "dermatology-online-journal",
    label: "Dermatology Online Journal"
  },
  {
    value: "deutsche-gesellschaft-fur-psychologie",
    label: "Deutsche Gesellschaft f\xFCr Psychologie 5. Auflage (Deutsch)"
  },
  {
    value: "deutsche-sprache",
    label: "Deutsche Sprache (Deutsch)"
  },
  {
    value: "deutsches-archaologisches-institut",
    label: "Deutsches Arch\xE4ologisches Institut"
  },
  {
    value: "deutsches-arzteblatt",
    label: "Deutsches \xC4rzteblatt"
  },
  {
    value: "developing-world-bioethics",
    label: "Developing World Bioethics"
  },
  {
    value: "development-and-change",
    label: "Development and Change"
  },
  {
    value: "development-policy-review",
    label: "Development Policy Review"
  },
  {
    value: "developmental-medicine-and-child-neurology",
    label: "Developmental Medicine & Child Neurology"
  },
  {
    value: "developmental-neurobiology",
    label: "Developmental Neurobiology"
  },
  {
    value: "diabetologia",
    label: "Diabetologia"
  },
  {
    value: "diagnostico-prenatal",
    label: "Diagn\xF3stico Prenatal (Espa\xF1ol)"
  },
  {
    value: "dialisis-y-trasplante",
    label: "Dialisis y Trasplante (Espa\xF1ol)"
  },
  {
    value: "diatom-research",
    label: "Diatom Research"
  },
  {
    value: "die-bachelorarbeit-samac-et-al-in-text",
    label: "Die Bachelorarbeit (Samac et al.) (in-text, Deutsch)"
  },
  {
    value: "die-bachelorarbeit-samac-et-al-note",
    label: "Die Bachelorarbeit (Samac et al.) (note, Deutsch)"
  },
  {
    value: "digital-humanities-im-deutschsprachigen-raum",
    label: "Digital Humanities im deutschsprachigen Raum (Deutsch)"
  },
  {
    value: "digital-scholarship-in-the-humanities",
    label: "Digital Scholarship in the Humanities"
  },
  {
    value: "din-1505-2-alphanumeric",
    label: "DIN 1505-2 (alphanumeric, Deutsch) - standard superseded by ISO-690"
  },
  {
    value: "din-1505-2-numeric-alphabetical",
    label: "DIN 1505-2 (numeric, sorted alphabetically, Deutsch) - standard superseded by ISO-690"
  },
  {
    value: "din-1505-2-numeric",
    label: "DIN 1505-2 (numeric, Deutsch) - standard superseded by ISO-690"
  },
  {
    value: "din-1505-2",
    label: "DIN 1505-2 (author-date, Deutsch) - standard superseded by ISO-690"
  },
  {
    value: "diplo",
    label: "Diplo"
  },
  {
    value: "disability-and-rehabilitation",
    label: "Disability and Rehabilitation"
  },
  {
    value: "discovery-medicine",
    label: "Discovery Medicine"
  },
  {
    value: "dna-research",
    label: "DNA Research"
  },
  {
    value: "documents-d-archeologie-francaise",
    label: "Documents d'arch\xE9ologie fran\xE7aise (Fran\xE7ais)"
  },
  {
    value: "donau-universitat-krems-department-fur-e-governance-in-wirthschaft-und-verwaltung",
    label: "Donau-Universit\xE4t Krems - Department f\xFCr E-Governance in Wirtschaft und Verwaltung (Deutsch - \xD6sterreich)"
  },
  {
    value: "drug-development-research",
    label: "Drug Development Research"
  },
  {
    value: "drug-testing-and-analysis",
    label: "Drug Testing and Analysis"
  },
  {
    value: "drugs-of-today",
    label: "Drugs of Today"
  },
  {
    value: "durban-university-of-technology-harvard",
    label: "Durban University of Technology - Harvard"
  },
  {
    value: "e3s-web-of-conferences",
    label: "E3S Web of Conferences"
  },
  {
    value: "ear-and-hearing",
    label: "Ear and Hearing"
  },
  {
    value: "early-christianity",
    label: "Early Christianity"
  },
  {
    value: "early-medieval-europe",
    label: "Early Medieval Europe"
  },
  {
    value: "early-music-history",
    label: "Early Music History"
  },
  {
    value: "earth-surface-processes-and-landforms",
    label: "Earth Surface Processes and Landforms"
  },
  {
    value: "earthquake-engineering-and-structural-dynamics",
    label: "Earthquake Engineering & Structural Dynamics"
  },
  {
    value: "earthquake-spectra",
    label: "Earthquake Spectra"
  },
  {
    value: "ecclesial-practices",
    label: "Ecclesial Practices"
  },
  {
    value: "ecole-de-technologie-superieure-apa",
    label: "\xC9cole de technologie sup\xE9rieure - APA (Fran\xE7ais - Canada)"
  },
  {
    value: "ecole-pratique-des-hautes-etudes-sciences-historiques-et-philologiques",
    label: "\xC9cole Pratique des Hautes \xC9tudes - Sciences historiques et philologiques (Fran\xE7ais)"
  },
  {
    value: "ecological-entomology",
    label: "Ecological Entomology"
  },
  {
    value: "ecological-restoration",
    label: "Ecological Restoration"
  },
  {
    value: "ecology-and-society",
    label: "Ecology and Society"
  },
  {
    value: "ecology-letters",
    label: "Ecology Letters"
  },
  {
    value: "ecology-of-freshwater-fish",
    label: "Ecology of Freshwater Fish"
  },
  {
    value: "ecology",
    label: "Ecology"
  },
  {
    value: "econometrica",
    label: "Econometrica"
  },
  {
    value: "economia-y-politica",
    label: "Econom\xEDa y Pol\xEDtica (Espa\xF1ol - Chile)"
  },
  {
    value: "economic-commission-for-latin-america-and-the-caribbean",
    label: "Economic Commission for Latin America and the Caribbean"
  },
  {
    value: "economic-geology",
    label: "Economic Geology"
  },
  {
    value: "economie-et-statistique",
    label: "\xC9conomie et Statistique (Fran\xE7ais)"
  },
  {
    value: "ecoscience",
    label: "\xC9coscience"
  },
  {
    value: "ecosistemas",
    label: "Ecosistemas (Espa\xF1ol)"
  },
  {
    value: "ecosystems",
    label: "Ecosystems"
  },
  {
    value: "edward-elgar-business-and-social-sciences",
    label: "Edward Elgar Publishing - Business and Social Sciences"
  },
  {
    value: "effective-altruism-wiki",
    label: "Effective Altruism Wiki"
  },
  {
    value: "egretta",
    label: "Egretta (Deutsch - \xD6sterreich)"
  },
  {
    value: "einaudi",
    label: "Einaudi (Italiano)"
  },
  {
    value: "eksploatacja-i-niezawodnosc",
    label: "Eksploatacja i Niezawodnosc - Maintenance and Reliability"
  },
  {
    value: "el-profesional-de-la-informacion",
    label: "Profesional de la informaci\xF3n (Espa\xF1ol)"
  },
  {
    value: "electrophoresis",
    label: "Electrophoresis"
  },
  {
    value: "elementa",
    label: "Elementa"
  },
  {
    value: "elife",
    label: "eLife"
  },
  {
    value: "elsevier-harvard-without-titles",
    label: "Elsevier - Harvard (without titles)"
  },
  {
    value: "elsevier-harvard",
    label: "Elsevier - Harvard (with titles)"
  },
  {
    value: "elsevier-harvard2",
    label: "Elsevier - Harvard 2"
  },
  {
    value: "elsevier-vancouver-author-date",
    label: "Elsevier - Vancouver (author-date)"
  },
  {
    value: "elsevier-vancouver",
    label: "Elsevier - Vancouver"
  },
  {
    value: "elsevier-with-titles-alphabetical",
    label: "Elsevier (numeric, with titles, sorted alphabetically)"
  },
  {
    value: "elsevier-with-titles",
    label: "Elsevier (numeric, with titles)"
  },
  {
    value: "elsevier-without-titles",
    label: "Elsevier (numeric, without titles)"
  },
  {
    value: "embnet-journal",
    label: "EMBnet.journal"
  },
  {
    value: "embo-press",
    label: "EMBO Press"
  },
  {
    value: "emerald-harvard",
    label: "Emerald - Harvard"
  },
  {
    value: "emu-austral-ornithology",
    label: "Emu - Austral Ornithology"
  },
  {
    value: "endocrine-connections",
    label: "Endocrine Connections"
  },
  {
    value: "endocrine-press",
    label: "Endocrine Press"
  },
  {
    value: "endoscopia",
    label: "Endoscopia (Espa\xF1ol)"
  },
  {
    value: "eneuro",
    label: "eNeuro"
  },
  {
    value: "enfermeria-clinica",
    label: "Enfermer\xEDa Cl\xEDnica (Espa\xF1ol)"
  },
  {
    value: "enfermeria-intensiva",
    label: "Enfermer\xEDa Intensiva (Espa\xF1ol)"
  },
  {
    value: "engineered-regeneration",
    label: "Engineered Regeneration"
  },
  {
    value: "engineering-in-life-sciences",
    label: "Engineering in Life Sciences"
  },
  {
    value: "engineering-technology-and-applied-science-research",
    label: "Engineering, Technology & Applied Science Research"
  },
  {
    value: "ens-de-lyon-centre-d-ingenierie-documentaire",
    label: "ENS de Lyon - Centre d'ing\xE9nierie documentaire (Fran\xE7ais)"
  },
  {
    value: "entecho",
    label: "ENTECHO (\u010Ce\u0161tina)"
  },
  {
    value: "entomologia-experimentalis-et-applicata",
    label: "Entomologia Experimentalis et Applicata"
  },
  {
    value: "entomological-society-of-america",
    label: "Entomological Society of America"
  },
  {
    value: "environment-and-planning",
    label: "Environment and Planning"
  },
  {
    value: "environment-and-urbanization",
    label: "Environment and Urbanization"
  },
  {
    value: "environmental-and-engineering-geoscience",
    label: "Environmental & Engineering Geoscience"
  },
  {
    value: "environmental-chemistry",
    label: "Environmental Chemistry"
  },
  {
    value: "environmental-conservation",
    label: "Environmental Conservation"
  },
  {
    value: "environmental-health-perspectives",
    label: "Environmental Health Perspectives"
  },
  {
    value: "environmental-microbiology",
    label: "Environmental Microbiology"
  },
  {
    value: "environmental-values",
    label: "Environmental Values"
  },
  {
    value: "environnement-risques-et-sante",
    label: "Environnement, Risques & Sant\xE9"
  },
  {
    value: "ephemerides-theologicae-lovanienses",
    label: "Ephemerides Theologicae Lovanienses"
  },
  {
    value: "epidemiologie-et-sante-animale",
    label: "\xC9pid\xE9miologie et Sant\xE9 Animale"
  },
  {
    value: "epidemiology-and-infection",
    label: "Epidemiology & Infection"
  },
  {
    value: "epilepsia",
    label: "Epilepsia"
  },
  {
    value: "equine-veterinary-education",
    label: "Equine Veterinary Education"
  },
  {
    value: "equine-veterinary-journal",
    label: "Equine Veterinary Journal"
  },
  {
    value: "ergo",
    label: "Ergo"
  },
  {
    value: "ergoscience",
    label: "ergoscience"
  },
  {
    value: "errata",
    label: "Errata: Publica\xE7\xE3o sobre processos editoriais (Portugu\xEAs - Brasil)"
  },
  {
    value: "escuela-nacional-de-antropologia-e-historia-author-date",
    label: "Escuela Nacional de Antropolog\xEDa e Historia (autor-fecha, Espa\xF1ol - M\xE9xico)"
  },
  {
    value: "escuela-nacional-de-antropologia-e-historia-full-note",
    label: "Escuela Nacional de Antropolog\xEDa e Historia (nota completa, Espa\xF1ol - M\xE9xico)"
  },
  {
    value: "escuela-nacional-de-antropologia-e-historia-short-note",
    label: "Escuela Nacional de Antropolog\xEDa e Historia (nota corta, Espa\xF1ol - M\xE9xico)"
  },
  {
    value: "estuaries-and-coasts",
    label: "Estuaries and Coasts"
  },
  {
    value: "estudios-de-cultura-maya",
    label: "Estudios de Cultura Maya (Espa\xF1ol - M\xE9xico)"
  },
  {
    value: "estudios-de-fonetica-experimental",
    label: "Estudios de Fon\xE9tica Experimental"
  },
  {
    value: "estudios-hispanicos",
    label: "Estudios Hisp\xE1nicos (Espa\xF1ol)"
  },
  {
    value: "ethics-book-reviews",
    label: "Ethics (for book reviews)"
  },
  {
    value: "ethnobiology-and-conservation",
    label: "Ethnobiology and Conservation"
  },
  {
    value: "ethnobiology-letters",
    label: "Ethnobiology Letters"
  },
  {
    value: "ethnographiques-org",
    label: "ethnographiques.org (Fran\xE7ais)"
  },
  {
    value: "ethnologie-francaise",
    label: "Ethnologie fran\xE7aise (Fran\xE7ais)"
  },
  {
    value: "ethnomusicology",
    label: "Ethnomusicology"
  },
  {
    value: "etri-journal",
    label: "ETRI Journal"
  },
  {
    value: "ets-ecole-de-technologie-superieure",
    label: "\xC9TS - \xC9cole de technologie sup\xE9rieure (Fran\xE7ais - Canada)"
  },
  {
    value: "eurasian-journal-of-medical-investigation",
    label: "Eurasian Journal of Medical Investigation"
  },
  {
    value: "eurasian-journal-of-medicine-and-oncology",
    label: "Eurasian Journal of Medicine and Oncology"
  },
  {
    value: "eurointervention",
    label: "EuroIntervention"
  },
  {
    value: "europace",
    label: "Europace"
  },
  {
    value: "european-cells-and-materials",
    label: "European Cells & Materials"
  },
  {
    value: "european-journal-for-philosophy-of-religion",
    label: "European Journal for Philosophy of Religion"
  },
  {
    value: "european-journal-of-anaesthesiology",
    label: "European Journal of Anaesthesiology"
  },
  {
    value: "european-journal-of-clinical-microbiology-and-infectious-diseases",
    label: "European Journal of Clinical Microbiology & Infectious Diseases"
  },
  {
    value: "european-journal-of-emergency-medicine",
    label: "European Journal of Emergency Medicine"
  },
  {
    value: "european-journal-of-endocrinology",
    label: "European Journal of Endocrinology"
  },
  {
    value: "european-journal-of-entomology",
    label: "European Journal of Entomology"
  },
  {
    value: "european-journal-of-human-genetics",
    label: "European Journal of Human Genetics"
  },
  {
    value: "european-journal-of-immunology",
    label: "European Journal of Immunology"
  },
  {
    value: "european-journal-of-information-systems",
    label: "European Journal of Information Systems"
  },
  {
    value: "european-journal-of-international-law",
    label: "European Journal of International Law"
  },
  {
    value: "european-journal-of-microbiology-and-immunology",
    label: "European Journal of Microbiology & Immunology"
  },
  {
    value: "european-journal-of-neuroscience",
    label: "European Journal of Neuroscience"
  },
  {
    value: "european-journal-of-ophthalmology",
    label: "European Journal of Ophthalmology"
  },
  {
    value: "european-journal-of-paediatric-neurology",
    label: "European Journal of Paediatric Neurology"
  },
  {
    value: "european-journal-of-pain",
    label: "European Journal of Pain"
  },
  {
    value: "european-journal-of-political-research",
    label: "European Journal of Political Research"
  },
  {
    value: "european-journal-of-public-health",
    label: "European Journal of Public Health"
  },
  {
    value: "european-journal-of-soil-science",
    label: "European Journal of Soil Science"
  },
  {
    value: "european-journal-of-taxonomy",
    label: "European Journal of Taxonomy"
  },
  {
    value: "european-journal-of-theology",
    label: "European Journal of Theology"
  },
  {
    value: "european-journal-of-ultrasound",
    label: "European Journal of Ultrasound (Ultraschall in der Medizin)"
  },
  {
    value: "european-journal-of-vascular-and-endovascular-surgery",
    label: "European Journal of Vascular and Endovascular Surgery"
  },
  {
    value: "european-respiratory-journal",
    label: "European Respiratory Journal"
  },
  {
    value: "european-retail-research",
    label: "European Retail Research"
  },
  {
    value: "european-review-of-agricultural-economics",
    label: "European Review of Agricultural Economics"
  },
  {
    value: "european-society-of-cardiology",
    label: "European Society of Cardiology"
  },
  {
    value: "european-union-interinstitutional-style-guide-author-date",
    label: "European Union - Interinstitutional Style Guide (author-date)"
  },
  {
    value: "european-union-interinstitutional-style-guide",
    label: "European Union - Interinstitutional Style Guide (note)"
  },
  {
    value: "eva-berlin-konferenz",
    label: "EVA Berlin Konferenz (Deutsch)"
  },
  {
    value: "evidence-based-complementary-and-alternative-medicine",
    label: "Evidence-Based Complementary and Alternative Medicine"
  },
  {
    value: "evolution-and-development",
    label: "Evolution & Development"
  },
  {
    value: "evolution-letters",
    label: "Evolution Letters"
  },
  {
    value: "evolution",
    label: "Evolution"
  },
  {
    value: "evolutionary-anthropology",
    label: "Evolutionary Anthropology"
  },
  {
    value: "evolutionary-ecology-research",
    label: "Evolutionary Ecology Research"
  },
  {
    value: "excli-journal",
    label: "EXCLI Journal"
  },
  {
    value: "exercer",
    label: "exercer (Fran\xE7ais)"
  },
  {
    value: "experimental-biology-and-medicine",
    label: "Experimental Biology and Medicine"
  },
  {
    value: "experimental-biomedical-research",
    label: "Experimental Biomedical Research"
  },
  {
    value: "experimental-dermatology",
    label: "Experimental Dermatology"
  },
  {
    value: "expert-reviews-in-molecular-medicine",
    label: "Expert Reviews in Molecular Medicine"
  },
  {
    value: "express-polymer-letters",
    label: "eXPRESS Polymer Letters"
  },
  {
    value: "extracellular-vesicles-and-circulating-nucleic-acids",
    label: "Extracellular Vesicles and Circulating Nucleic Acids"
  },
  {
    value: "eye",
    label: "Eye"
  },
  {
    value: "fachhochschule-kiel-fachbereich-medien",
    label: "Fachhochschule Kiel - Fachbereich Medien (Deutsch)"
  },
  {
    value: "fachhochschule-sudwestfalen",
    label: "Fachhochschule S\xFCdwestfalen (Deutsch)"
  },
  {
    value: "fachhochschule-vorarlberg-author-date",
    label: "Fachhochschule Vorarlberg (author-date)"
  },
  {
    value: "fachhochschule-vorarlberg-note",
    label: "Fachhochschule Vorarlberg (note)"
  },
  {
    value: "facial-plastic-surgery-clinics-of-north-america",
    label: "Facial Plastic Surgery Clinics of North America"
  },
  {
    value: "facolta-teologica-dell-italia-settentrionale-milano",
    label: "Facolt\xE0 Teologica dell'Italia Settentrionale - Milano (titoli di riviste non abbreviati, Italiano)"
  },
  {
    value: "family-business-review",
    label: "Family Business Review"
  },
  {
    value: "farmeconomia",
    label: "Farmeconomia. Health Economics and Therapeutic Pathways"
  },
  {
    value: "fatigue-and-fracture-of-engineering-materials-and-structures",
    label: "Fatigue & Fracture of Engineering Materials & Structures"
  },
  {
    value: "feminist-economics",
    label: "Feminist Economics"
  },
  {
    value: "feminist-theory",
    label: "Feminist Theory"
  },
  {
    value: "ferdinand-porsche-fern-fachhochschule",
    label: "Ferdinand Porsche Fernfachhochschule (Deutsch - \xD6sterreich)"
  },
  {
    value: "fertility-and-sterility",
    label: "Fertility and Sterility"
  },
  {
    value: "finance-and-society",
    label: "Finance and Society"
  },
  {
    value: "finanzarchiv",
    label: "FinanzArchiv - Public Finance Analysis"
  },
  {
    value: "fine-focus",
    label: "Fine Focus"
  },
  {
    value: "first-break",
    label: "First Break"
  },
  {
    value: "first-monday",
    label: "First Monday"
  },
  {
    value: "fishery-bulletin",
    label: "Fishery Bulletin"
  },
  {
    value: "flavour-and-fragrance-journal",
    label: "Flavour and Fragrance Journal"
  },
  {
    value: "florida-entomologist",
    label: "Florida Entomologist"
  },
  {
    value: "focaal-journal-of-global-and-historical-anthropology",
    label: "Focaal\u2014Journal of Global and Historical Anthropology"
  },
  {
    value: "foerster-geisteswissenschaft",
    label: "Sascha Foerster - Geisteswissenschaft (Deutsch)"
  },
  {
    value: "fold-and-r",
    label: "FOLD&R (Fasti On Line Documents & Research)"
  },
  {
    value: "folia-biologica",
    label: "Folia Biologica"
  },
  {
    value: "folia-morphologia",
    label: "Folia Morphologia"
  },
  {
    value: "food-and-agriculture-organization-of-the-united-nations",
    label: "Food and Agriculture Organization of the United Nations"
  },
  {
    value: "forensic-anthropology",
    label: "Forensic Anthropology"
  },
  {
    value: "forensic-science-review",
    label: "Forensic Science Review"
  },
  {
    value: "forest-science",
    label: "Forest Science"
  },
  {
    value: "forschungsjournal-soziale-bewegungen-fjsb",
    label: "Forschungsjournal Soziale Bewegungen FJSB(German)"
  },
  {
    value: "forum-qualitative-social-research",
    label: "Forum: Qualitative Social Research (English)"
  },
  {
    value: "forum-qualitative-sozialforschung",
    label: "Forum: Qualitative Sozialforschung (Deutsch)"
  },
  {
    value: "frattura-ed-integrita-strutturale-fracture-and-structural-integrity",
    label: "Frattura ed Integrit\xE0 Strutturale - Fracture and Structural Integrity"
  },
  {
    value: "free-radical-research",
    label: "Free Radical Research"
  },
  {
    value: "freie-hochschule-stuttgart",
    label: "Freie Hochschule Stuttgart (Deutsch)"
  },
  {
    value: "freie-universitat-berlin-geographische-wissenschaften",
    label: "Freie Universit\xE4t Berlin - Geographische Wissenschaften (Deutsch)"
  },
  {
    value: "french-politics",
    label: "French Politics"
  },
  {
    value: "french1",
    label: "France (tous les auteurs, num\xE9rotation, Fran\xE7ais)"
  },
  {
    value: "french2",
    label: "France (auteurs et al., num\xE9rotation, Fran\xE7ais)"
  },
  {
    value: "french3",
    label: "France (tous les auteurs, auteur-date, Fran\xE7ais)"
  },
  {
    value: "french4",
    label: "France (auteurs et al., auteur-date, Fran\xE7ais)"
  },
  {
    value: "freshwater-biology",
    label: "Freshwater Biology"
  },
  {
    value: "freshwater-crayfish",
    label: "Freshwater Crayfish"
  },
  {
    value: "freshwater-science",
    label: "Freshwater Science"
  },
  {
    value: "friedrich-schiller-universitat-jena-medizinische-fakultat",
    label: "Friedrich-Schiller-Universit\xE4t Jena - Medizinische Fakult\xE4t (Deutsch)"
  },
  {
    value: "frontiers-in-bioscience",
    label: "Frontiers in Bioscience"
  },
  {
    value: "frontiers-in-ecology-and-the-environment",
    label: "Frontiers in Ecology and the Environment"
  },
  {
    value: "frontiers-in-optics",
    label: "Frontiers in Optics"
  },
  {
    value: "frontiers-in-physics",
    label: "Frontiers in Physics"
  },
  {
    value: "frontiers-medical-journals",
    label: "Frontiers medical journals"
  },
  {
    value: "frontiers-of-biogeography",
    label: "Frontiers of Biogeography"
  },
  {
    value: "frontiers",
    label: "Frontiers journals"
  },
  {
    value: "fundamental-and-applied-limnology",
    label: "Fundamental and Applied Limnology"
  },
  {
    value: "future-medicine",
    label: "Future Medicine journals"
  },
  {
    value: "future-science-group",
    label: "Future Science Group"
  },
  {
    value: "g-giappichelli-editore",
    label: "G. Giappichelli Editore (Italiano)"
  },
  {
    value: "g3",
    label: "G3: Genes, Genomes, Genetics"
  },
  {
    value: "gaceta-sanitaria",
    label: "Gaceta Sanitaria"
  },
  {
    value: "gaia",
    label: "GAIA"
  },
  {
    value: "galatasaray-universitesi-sosyal-bilimler-enstitusu",
    label: "Galatasaray \xDCniversitesi Sosyal Bilimler Enstit\xFCs\xFC"
  },
  {
    value: "gallia-prehistoire",
    label: "Gallia Pr\xE9histoire (Fran\xE7ais)"
  },
  {
    value: "gallia",
    label: "Gallia (Fran\xE7ais)"
  },
  {
    value: "gastroenterology",
    label: "Gastroenterology"
  },
  {
    value: "gastrointestinal-endoscopy-clinics-of-north-america",
    label: "Gastrointestinal Endoscopy Clinics of North America"
  },
  {
    value: "gastrointestinal-intervention",
    label: "Gastrointestinal Intervention"
  },
  {
    value: "gazeta-medica",
    label: "Gazeta M\xE9dica"
  },
  {
    value: "geistes-und-kulturwissenschaften-heilmann",
    label: "Geistes- und Kulturwissenschaften (Heilmann) (Deutsch)"
  },
  {
    value: "generic-style-rules-for-linguistics",
    label: "Generic Style Rules for Linguistics"
  },
  {
    value: "genes-brain-and-behavior",
    label: "Genes, Brain and Behavior"
  },
  {
    value: "genes-to-cells",
    label: "Genes to Cells"
  },
  {
    value: "geneses",
    label: "Gen\xE8ses: Sciences sociales et histoire (Fran\xE7ais)"
  },
  {
    value: "genetics-and-molecular-biology",
    label: "Genetics and Molecular Biology"
  },
  {
    value: "genetics",
    label: "Genetics"
  },
  {
    value: "genome-biology-and-evolution",
    label: "Genome Biology and Evolution"
  },
  {
    value: "genomics-and-informatics",
    label: "Genomics & Informatics"
  },
  {
    value: "geoarchaeology",
    label: "Geoarchaeology"
  },
  {
    value: "geobiology",
    label: "Geobiology"
  },
  {
    value: "geochemical-perspectives-letters",
    label: "Geochemical Perspectives Letters"
  },
  {
    value: "geochimica-et-cosmochimica-acta",
    label: "Geochimica et Cosmochimica Acta"
  },
  {
    value: "geochronometria",
    label: "Geochronometria"
  },
  {
    value: "geografia-fisica-e-dinamica-quaternaria",
    label: "Geografia Fisica e Dinamica Quaternaria"
  },
  {
    value: "geografie-sbornik-cgs",
    label: "Geografie Sborn\xEDk \u010CGS"
  },
  {
    value: "geographie-et-cultures",
    label: "G\xE9ographie et cultures (Fran\xE7ais)"
  },
  {
    value: "geographische-zeitschrift",
    label: "Geographische Zeitschrift"
  },
  {
    value: "geological-magazine",
    label: "Geological Magazine"
  },
  {
    value: "geophysical-journal-international",
    label: "Geophysical Journal International"
  },
  {
    value: "geophysics",
    label: "Geophysics"
  },
  {
    value: "geopolitics",
    label: "Geopolitics"
  },
  {
    value: "georg-august-universitat-gottingen-institut-fur-ethnologie-und-ethnologische-sammlung",
    label: "Georg-August-Universit\xE4t G\xF6ttingen - Institut f\xFCr Ethnologie und Ethnologische Sammlung (Deutsch)"
  },
  {
    value: "geriatrics-and-gerontology-international",
    label: "Geriatrics & Gerontology International"
  },
  {
    value: "geriatrie-et-psychologie-neuropsychiatrie-du-vieillissement",
    label: "G\xE9riatrie et Psychologie Neuropsychiatrie du Vieillissement"
  },
  {
    value: "german-council-of-economic-experts",
    label: "German Council of Economic Experts"
  },
  {
    value: "german-journal-of-agricultural-economics",
    label: "German Journal of Agricultural Economics"
  },
  {
    value: "german-yearbook-of-international-law",
    label: "German Yearbook of International Law"
  },
  {
    value: "geschichte-und-gesellschaft",
    label: "Geschichte und Gesellschaft"
  },
  {
    value: "gesellschaft-fur-popularmusikforschung",
    label: "Gesellschaft fur Popularmusikforschung (Deutsch)"
  },
  {
    value: "gewerblicher-rechtsschutz-und-urheberrecht",
    label: "Gewerblicher Rechtsschutz und Urheberrecht (Deutsch)"
  },
  {
    value: "gigascience",
    label: "GigaScience"
  },
  {
    value: "global-ecology-and-biogeography",
    label: "Global Ecology and Biogeography"
  },
  {
    value: "glossa",
    label: "Glossa"
  },
  {
    value: "gost-r-7-0-5-2008-numeric-alphabetical",
    label: "Russian GOST R 7.0.5-2008 (numeric, sorted alphabetically, \u0420\u0443\u0301\u0441\u0441\u043A\u0438\u0439)"
  },
  {
    value: "gost-r-7-0-5-2008-numeric",
    label: "Russian GOST R 7.0.5-2008 (numeric)"
  },
  {
    value: "gost-r-7-0-5-2008",
    label: "Russian GOST R 7.0.5-2008 (\u0420\u0443\u0301\u0441\u0441\u043A\u0438\u0439)"
  },
  {
    value: "government-and-opposition",
    label: "Government and Opposition"
  },
  {
    value: "grasas-y-aceites",
    label: "Grasas y Aceites"
  },
  {
    value: "griffith-college-harvard",
    label: "Griffith College - Harvard"
  },
  {
    value: "groundwater",
    label: "Groundwater"
  },
  {
    value: "groupe-danthropologie-et-darcheologie-funeraire",
    label: "Groupe d'anthropologie et d'arch\xE9ologie fun\xE9raire (Fran\xE7ais)"
  },
  {
    value: "guide-des-citations-references-et-abreviations-juridiques",
    label: "Guide des citations, r\xE9f\xE9rences et abr\xE9viations juridiques 6e \xE9dition (Fran\xE7ais)"
  },
  {
    value: "guide-pour-la-redaction-et-la-presentation-des-theses-a-lusage-des-doctorants",
    label: "Guide pour la r\xE9daction et la pr\xE9sentation des th\xE8ses \xE0 l'usage des doctorants (Fran\xE7ais)"
  },
  {
    value: "haaga-helia-university-of-applied-sciences-harvard",
    label: "Haaga-Helia ammattikorkeakoulu - Harvard"
  },
  {
    value: "haematologica",
    label: "Haematologica"
  },
  {
    value: "haemophilia",
    label: "Haemophilia"
  },
  {
    value: "hainan-medical-university-journal-publisher",
    label: "Hainan Medical University Journal Publisher"
  },
  {
    value: "hamburg-school-of-food-science",
    label: "Hamburg School of Food Science (diploma, Deutsch)"
  },
  {
    value: "hand",
    label: "HAND"
  },
  {
    value: "handbook-of-clinical-neurology",
    label: "Handbook of Clinical Neurology"
  },
  {
    value: "harvard-anglia-ruskin-university",
    label: "Anglia Ruskin University - Harvard"
  },
  {
    value: "harvard-bournemouth-university",
    label: "Bournemouth University - Harvard"
  },
  {
    value: "harvard-cape-peninsula-university-of-technology",
    label: "Cape Peninsula University of Technology - Harvard"
  },
  {
    value: "harvard-cardiff-university-old",
    label: "Cardiff University - (old) Harvard"
  },
  {
    value: "harvard-cite-them-right-10th-edition",
    label: "Cite Them Right 10th edition - Harvard"
  },
  {
    value: "harvard-cite-them-right-no-et-al",
    label: 'Cite Them Right 11th edition - Harvard (no "et al.")'
  },
  {
    value: "harvard-cite-them-right",
    label: "Cite Them Right 11th edition - Harvard"
  },
  {
    value: "harvard-coventry-university",
    label: "Coventry University - Harvard"
  },
  {
    value: "harvard-cranfield-university",
    label: "Cranfield University - Harvard"
  },
  {
    value: "harvard-deakin-university",
    label: "Deakin University - Harvard"
  },
  {
    value: "harvard-dundalk-institute-of-technology",
    label: "Dundalk Institute of Technology - Harvard"
  },
  {
    value: "harvard-durham-university-business-school",
    label: "Durham University Business School - Harvard"
  },
  {
    value: "harvard-edge-hill-university",
    label: "Edge Hill University - Harvard"
  },
  {
    value: "harvard-european-archaeology",
    label: "European Archaeology - Harvard"
  },
  {
    value: "harvard-fachhochschule-salzburg",
    label: "Fachhochschule Salzburg - Harvard"
  },
  {
    value: "harvard-falmouth-university",
    label: "Falmouth University - Harvard"
  },
  {
    value: "harvard-gesellschaft-fur-bildung-und-forschung-in-europa",
    label: "Gesellschaft f\xFCr Bildung und Forschung in Europa - Harvard (Deutsch)"
  },
  {
    value: "harvard-imperial-college-london",
    label: "Imperial College London - Harvard"
  },
  {
    value: "harvard-institut-fur-praxisforschung-de",
    label: "Institut f\xFCr Praxisforschung - Harvard (Bahr & Frackmann) (Deutsch)"
  },
  {
    value: "harvard-kings-college-london",
    label: "King's College London - Harvard"
  },
  {
    value: "harvard-leeds-beckett-university",
    label: "Leeds Beckett University - Harvard"
  },
  {
    value: "harvard-leeds-metropolitan-university",
    label: "Leeds Metropolitan University - Harvard"
  },
  {
    value: "harvard-limerick",
    label: "University of Limerick (Cite it Right) - Harvard"
  },
  {
    value: "harvard-london-south-bank-university",
    label: "London South Bank University - Harvard"
  },
  {
    value: "harvard-manchester-business-school",
    label: "Manchester Business School - Harvard"
  },
  {
    value: "harvard-manchester-metropolitan-university",
    label: "Manchester Metropolitan University - Harvard"
  },
  {
    value: "harvard-melbourne-polytechnic",
    label: "Melbourne Polytechnic - Harvard"
  },
  {
    value: "harvard-newcastle-university",
    label: "Newcastle University - Harvard"
  },
  {
    value: "harvard-north-west-university",
    label: "North-West University - Harvard"
  },
  {
    value: "harvard-oxford-brookes-university-faculty-of-health-and-life-sciences",
    label: "Oxford Brookes University - Faculty of Health and Life Sciences - Harvard"
  },
  {
    value: "harvard-pontificia-universidad-catolica-del-ecuador",
    label: "Pontificia Universidad Cat\xF3lica del Ecuador (Espa\xF1ol) - Harvard"
  },
  {
    value: "harvard-robert-gordon-university",
    label: "Robert Gordon University - Harvard"
  },
  {
    value: "harvard-staffordshire-university",
    label: "Staffordshire University - Harvard"
  },
  {
    value: "harvard-stellenbosch-university",
    label: "Stellenbosch University - Harvard"
  },
  {
    value: "harvard-swinburne-university-of-technology",
    label: "Swinburne University of Technology - Harvard"
  },
  {
    value: "harvard-the-university-of-melbourne",
    label: "The University of Melbourne - Harvard"
  },
  {
    value: "harvard-the-university-of-northampton",
    label: "The University of Northampton - Harvard"
  },
  {
    value: "harvard-the-university-of-sheffield-school-of-east-asian-studies",
    label: "The University of Sheffield - School of East Asian Studies - Harvard"
  },
  {
    value: "harvard-the-university-of-sheffield-town-and-regional-planning",
    label: "The University of Sheffield - Town and Regional Planning - Harvard"
  },
  {
    value: "harvard-theologisches-seminar-adelshofen",
    label: "Theologisches Seminar Adelshofen - Harvard (Deutsch)"
  },
  {
    value: "harvard-universiti-teknologi-malaysia",
    label: "Universiti Teknologi Malaysia - Harvard"
  },
  {
    value: "harvard-universiti-tunku-abdul-rahman",
    label: "Universiti Tunku Abdul Rahman - Harvard"
  },
  {
    value: "harvard-university-for-the-creative-arts",
    label: "University for the Creative Arts - Harvard"
  },
  {
    value: "harvard-university-of-abertay-dundee",
    label: "University of Abertay Dundee - Harvard"
  },
  {
    value: "harvard-university-of-bath",
    label: "University of Bath - Harvard"
  },
  {
    value: "harvard-university-of-birmingham",
    label: "University of Birmingham - Harvard"
  },
  {
    value: "harvard-university-of-brighton-school-of-environment-and-technology",
    label: "University of Brighton School of Environment & Technology - Harvard"
  },
  {
    value: "harvard-university-of-cape-town",
    label: "University of Cape Town - Harvard"
  },
  {
    value: "harvard-university-of-exeter-geography",
    label: "University of Exeter - Geography - Harvard"
  },
  {
    value: "harvard-university-of-greenwich",
    label: "University of Greenwich - Harvard"
  },
  {
    value: "harvard-university-of-kent",
    label: "University of Kent - Harvard"
  },
  {
    value: "harvard-university-of-leeds",
    label: "University of Leeds - Harvard"
  },
  {
    value: "harvard-university-of-technology-sydney",
    label: "University of Technology Sydney - Harvard"
  },
  {
    value: "harvard-university-of-the-west-of-england",
    label: "University of the West of England (Bristol) - Harvard"
  },
  {
    value: "harvard-university-of-the-west-of-scotland",
    label: "University of the West of Scotland - Harvard"
  },
  {
    value: "harvard-university-of-westminster",
    label: "University of Westminster - Harvard"
  },
  {
    value: "harvard-university-of-wolverhampton",
    label: "University of Wolverhampton - Harvard"
  },
  {
    value: "harvard-university-of-worcester",
    label: "University of Worcester - Harvard"
  },
  {
    value: "harvard-york-st-john-university",
    label: "York St John University - Harvard (pre September 2019 entry)"
  },
  {
    value: "haute-ecole-de-gestion-de-geneve-iso-690",
    label: "Haute \xE9cole de gestion de Gen\xE8ve - ISO 690"
  },
  {
    value: "haute-ecole-pedagogique-fribourg",
    label: "Haute Ecole p\xE9dagogique Fribourg (Fran\xE7ais)"
  },
  {
    value: "hawaii-international-conference-on-system-sciences-proceedings",
    label: "Hawaii International Conference on System Sciences Proceedings"
  },
  {
    value: "health-and-human-rights-journal",
    label: "Health and Human Rights Journal"
  },
  {
    value: "health-and-social-care-in-the-community",
    label: "Health & Social Care in the Community"
  },
  {
    value: "health-economics-policy-and-law",
    label: "Health Economics, Policy and Law"
  },
  {
    value: "health-economics",
    label: "Health Economics"
  },
  {
    value: "health-education-england-harvard",
    label: "Health Education England - Harvard"
  },
  {
    value: "health-education-research",
    label: "Health Education Research"
  },
  {
    value: "health-policy-and-planning",
    label: "Health Policy and Planning"
  },
  {
    value: "health-reform-observer-observatoire-des-reformes-de-sante",
    label: "Health Reform Observer - Observatoire des R\xE9formes de Sant\xE9"
  },
  {
    value: "health-sports-and-rehabilitation-medicine",
    label: "Health, Sports & Rehabilitation Medicine"
  },
  {
    value: "heart-failure-clinics",
    label: "Heart Failure Clinics"
  },
  {
    value: "heart-rhythm",
    label: "Heart Rhythm"
  },
  {
    value: "heidelberg-university-faculty-of-medicine",
    label: "Heidelberg University - Faculty of Medicine (Universit\xE4t Heidelberg - Medizinische Fakult\xE4t Heidelberg)"
  },
  {
    value: "heiliger-dienst",
    label: "Heiliger Dienst (Deutsch)"
  },
  {
    value: "helvetica-chimica-acta",
    label: "Helvetica Chimica Acta"
  },
  {
    value: "hematology-oncology-clinics-of-north-america",
    label: "Hematology/Oncology Clinics of North America"
  },
  {
    value: "hemijska-industrija",
    label: "Hemijska industrija"
  },
  {
    value: "henoch",
    label: "Henoch"
  },
  {
    value: "hepatology",
    label: "Hepatology"
  },
  {
    value: "heredity",
    label: "Heredity"
  },
  {
    value: "herpetologica",
    label: "Herpetologica"
  },
  {
    value: "hiob-ludolf-centre-for-ethiopian-studies-long-names",
    label: "Hiob Ludolf Centre for Ethiopian Studies (long names)"
  },
  {
    value: "hiob-ludolf-centre-for-ethiopian-studies-with-url-doi",
    label: "Hiob Ludolf Centre for Ethiopian Studies (with URL/DOI)"
  },
  {
    value: "hiob-ludolf-centre-for-ethiopian-studies",
    label: "Hiob Ludolf Centre for Ethiopian Studies"
  },
  {
    value: "hipertension-y-riesgo-vascular",
    label: "Hipertensi\xF3n y Riesgo Vascular (Espa\xF1ol)"
  },
  {
    value: "histoire-at-politique",
    label: "Histoire@Politique. Politique, culture, soci\xE9t\xE9 (Fran\xE7ais)"
  },
  {
    value: "histoire-et-mesure",
    label: "Histoire & Mesure (Fran\xE7ais)"
  },
  {
    value: "histopathology",
    label: "Histopathology"
  },
  {
    value: "historia-scribere",
    label: "historia-scribere (Deutsch)"
  },
  {
    value: "historical-materialism",
    label: "Historical Materialism"
  },
  {
    value: "historical-social-research",
    label: "Historical Social Research"
  },
  {
    value: "historio-plus",
    label: "historioPLUS (Deutsch - \xD6sterreich)"
  },
  {
    value: "history-and-theory",
    label: "History and Theory"
  },
  {
    value: "history-australia",
    label: "History Australia"
  },
  {
    value: "history-of-the-human-sciences",
    label: "History of the Human Sciences"
  },
  {
    value: "hochschule-bonn-rhein-sieg",
    label: "Hochschule Bonn-Rhein-Sieg (Harvard, Deutsch)"
  },
  {
    value: "hochschule-fur-soziale-arbeit-fhnw",
    label: "Hochschule f\xFCr Soziale Arbeit FHNW (Deutsch - Schweiz)"
  },
  {
    value: "hochschule-fur-wirtschaft-und-recht-berlin",
    label: "Hochschule f\xFCr Wirtschaft und Recht Berlin (Deutsch)"
  },
  {
    value: "hochschule-hannover-soziale-arbeit",
    label: "Hochschule Hannover - Soziale Arbeit (Deutsch)"
  },
  {
    value: "hochschule-munchen-fakultat-fur-angewandte-sozialwissenschaften",
    label: "Hochschule M\xFCnchen - Fakult\xE4t f\xFCr Angewandte Sozialwissenschaften (Deutsch)"
  },
  {
    value: "hochschule-osnabruck-fakultat-agrarwissenschaften-und-landschaftsarchitektur",
    label: "Hochschule Osnabr\xFCck - Fakult\xE4t Agrarwissenschaften und Landschaftsarchitektur (Deutsch)"
  },
  {
    value: "hochschule-pforzheim-fakultat-fur-wirtschaft-und-recht",
    label: "Hochschule Pforzheim - Fakult\xE4t f\xFCr Wirtschaft und Recht (Deutsch)"
  },
  {
    value: "hong-kong-journal-of-radiology",
    label: "Hong Kong Journal of Radiology"
  },
  {
    value: "hospital-a-domicilio",
    label: "Hospital a Domicilio"
  },
  {
    value: "housing-studies",
    label: "Housing Studies"
  },
  {
    value: "hpb",
    label: "HPB"
  },
  {
    value: "human-brain-mapping",
    label: "Human Brain Mapping"
  },
  {
    value: "human-ecology",
    label: "Human Ecology"
  },
  {
    value: "human-molecular-genetics",
    label: "Human Molecular Genetics"
  },
  {
    value: "human-mutation",
    label: "Human Mutation"
  },
  {
    value: "human-reproduction-update",
    label: "Human Reproduction Update"
  },
  {
    value: "human-reproduction",
    label: "Human Reproduction"
  },
  {
    value: "human-resource-management-journal",
    label: "Human Resource Management Journal"
  },
  {
    value: "human-rights-law-review",
    label: "Human Rights Law Review"
  },
  {
    value: "human-wildlife-interactions",
    label: "Human-Wildlife Interactions"
  },
  {
    value: "humanistica-lovaniensia-journal-of-neo-latin-studies",
    label: "Humanistica Lovaniensia. Journal of Neo-Latin Studies"
  },
  {
    value: "humboldt-state-university-environmental-resources-engineering",
    label: "Humboldt State University - Environmental Resources Engineering"
  },
  {
    value: "hydrobiologia",
    label: "Hydrobiologia"
  },
  {
    value: "hydrological-processes",
    label: "Hydrological Processes"
  },
  {
    value: "hydrological-sciences-journal",
    label: "Hydrological Sciences Journal"
  },
  {
    value: "hypertension-research",
    label: "Hypertension Research"
  },
  {
    value: "hypotheses-in-the-life-sciences",
    label: "Hypotheses in the Life Sciences"
  },
  {
    value: "hystrix-the-italian-journal-of-mammalogy",
    label: "Hystrix, the Italian Journal of Mammalogy"
  },
  {
    value: "iawa-journal",
    label: "IAWA Journal"
  },
  {
    value: "ib-tauris-note",
    label: "I.B. Tauris (note)"
  },
  {
    value: "ibis",
    label: "Ibis"
  },
  {
    value: "ices-journal-of-marine-science",
    label: "ICES Journal of Marine Science"
  },
  {
    value: "idojaras-quarterly-journal-of-the-hungarian-meteorological-service",
    label: "Id\u0151j\xE1r\xE1s - Quarterly Journal of the Hungarian Meteorological Service"
  },
  {
    value: "ie-comunicaciones",
    label: "IE Comunicaciones"
  },
  {
    value: "ieee-transactions-on-medical-imaging",
    label: "IEEE Transactions on Medical Imaging"
  },
  {
    value: "ieee-with-url",
    label: "IEEE (with URL)"
  },
  {
    value: "ieee",
    label: "IEEE"
  },
  {
    value: "iforest",
    label: "iForest"
  },
  {
    value: "igaku-toshokan",
    label: "Igaku Toshokan (\u65E5\u672C\u8A9E)"
  },
  {
    value: "iica-catie",
    label: "IICA-CATIE (Espa\xF1ol)"
  },
  {
    value: "ilahiyat-studies",
    label: "Ilahiyat Studies (full note)"
  },
  {
    value: "im-gesprach",
    label: "Im Gespr\xE4ch - Hefte der Martin Buber-Gesellschaft (Deutsch)"
  },
  {
    value: "incontext-studies-in-translation-and-interculturalism",
    label: "INContext: Studies in Translation and Interculturalism"
  },
  {
    value: "indian-dermatology-online-journal",
    label: "Indian Dermatology Online Journal"
  },
  {
    value: "indian-journal-of-medical-research",
    label: "Indian Journal of Medical Research"
  },
  {
    value: "indian-journal-of-orthopaedics",
    label: "Indian Journal of Orthopaedics"
  },
  {
    value: "indian-journal-of-physics",
    label: "Indian Journal of Physics"
  },
  {
    value: "indian-journal-of-traditional-knowledge",
    label: "Indian Journal of Traditional Knowledge"
  },
  {
    value: "indiana",
    label: "INDIANA"
  },
  {
    value: "indoor-air",
    label: "Indoor Air"
  },
  {
    value: "industrial-relations",
    label: "Industrial Relations"
  },
  {
    value: "infectio",
    label: "Infectio (Espa\xF1ol)"
  },
  {
    value: "infectious-disease-clinics-of-north-america",
    label: "Infectious Disease Clinics of North America"
  },
  {
    value: "inflammatory-bowel-diseases",
    label: "Inflammatory Bowel Diseases"
  },
  {
    value: "influenza-and-other-respiratory-viruses",
    label: "Influenza and Other Respiratory Viruses"
  },
  {
    value: "infoclio-de-kurzbelege",
    label: "infoclio.ch (Kurzbelege, Deutsch - Schweiz)"
  },
  {
    value: "infoclio-de",
    label: "infoclio.ch (Deutsch - Schweiz)"
  },
  {
    value: "infoclio-fr-nocaps",
    label: "infoclio.ch (sans majuscules, Fran\xE7ais)"
  },
  {
    value: "infoclio-fr-smallcaps",
    label: "infoclio.ch (petites majuscules, Fran\xE7ais)"
  },
  {
    value: "infomin",
    label: "Infomin"
  },
  {
    value: "informal-logic",
    label: "Informal Logic"
  },
  {
    value: "ingenieria-agricola",
    label: "Ingenier\xEDa Agr\xEDcola (Espa\xF1ol)"
  },
  {
    value: "innovations-therapeutiques-en-oncologie",
    label: "Innovations & Th\xE9rapeutiques en Oncologie"
  },
  {
    value: "instap-academic-press",
    label: "INSTAP Academic Press"
  },
  {
    value: "institut-francais-darcheologie-orientale-arab-studies",
    label: "Institut fran\xE7ais d'arch\xE9ologie orientale - Arab Studies (English)"
  },
  {
    value: "institut-francais-darcheologie-orientale-en",
    label: "Institut fran\xE7ais d'arch\xE9ologie orientale - Egyptology (English)"
  },
  {
    value: "institut-francais-darcheologie-orientale-etudes-arabes",
    label: "Institut fran\xE7ais d'arch\xE9ologie orientale - \xE9tudes arabes (Fran\xE7ais)"
  },
  {
    value: "institut-francais-darcheologie-orientale",
    label: "Institut fran\xE7ais d'arch\xE9ologie orientale - arch\xE9ologie et \xE9gyptologie (Fran\xE7ais)"
  },
  {
    value: "institut-national-de-la-recherche-scientifique-sciences-sociales",
    label: "Institut national de la recherche scientifique - Sciences sociales (author-date, Fran\xE7ais)"
  },
  {
    value: "institut-national-de-recherches-archeologiques-preventives",
    label: "Institut national de recherches arch\xE9ologiques pr\xE9ventives (Fran\xE7ais)"
  },
  {
    value: "institut-national-de-sante-publique-du-quebec-napp",
    label: "Institut national de sant\xE9 publique du Qu\xE9bec - NAPP (Fran\xE7ais - Canada)"
  },
  {
    value: "institut-national-de-sante-publique-du-quebec-topo",
    label: "Institut national de sant\xE9 publique du Qu\xE9bec - TOPO (Fran\xE7ais - Canada)"
  },
  {
    value: "institut-pertanian-bogor",
    label: "Institut Pertanian Bogor: Pedoman Penulisan Karya Ilmiah Edisi ke-3 (Bahasa Indonesia)"
  },
  {
    value: "institut-teknologi-bandung-sekolah-pascasarjana",
    label: "Institut Teknologi Bandung - Sekolah Pascasarjana"
  },
  {
    value: "institute-for-operations-research-and-the-management-sciences",
    label: "Institute for Operations Research and the Management Sciences"
  },
  {
    value: "institute-of-mathematical-statistics",
    label: "Institute of Mathematical Statistics journals"
  },
  {
    value: "institute-of-mathematics-and-its-applications",
    label: "Institute of Mathematics and its Applications"
  },
  {
    value: "institute-of-physics-harvard",
    label: "Institute of Physics - Harvard"
  },
  {
    value: "institute-of-physics-numeric",
    label: "Institute of Physics (numeric)"
  },
  {
    value: "instituto-brasileiro-de-informacao-em-ciencia-e-tecnologia-abnt-initials",
    label: "Instituto Brasileiro de Informa\xE7\xE3o em Ci\xEAncia e Tecnologia - ABNT (autoria abreviada)"
  },
  {
    value: "instituto-brasileiro-de-informacao-em-ciencia-e-tecnologia-abnt",
    label: "Instituto Brasileiro de Informa\xE7\xE3o em Ci\xEAncia e Tecnologia - ABNT (autoria completa)"
  },
  {
    value: "instituto-de-investigaciones-sobre-la-universidad-y-la-educacion-moderno",
    label: "Instituto de Investigaciones sobre la Universidad y la Educaci\xF3n - Moderno (autor-fecha, Espa\xF1ol)"
  },
  {
    value: "instituto-de-pesquisas-energeticas-e-nucleares",
    label: "Instituto de Pesquisas Energ\xE9ticas e Nucleares (Portugu\xEAs - Brasil)"
  },
  {
    value: "instituto-de-pesquisas-tecnologicas",
    label: "Instituto de Pesquisas Tecnol\xF3gicas (Portugu\xEAs - Brasil)"
  },
  {
    value: "instituto-superior-de-teologia-de-las-islas-canarias",
    label: "Instituto Superior de Teolog\xEDa de las Islas Canarias (Espa\xF1ol)"
  },
  {
    value: "integrated-science-publishing-journals",
    label: "Integrated Science Publishing journals"
  },
  {
    value: "integrative-and-comparative-biology",
    label: "Integrative & Comparative Biology"
  },
  {
    value: "inter-research-science-center",
    label: "Inter-Research Science Center"
  },
  {
    value: "inter-ro",
    label: "INTER: Romanian Review for Theological and Religious Studies"
  },
  {
    value: "interaction-design-and-architectures",
    label: "Interaction Design & Architecture(s)"
  },
  {
    value: "interactive-cardiovascular-and-thoracic-surgery",
    label: "Interactive CardioVascular and Thoracic Surgery"
  },
  {
    value: "interdisziplinare-anthropologie",
    label: "Interdisziplin\xE4re Anthropologie (Deutsch)"
  },
  {
    value: "interdisziplinare-zeitschrift-fur-technologie-und-lernen",
    label: "Interdisziplin\xE4re Zeitschrift f\xFCr Technologie und Lernen (Deutsch)"
  },
  {
    value: "interkulturelle-germanistik-gottingen",
    label: "Interkulturelle Germanistik G\xF6ttingen (Deutsch)"
  },
  {
    value: "international-atomic-energy-agency",
    label: "International Atomic Energy Agency"
  },
  {
    value: "international-biodeterioration-and-biodegradation",
    label: "International Biodeterioration & Biodegradation"
  },
  {
    value: "international-brazilian-journal-of-urology",
    label: "International Brazilian Journal Of Urology"
  },
  {
    value: "international-conference-on-information-systems-development",
    label: "International Conference on Information Systems Development"
  },
  {
    value: "international-development-policy",
    label: "International Development Policy"
  },
  {
    value: "international-energy-agency-organisation-for-economic-co-operation-and-development",
    label: "International Energy Agency - Organisation for Economic Co-operation and Development"
  },
  {
    value: "international-islamic-university-malaysia-ahmad-ibrahim-kulliyyah-of-laws",
    label: "International Islamic University Malaysia - Ahmad Ibrahim Kulliyyah of Laws"
  },
  {
    value: "international-journal-for-numerical-methods-in-biomedical-engineering",
    label: "International Journal for Numerical Methods in Biomedical Engineering"
  },
  {
    value: "international-journal-of-audiology",
    label: "International Journal of Audiology"
  },
  {
    value: "international-journal-of-automotive-technology",
    label: "International Journal of Automotive Technology"
  },
  {
    value: "international-journal-of-cancer",
    label: "International Journal of Cancer"
  },
  {
    value: "international-journal-of-circuit-theory-and-applications",
    label: "International Journal of Circuit Theory and Applications"
  },
  {
    value: "international-journal-of-climatology",
    label: "International Journal of Climatology"
  },
  {
    value: "international-journal-of-clinical-research",
    label: "International Journal of Clinical Research"
  },
  {
    value: "international-journal-of-cosmetic-science",
    label: "International Journal of Cosmetic Science"
  },
  {
    value: "international-journal-of-electrochemical-science",
    label: "International Journal of Electrochemical Science"
  },
  {
    value: "international-journal-of-electronic-commerce",
    label: "International Journal of Electronic Commerce"
  },
  {
    value: "international-journal-of-epidemiology",
    label: "International Journal of Epidemiology"
  },
  {
    value: "international-journal-of-exercise-science",
    label: "International Journal of Exercise Science"
  },
  {
    value: "international-journal-of-food-science-and-technology",
    label: "International Journal of Food Science & Technology"
  },
  {
    value: "international-journal-of-geriatric-psychiatry",
    label: "International Journal of Geriatric Psychiatry"
  },
  {
    value: "international-journal-of-humanoid-robotics",
    label: "International Journal of Humanoid Robotics"
  },
  {
    value: "international-journal-of-language-and-communication-disorders",
    label: "International Journal of Language & Communication Disorders"
  },
  {
    value: "international-journal-of-learner-corpus-research",
    label: "International Journal of Learner Corpus Research"
  },
  {
    value: "international-journal-of-lexicography",
    label: "International Journal of Lexicography"
  },
  {
    value: "international-journal-of-management-reviews",
    label: "International Journal of Management Reviews"
  },
  {
    value: "international-journal-of-nuclear-security",
    label: "International Journal of Nuclear Security"
  },
  {
    value: "international-journal-of-obstetric-anesthesia",
    label: "International Journal of Obstetric Anesthesia"
  },
  {
    value: "international-journal-of-occupational-medicine-and-environmental-health",
    label: "International Journal of Occupational Medicine and Environmental Health"
  },
  {
    value: "international-journal-of-oral-and-maxillofacial-surgery",
    label: "International Journal of Oral and Maxillofacial Surgery"
  },
  {
    value: "international-journal-of-osteoarchaeology",
    label: "International Journal of Osteoarchaeology"
  },
  {
    value: "international-journal-of-plant-sciences",
    label: "International Journal of Plant Sciences"
  },
  {
    value: "international-journal-of-polymer-analysis-and-characterization",
    label: "International Journal of Polymer Analysis and Characterization"
  },
  {
    value: "international-journal-of-polymeric-materials-and-polymeric-biomaterials",
    label: "International Journal of Polymeric Materials and Polymeric Biomaterials"
  },
  {
    value: "international-journal-of-population-data-science",
    label: "International Journal of Population Data Science"
  },
  {
    value: "international-journal-of-quantum-chemistry",
    label: "International Journal of Quantum Chemistry"
  },
  {
    value: "international-journal-of-radiation-oncology-biology-physics",
    label: "International Journal of Radiation Oncology, Biology, Physics"
  },
  {
    value: "international-journal-of-research-in-exercise-physiology",
    label: "International Journal of Research in Exercise Physiology"
  },
  {
    value: "international-journal-of-simulation-modelling",
    label: "International Journal of Simulation Modelling"
  },
  {
    value: "international-journal-of-spatial-data-infrastructures-research",
    label: "International Journal of Spatial Data Infrastructures Research"
  },
  {
    value: "international-journal-of-sports-medicine",
    label: "International Journal of Sport Medicine"
  },
  {
    value: "international-journal-of-urban-and-regional-research",
    label: "International Journal of Urban and Regional Research"
  },
  {
    value: "international-journal-of-wildland-fire",
    label: "International Journal of Wildland Fire"
  },
  {
    value: "international-microbiology",
    label: "International Microbiology"
  },
  {
    value: "international-organization",
    label: "International Organization"
  },
  {
    value: "international-pig-veterinary-society-congress-proceedings",
    label: "International Pig Veterinary Society Congress Proceedings"
  },
  {
    value: "international-review-of-the-red-cross",
    label: "International Review of the Red Cross"
  },
  {
    value: "international-security",
    label: "International Security"
  },
  {
    value: "international-studies-association",
    label: "International Studies Association"
  },
  {
    value: "international-union-of-crystallography",
    label: "International Union of Crystallography journals"
  },
  {
    value: "international-union-of-forest-research-organizations-headquarters",
    label: "International Union of Forest Research Organizations - Headquarters"
  },
  {
    value: "inventaire-general-du-patrimoine-culturel-iso-690-full-note-with-ibid",
    label: "Inventaire g\xE9n\xE9ral du patrimoine culturel - ISO-690 (full note, with Ibid., Fran\xE7ais)"
  },
  {
    value: "inventaire-general-du-patrimoine-culturel-iso-690-full-note",
    label: "Inventaire g\xE9n\xE9ral du patrimoine culturel - ISO-690 (full note, Fran\xE7ais)"
  },
  {
    value: "inventaire-general-du-patrimoine-culturel-iso-690-note",
    label: "Inventaire g\xE9n\xE9ral du patrimoine culturel - ISO-690 (note, Fran\xE7ais)"
  },
  {
    value: "invertebrate-biology",
    label: "Invertebrate Biology"
  },
  {
    value: "investigative-radiology",
    label: "Investigative Radiology"
  },
  {
    value: "invisu",
    label: "InVisu"
  },
  {
    value: "ios-press-books",
    label: "IOS Press (books)"
  },
  {
    value: "ipag-business-school-apa",
    label: "IPAG Business School - APA"
  },
  {
    value: "iran-manual-of-style",
    label: "Iran Manual of Style - \u0634\u06CC\u0648\u0647\u200C\u0646\u0627\u0645\u0647 \u0627\u06CC\u0631\u0627\u0646 (\u0641\u0627\u0631\u0633\u06CC)"
  },
  {
    value: "iranian-journal-of-basic-medical-sciences",
    label: "Iranian Journal of Basic Medical Sciences"
  },
  {
    value: "iranian-journal-of-pharmaceutical-research",
    label: "Iranian Journal of Pharmaceutical Research"
  },
  {
    value: "irish-historical-studies",
    label: "Irish Historical Studies"
  },
  {
    value: "isabella-stewart-gardner-museum",
    label: "Isabella Stewart Gardner Museum"
  },
  {
    value: "isnad-dipnotlu",
    label: "\u0130SNAD At\u0131f Sistemi 2. Edisyon (dipnotlu)"
  },
  {
    value: "isnad-metinici",
    label: "\u0130SNAD At\u0131f Sistemi 2. Edisyon (metini\xE7i)"
  },
  {
    value: "isnad",
    label: "\u0130SNAD At\u0131f Sistemi 1. Edisyon (dipnotlu)"
  },
  {
    value: "iso690-author-date-cs",
    label: "ISO-690 (author-date, \u010Ce\u0161tina)"
  },
  {
    value: "iso690-author-date-de",
    label: "ISO-690 (author-date, Deutsch)"
  },
  {
    value: "iso690-author-date-en",
    label: "ISO-690 (author-date, English)"
  },
  {
    value: "iso690-author-date-es",
    label: "ISO-690 (author-date, Espa\xF1ol)"
  },
  {
    value: "iso690-author-date-fr-no-abstract",
    label: "ISO-690 (author-date, no abstract, Fran\xE7ais)"
  },
  {
    value: "iso690-author-date-fr",
    label: "ISO-690 (author-date, Fran\xE7ais)"
  },
  {
    value: "iso690-author-date-pt-br",
    label: "ISO-690 (author-date, Portugu\xEAs - Brasil)"
  },
  {
    value: "iso690-author-date-sk",
    label: "ISO-690 (author-date, Sloven\u010Dina)"
  },
  {
    value: "iso690-full-note-cs",
    label: "ISO-690 (full note, \u010Ce\u0161tina)"
  },
  {
    value: "iso690-full-note-sk",
    label: "ISO-690 (full note, Sloven\u010Dina)"
  },
  {
    value: "iso690-full-note-with-ibid-ro",
    label: "ISO-690 (full note, with Ibid., Rom\xE2n\u0103)"
  },
  {
    value: "iso690-note-cs",
    label: "ISO-690 (note, without bibliography, \u010Ce\u0161tina)"
  },
  {
    value: "iso690-note-fr",
    label: "ISO-690 (note, no abstract, Fran\xE7ais)"
  },
  {
    value: "iso690-numeric-brackets-cs",
    label: "ISO-690 (numeric, brackets, \u010Ce\u0161tina)"
  },
  {
    value: "iso690-numeric-cs",
    label: "ISO-690 (numeric, parentheses, \u010Ce\u0161tina)"
  },
  {
    value: "iso690-numeric-en",
    label: "ISO-690 (numeric, English)"
  },
  {
    value: "iso690-numeric-fr",
    label: "ISO-690 (numeric, Fran\xE7ais)"
  },
  {
    value: "iso690-numeric-lt",
    label: "ISO-690 (numeric, Lietuvi\u0173 kalba)"
  },
  {
    value: "iso690-numeric-sk",
    label: "ISO-690 (numeric, Sloven\u010Dina)"
  },
  {
    value: "israel-medical-association-journal",
    label: "Israel Medical Association Journal"
  },
  {
    value: "istanbul-medical-journal",
    label: "\u0130stanbul Medical Journal"
  },
  {
    value: "istanbul-universitesi-sosyal-bilimler-enstitusu",
    label: "\u0130stanbul \xDCniversitesi Sosyal Bilimler Enstit\xFCs\xFC (T\xFCrk\xE7e)"
  },
  {
    value: "italian-journal-of-agronomy",
    label: "Italian Journal of Agronomy"
  },
  {
    value: "italus-hortus",
    label: "Italus Hortus"
  },
  {
    value: "ithaque",
    label: "Ithaque (Fran\xE7ais - Canada)"
  },
  {
    value: "iubmb-life",
    label: "IUBMB Life"
  },
  {
    value: "ius-ecclesiae",
    label: "Ius Ecclesiae"
  },
  {
    value: "izmir-katip-celebi-universitesi-sosyal-bilimler-enstitusu",
    label: "\u0130zmir Katip \xC7elebi \xDCniversitesi - Sosyal Bilimler Enstit\xFCs\xFC (T\xFCrk\xE7e)"
  },
  {
    value: "jacc-cardiovascular-imaging",
    label: "JACC: Cardiovascular Imaging"
  },
  {
    value: "jacc-cardiovascular-interventions",
    label: "JACC: Cardiovascular Interventions"
  },
  {
    value: "jahrbuch-der-osterreichischen-byzantinischen-gesellschaft",
    label: "Jahrbuch der \xD6sterreichischen Byzantinischen Gesellschaft"
  },
  {
    value: "jahrbuch-fur-evangelikale-theologie",
    label: "Jahrbuch f\xFCr evangelikale Theologie (Deutsch)"
  },
  {
    value: "japanese-journal-of-applied-physics",
    label: "Japanese Journal of Applied Physics"
  },
  {
    value: "javnost-the-public",
    label: "Javnost - The Public"
  },
  {
    value: "jci-insight",
    label: "JCI Insight"
  },
  {
    value: "jcom-journal-of-science-communication",
    label: "JCOM: Journal of Science Communication"
  },
  {
    value: "john-benjamins-publishing-company-iconicity-in-language-and-literature",
    label: "John Benjamins Publishing Company - Iconicity in Language and Literature"
  },
  {
    value: "john-benjamins-publishing-company-linguistik-aktuell-linguistics-today",
    label: "John Benjamins Publishing Company - Linguistik Aktuell/Linguistics Today"
  },
  {
    value: "johnson-matthey-technology-review",
    label: "Johnson Matthey Technology Review"
  },
  {
    value: "journal-and-proceedings-of-the-royal-society-of-new-south-wales",
    label: "Journal and Proceedings of the Royal Society of New South Wales"
  },
  {
    value: "journal-de-la-societe-des-americanistes",
    label: "Journal de la Soci\xE9t\xE9 des am\xE9ricanistes"
  },
  {
    value: "journal-de-la-societe-des-oceanistes",
    label: "Journal de la Soci\xE9t\xE9 des Oc\xE9anistes"
  },
  {
    value: "journal-for-the-history-of-astronomy",
    label: "Journal for the History of Astronomy"
  },
  {
    value: "journal-for-the-study-of-the-new-testament",
    label: "Journal for the Study of the New Testament"
  },
  {
    value: "journal-for-veterinary-medicine-biotechnology-and-biosafety",
    label: "Journal for Veterinary Medicine, Biotechnology and Biosafety"
  },
  {
    value: "journal-fur-kulturpflanzen-journal-of-cultivated-plants",
    label: "Journal f\xFCr Kulturpflanzen - Journal of Cultivated Plants"
  },
  {
    value: "journal-fur-kunstgeschichte",
    label: "Journal f\xFCr Kunstgeschichte"
  },
  {
    value: "journal-of-accounting-research",
    label: "Journal of Accounting Research"
  },
  {
    value: "journal-of-acoustics",
    label: "Journal of Acoustics"
  },
  {
    value: "journal-of-adolescent-health",
    label: "Journal of Adolescent Health"
  },
  {
    value: "journal-of-advertising-research",
    label: "Journal of Advertising Research"
  },
  {
    value: "journal-of-agricultural-and-applied-economics",
    label: "Journal of Agricultural and Applied Economics"
  },
  {
    value: "journal-of-agricultural-and-resource-economics",
    label: "Journal of Agricultural and Resource Economics"
  },
  {
    value: "journal-of-alzheimers-disease",
    label: "Journal of Alzheimer's Disease"
  },
  {
    value: "journal-of-analytical-toxicology",
    label: "Journal of Analytical Toxicology"
  },
  {
    value: "journal-of-animal-physiology-and-animal-nutrition",
    label: "Journal of Animal Physiology and Animal Nutrition"
  },
  {
    value: "journal-of-animal-science",
    label: "Journal of Animal Science"
  },
  {
    value: "journal-of-antimicrobial-chemotherapy",
    label: "Journal of Antimicrobial Chemotherapy"
  },
  {
    value: "journal-of-aoac-international",
    label: "Journal of AOAC International"
  },
  {
    value: "journal-of-applied-animal-science",
    label: "Journal of Applied Animal Science"
  },
  {
    value: "journal-of-applied-clinical-medical-physics",
    label: "Journal of Applied Clinical Medical Physics"
  },
  {
    value: "journal-of-applied-entomology",
    label: "Journal of Applied Entomology"
  },
  {
    value: "journal-of-applied-pharmaceutical-research",
    label: "Journal of Applied Pharmaceutical Research"
  },
  {
    value: "journal-of-applied-philosophy",
    label: "Journal of Applied Philosophy"
  },
  {
    value: "journal-of-applied-polymer-science",
    label: "Journal of Applied Polymer Science"
  },
  {
    value: "journal-of-archaeological-research",
    label: "Journal of Archaeological Research"
  },
  {
    value: "journal-of-atrial-fibrillation",
    label: "Journal of Atrial Fibrillation"
  },
  {
    value: "journal-of-australian-strength-and-conditioning",
    label: "Journal of Australian Strength & Conditioning"
  },
  {
    value: "journal-of-avian-biology",
    label: "Journal of Avian Biology"
  },
  {
    value: "journal-of-basic-microbiology",
    label: "Journal of Basic Microbiology"
  },
  {
    value: "journal-of-biological-chemistry",
    label: "The Journal of Biological Chemistry"
  },
  {
    value: "journal-of-biological-regulators-and-homeostatic-agents",
    label: "Journal of Biological Regulators & Homeostatic Agents"
  },
  {
    value: "journal-of-biomedical-materials-research-part-a",
    label: "Journal of Biomedical Materials Research Part A"
  },
  {
    value: "journal-of-biosciences",
    label: "Journal of Biosciences"
  },
  {
    value: "journal-of-bone-and-mineral-research",
    label: "Journal of Bone and Mineral Research"
  },
  {
    value: "journal-of-brachial-plexus-and-peripheral-nerve-injury",
    label: "Journal of Brachial Plexus and Peripheral Nerve Injury"
  },
  {
    value: "journal-of-breast-cancer",
    label: "Journal of Breast Cancer"
  },
  {
    value: "journal-of-burn-care-and-research",
    label: "Journal of Burn Care & Research"
  },
  {
    value: "journal-of-business-logistics",
    label: "Journal of Business Logistics"
  },
  {
    value: "journal-of-cachexia-sarcopenia-and-muscle",
    label: "Journal of Cachexia, Sarcopenia and Muscle"
  },
  {
    value: "journal-of-cardiothoracic-and-vascular-anesthesia",
    label: "Journal of Cardiothoracic and Vascular Anesthesia"
  },
  {
    value: "journal-of-cellular-and-molecular-medicine",
    label: "Journal of Cellular and Molecular Medicine"
  },
  {
    value: "journal-of-cellular-biochemistry",
    label: "Journal of Cellular Biochemistry"
  },
  {
    value: "journal-of-chemistry-and-chemical-engineering",
    label: "Journal of Chemistry and Chemical Engineering"
  },
  {
    value: "journal-of-chemometrics",
    label: "Journal of Chemometrics"
  },
  {
    value: "journal-of-clinical-and-translational-science",
    label: "Journal of Clinical and Translational Science"
  },
  {
    value: "journal-of-clinical-neurology",
    label: "Journal of Clinical Neurology"
  },
  {
    value: "journal-of-clinical-neurophysiology",
    label: "Journal of Clinical Neurophysiology"
  },
  {
    value: "journal-of-clinical-oncology",
    label: "Journal of Clinical Oncology"
  },
  {
    value: "journal-of-clinical-rheumatology",
    label: "Journal of Clinical Rheumatology"
  },
  {
    value: "journal-of-clinical-sleep-medicine",
    label: "Journal of Clinical Sleep Medicine"
  },
  {
    value: "journal-of-combinatorics",
    label: "Journal of Combinatorics"
  },
  {
    value: "journal-of-common-market-studies",
    label: "Journal of Common Market Studies"
  },
  {
    value: "journal-of-comparative-pathology",
    label: "Journal of Comparative Pathology"
  },
  {
    value: "journal-of-computational-chemistry",
    label: "Journal of Computational Chemistry"
  },
  {
    value: "journal-of-computer-applications-in-archaeology",
    label: "Journal of Computer Applications in Archaeology"
  },
  {
    value: "journal-of-computer-assisted-tomography",
    label: "Journal of Computer Assisted Tomography"
  },
  {
    value: "journal-of-computer-information-systems",
    label: "Journal of Computer Information Systems"
  },
  {
    value: "journal-of-consumer-research",
    label: "Journal of Consumer Research"
  },
  {
    value: "journal-of-contemporary-medicine",
    label: "Journal of Contemporary Medicine"
  },
  {
    value: "journal-of-contemporary-water-research-and-education",
    label: "Journal of Contemporary Water Research and Education"
  },
  {
    value: "journal-of-crohns-and-colitis-supplements",
    label: "Journal of Crohn's and Colitis Supplements"
  },
  {
    value: "journal-of-crohns-and-colitis",
    label: "Journal of Crohn's and Colitis"
  },
  {
    value: "journal-of-dairy-science",
    label: "Journal of Dairy Science"
  },
  {
    value: "journal-of-dental-research",
    label: "Journal of Dental Research"
  },
  {
    value: "journal-of-early-christian-studies",
    label: "Journal of Early Christian Studies"
  },
  {
    value: "journal-of-economic-impact",
    label: "Journal of Economic Impact"
  },
  {
    value: "journal-of-egyptian-history",
    label: "Journal of Egyptian History"
  },
  {
    value: "journal-of-elections-public-opinion-and-parties",
    label: "Journal of Elections, Public Opinion & Parties"
  },
  {
    value: "journal-of-endodontics",
    label: "Journal of Endodontics"
  },
  {
    value: "journal-of-environmental-science-and-health-part-b",
    label: "Journal of Environmental Science and Health, Part B"
  },
  {
    value: "journal-of-ethnobiology",
    label: "Journal of Ethnobiology"
  },
  {
    value: "journal-of-european-public-policy",
    label: "Journal of European Public Policy"
  },
  {
    value: "journal-of-evolution-and-health",
    label: "Journal of Evolution and Health"
  },
  {
    value: "journal-of-evolutionary-biology",
    label: "Journal of Evolutionary Biology"
  },
  {
    value: "journal-of-experimental-botany",
    label: "Journal of Experimental Botany"
  },
  {
    value: "journal-of-field-ornithology",
    label: "Journal of Field Ornithology"
  },
  {
    value: "journal-of-finance",
    label: "Journal of Finance"
  },
  {
    value: "journal-of-financial-and-quantitative-analysis",
    label: "Journal of Financial and Quantitative Analysis"
  },
  {
    value: "journal-of-fish-biology",
    label: "Journal of Fish Biology"
  },
  {
    value: "journal-of-food-protection",
    label: "Journal of Food Protection"
  },
  {
    value: "journal-of-foraminiferal-research",
    label: "Journal of Foraminiferal Research"
  },
  {
    value: "journal-of-forensic-sciences",
    label: "Journal of Forensic Sciences"
  },
  {
    value: "journal-of-frailty-and-aging",
    label: "Journal of Frailty & Aging"
  },
  {
    value: "journal-of-geriatric-psychiatry-and-neurology",
    label: "Journal of Geriatric Psychiatry and Neurology"
  },
  {
    value: "journal-of-glaciology",
    label: "Journal of Glaciology"
  },
  {
    value: "journal-of-global-health",
    label: "Journal of Global Health"
  },
  {
    value: "journal-of-health-care-for-the-poor-and-underserved",
    label: "Journal of Health Care for the Poor and Underserved"
  },
  {
    value: "journal-of-hearing-science",
    label: "Journal of Hearing Science"
  },
  {
    value: "journal-of-historical-linguistics",
    label: "Journal of Historical Linguistics"
  },
  {
    value: "journal-of-human-evolution",
    label: "Journal of Human Evolution"
  },
  {
    value: "journal-of-human-rights",
    label: "Journal of Human Rights"
  },
  {
    value: "journal-of-hypertension",
    label: "Journal of Hypertension"
  },
  {
    value: "journal-of-industrial-and-engineering-chemistry",
    label: "Journal of Industrial and Engineering Chemistry"
  },
  {
    value: "journal-of-industrial-ecology",
    label: "Journal of Industrial Ecology"
  },
  {
    value: "journal-of-infection",
    label: "Journal of Infection"
  },
  {
    value: "journal-of-infectious-diseases",
    label: "Journal of Infectious Diseases"
  },
  {
    value: "journal-of-information-technology",
    label: "Journal of Information Technology"
  },
  {
    value: "journal-of-institutional-and-theoretical-economics",
    label: "Journal of Institutional and Theoretical Economics"
  },
  {
    value: "journal-of-instrumentation",
    label: "Journal of Instrumentation"
  },
  {
    value: "journal-of-integrated-omics",
    label: "Journal of Integrated OMICS"
  },
  {
    value: "journal-of-interactive-marketing",
    label: "Journal of Interactive Marketing"
  },
  {
    value: "journal-of-intercultural-studies",
    label: "Journal of Intercultural Studies"
  },
  {
    value: "journal-of-internal-medicine",
    label: "Journal of Internal Medicine"
  },
  {
    value: "journal-of-international-business-studies",
    label: "Journal of International Business Studies"
  },
  {
    value: "journal-of-international-economic-law",
    label: "Journal of International Economic Law"
  },
  {
    value: "journal-of-international-peacekeeping",
    label: "Journal of International Peacekeeping"
  },
  {
    value: "journal-of-international-relations-and-development",
    label: "Journal of International Relations and Development"
  },
  {
    value: "journal-of-investigative-dermatology",
    label: "Journal of Investigative Dermatology"
  },
  {
    value: "journal-of-jewish-studies",
    label: "Journal of Jewish Studies"
  },
  {
    value: "journal-of-korean-neurosurgical-society",
    label: "Journal of Korean Neurosurgical Society"
  },
  {
    value: "journal-of-leukocyte-biology",
    label: "Journal of Leukocyte Biology"
  },
  {
    value: "journal-of-limnology",
    label: "Journal of Limnology"
  },
  {
    value: "journal-of-linguistics",
    label: "Journal of Linguistics"
  },
  {
    value: "journal-of-lipid-research",
    label: "Journal of Lipid Research"
  },
  {
    value: "journal-of-magnetic-resonance-imaging",
    label: "Journal Of Magnetic Resonance Imaging"
  },
  {
    value: "journal-of-mammalogy",
    label: "Journal of Mammalogy"
  },
  {
    value: "journal-of-management-information-systems",
    label: "Journal of Management Information Systems"
  },
  {
    value: "journal-of-management-studies",
    label: "Journal of Management Studies"
  },
  {
    value: "journal-of-management",
    label: "Journal of Management"
  },
  {
    value: "journal-of-materials-research",
    label: "Journal of Materials Research"
  },
  {
    value: "journal-of-mechanical-science-and-technology",
    label: "Journal of Mechanical Science and Technology"
  },
  {
    value: "journal-of-medical-genetics",
    label: "Journal of Medical Genetics"
  },
  {
    value: "journal-of-medical-internet-research",
    label: "Journal of Medical Internet Research"
  },
  {
    value: "journal-of-microbiology-and-biotechnology",
    label: "Journal of Microbiology and Biotechnology"
  },
  {
    value: "journal-of-microbiology",
    label: "Journal of Microbiology"
  },
  {
    value: "journal-of-minimally-invasive-gynecology",
    label: "Journal of Minimally Invasive Gynecology"
  },
  {
    value: "journal-of-molecular-cell-biology",
    label: "Journal of Molecular Cell Biology"
  },
  {
    value: "journal-of-molecular-endocrinology",
    label: "Journal of Molecular Endocrinology"
  },
  {
    value: "journal-of-molecular-recognition",
    label: "Journal of Molecular Recognition"
  },
  {
    value: "journal-of-molecular-signaling",
    label: "Journal of Molecular Signaling"
  },
  {
    value: "journal-of-move-and-therapeutic-science",
    label: "Journal of Move and Therapeutic Science"
  },
  {
    value: "journal-of-musculoskeletal-research",
    label: "Journal of Musculoskeletal Research"
  },
  {
    value: "journal-of-music-technology-and-education",
    label: "Journal of Music Technology and Education"
  },
  {
    value: "journal-of-nanoscience-and-nanotechnology",
    label: "Journal of Nanoscience and Nanotechnology"
  },
  {
    value: "journal-of-natural-history",
    label: "Journal of Natural History"
  },
  {
    value: "journal-of-neolithic-archaeology",
    label: "Journal of Neolithic Archaeology"
  },
  {
    value: "journal-of-neurochemistry",
    label: "Journal of Neurochemistry"
  },
  {
    value: "journal-of-neuroendocrinology",
    label: "Journal of Neuroendocrinology"
  },
  {
    value: "journal-of-neurological-disorders",
    label: "Journal of Neurological Disorders"
  },
  {
    value: "journal-of-neurophysiology",
    label: "Journal of Neurophysiology"
  },
  {
    value: "journal-of-neuroscience-and-neuroengineering",
    label: "Journal of Neuroscience and Neuroengineering"
  },
  {
    value: "journal-of-new-zealand-grasslands",
    label: "Journal of New Zealand Grasslands"
  },
  {
    value: "journal-of-nutrition",
    label: "Journal of Nutrition"
  },
  {
    value: "journal-of-oil-palm-research",
    label: "Journal of Oil Palm Research"
  },
  {
    value: "journal-of-open-research-software",
    label: "Journal of Open Research Software"
  },
  {
    value: "journal-of-oral-and-maxillofacial-surgery",
    label: "Journal of Oral and Maxillofacial Surgery"
  },
  {
    value: "journal-of-orthopaedic-research",
    label: "Journal of Orthopaedic Research"
  },
  {
    value: "journal-of-orthopaedic-trauma",
    label: "Journal of Orthopaedic Trauma"
  },
  {
    value: "journal-of-orthopaedics-trauma-and-rehabilitation",
    label: "Journal of Orthopaedics, Trauma and Rehabilitation"
  },
  {
    value: "journal-of-paleontology",
    label: "Journal of Paleontology"
  },
  {
    value: "journal-of-peace-research",
    label: "Journal of Peace Research"
  },
  {
    value: "journal-of-pediatric-gastroenterology-and-nutrition",
    label: "Journal of Pediatric Gastroenterology and Nutrition"
  },
  {
    value: "journal-of-peptide-science",
    label: "Journal of Peptide Science"
  },
  {
    value: "journal-of-perinatal-medicine",
    label: "Journal of Perinatal Medicine"
  },
  {
    value: "journal-of-periodontal-research",
    label: "Journal of Periodontal Research"
  },
  {
    value: "journal-of-petrology",
    label: "Journal of Petrology"
  },
  {
    value: "journal-of-pharmacy-and-pharmacology",
    label: "Journal of Pharmacy and Pharmacology"
  },
  {
    value: "journal-of-phycology",
    label: "Journal of Phycology"
  },
  {
    value: "journal-of-physical-therapy-science",
    label: "Journal of Physical Therapy Science"
  },
  {
    value: "journal-of-plankton-research",
    label: "Journal of Plankton Research"
  },
  {
    value: "journal-of-plant-ecology",
    label: "Journal of Plant Ecology"
  },
  {
    value: "journal-of-plant-nutrition-and-soil-science",
    label: "Journal of Plant Nutrition and Soil Science"
  },
  {
    value: "journal-of-plant-protection-research",
    label: "Journal of Plant Protection Research"
  },
  {
    value: "journal-of-political-ideologies",
    label: "Journal of Political Ideologies"
  },
  {
    value: "journal-of-political-philosophy",
    label: "Journal of Political Philosophy"
  },
  {
    value: "journal-of-pollination-ecology",
    label: "Journal of Pollination Ecology"
  },
  {
    value: "journal-of-polymer-science-part-a-polymer-chemistry",
    label: "Journal of Polymer Science Part A: Polymer Chemistry"
  },
  {
    value: "journal-of-porphyrins-and-phthalocyanines",
    label: "Journal of Porphyrins and Phthalocyanines"
  },
  {
    value: "journal-of-product-innovation-management",
    label: "Journal of Product Innovation Management"
  },
  {
    value: "journal-of-psychiatric-and-mental-health-nursing",
    label: "Journal of Psychiatric and Mental Health Nursing"
  },
  {
    value: "journal-of-psychiatry-and-neuroscience",
    label: "Journal of Psychiatry & Neuroscience"
  },
  {
    value: "journal-of-raman-spectroscopy",
    label: "Journal of Raman Spectroscopy"
  },
  {
    value: "journal-of-reconstructive-microsurgery",
    label: "Journal of Reconstructive Microsurgery"
  },
  {
    value: "journal-of-refugee-studies",
    label: "Journal of Refugee Studies"
  },
  {
    value: "journal-of-retailing",
    label: "Journal of Retailing"
  },
  {
    value: "journal-of-rheumatology",
    label: "Journal of Rheumatology"
  },
  {
    value: "journal-of-roman-archaeology-a",
    label: "Journal of Roman Archaeology (A)"
  },
  {
    value: "journal-of-roman-archaeology-b",
    label: "Journal of Roman Archaeology (B)"
  },
  {
    value: "journal-of-science-and-medicine-in-sport",
    label: "Journal of Science and Medicine in Sport"
  },
  {
    value: "journal-of-separation-science",
    label: "Journal of Separation Science"
  },
  {
    value: "journal-of-shoulder-and-elbow-surgery",
    label: "Journal of Shoulder and Elbow Surgery"
  },
  {
    value: "journal-of-simulation",
    label: "Journal of Simulation"
  },
  {
    value: "journal-of-sleep-research",
    label: "Journal of Sleep Research"
  },
  {
    value: "journal-of-small-animal-practice",
    label: "Journal of Small Animal Practice"
  },
  {
    value: "journal-of-small-business-management",
    label: "Journal of Small Business Management"
  },
  {
    value: "journal-of-social-archaeology",
    label: "Journal of Social Archaeology"
  },
  {
    value: "journal-of-social-philosophy",
    label: "Journal of Social Philosophy"
  },
  {
    value: "journal-of-soil-and-water-conservation",
    label: "Journal of Soil and Water Conservation"
  },
  {
    value: "journal-of-soil-science-and-plant-nutrition",
    label: "Journal of Soil Science and Plant Nutrition"
  },
  {
    value: "journal-of-sport-and-health-science",
    label: "Journal of Sport and Health Science"
  },
  {
    value: "journal-of-sports-science-and-medicine",
    label: "Journal of Sports Science & Medicine"
  },
  {
    value: "journal-of-strength-and-conditioning-research",
    label: "Journal of Strength and Conditioning Research"
  },
  {
    value: "journal-of-stroke",
    label: "Journal of Stroke"
  },
  {
    value: "journal-of-structural-geology",
    label: "Journal of Structural Geology"
  },
  {
    value: "journal-of-studies-on-alcohol-and-drugs",
    label: "Journal of Studies on Alcohol and Drugs"
  },
  {
    value: "journal-of-surgery-and-medicine",
    label: "Journal of Surgery and Medicine"
  },
  {
    value: "journal-of-surgical-oncology",
    label: "Journal of Surgical Oncology"
  },
  {
    value: "journal-of-systematic-palaeontology",
    label: "Journal of Systematic Palaeontology"
  },
  {
    value: "journal-of-the-air-and-waste-management-association",
    label: "Journal of the Air & Waste Management Association"
  },
  {
    value: "journal-of-the-american-academy-of-audiology",
    label: "Journal of the American Academy of Audiology"
  },
  {
    value: "journal-of-the-american-academy-of-orthopaedic-surgeons",
    label: "Journal of the American Academy of Orthopaedic Surgeons"
  },
  {
    value: "journal-of-the-american-animal-hospital-association",
    label: "Journal of the American Animal Hospital Association"
  },
  {
    value: "journal-of-the-american-association-of-laboratory-animal-science",
    label: "Journal of the American Association of Laboratory Animal Science"
  },
  {
    value: "journal-of-the-american-ceramic-society",
    label: "Journal of the American Ceramic Society"
  },
  {
    value: "journal-of-the-american-college-of-cardiology",
    label: "Journal of the American College of Cardiology"
  },
  {
    value: "journal-of-the-american-college-of-surgeons",
    label: "Journal of the American College of Surgeons"
  },
  {
    value: "journal-of-the-american-heart-association",
    label: "Journal of the American Heart Association"
  },
  {
    value: "journal-of-the-american-society-of-brewing-chemists",
    label: "Journal of the American Society of Brewing Chemists"
  },
  {
    value: "journal-of-the-american-society-of-nephrology",
    label: "Journal of the American Society of Nephrology"
  },
  {
    value: "journal-of-the-american-water-resources-association",
    label: "Journal of the American Water Resources Association"
  },
  {
    value: "journal-of-the-association-for-information-systems",
    label: "Journal of the Association for Information Systems"
  },
  {
    value: "journal-of-the-association-of-environmental-and-resource-economists",
    label: "Journal of the Association of Environmental and Resource Economists"
  },
  {
    value: "journal-of-the-botanical-research-institute-of-texas",
    label: "Journal of the Botanical Research Institute of Texas"
  },
  {
    value: "journal-of-the-brazilian-chemical-society",
    label: "Journal of the Brazilian Chemical Society"
  },
  {
    value: "journal-of-the-electrochemical-society",
    label: "Journal of The Electrochemical Society"
  },
  {
    value: "journal-of-the-european-academy-of-dermatology-and-venereology",
    label: "Journal of the European Academy of Dermatology and Venereology"
  },
  {
    value: "journal-of-the-history-of-collections",
    label: "Journal of the History of Collections"
  },
  {
    value: "journal-of-the-indian-law-institute",
    label: "Journal of the Indian Law Institute"
  },
  {
    value: "journal-of-the-korean-society-of-civil-engineers",
    label: "Journal of the Korean Society of Civil Engineers"
  },
  {
    value: "journal-of-the-marine-biological-association-of-the-united-kingdom",
    label: "Journal of the Marine Biological Association of the United Kingdom"
  },
  {
    value: "journal-of-the-royal-anthropological-institute",
    label: "Journal of the Royal Anthropological Institute"
  },
  {
    value: "journal-of-the-royal-society-of-western-australia",
    label: "Journal of the Royal Society of Western Australia"
  },
  {
    value: "journal-of-the-royal-statistical-society",
    label: "Journal of the Royal Statistical Society"
  },
  {
    value: "journal-of-the-science-of-food-and-agriculture",
    label: "Journal of the Science of Food and Agriculture"
  },
  {
    value: "journal-of-the-serbian-chemical-society",
    label: "Journal of the Serbian Chemical Society"
  },
  {
    value: "journal-of-the-warburg-and-courtauld-institutes",
    label: "Journal of the Warburg and Courtauld Institutes"
  },
  {
    value: "journal-of-thermal-spray-technology",
    label: "Journal of Thermal Spray Technology"
  },
  {
    value: "journal-of-threatened-taxa",
    label: "Journal of Threatened Taxa"
  },
  {
    value: "journal-of-thrombosis-and-haemostasis",
    label: "Journal of Thrombosis and Haemostasis"
  },
  {
    value: "journal-of-tropical-ecology",
    label: "Journal of Tropical Ecology"
  },
  {
    value: "journal-of-tropical-life-science",
    label: "Journal of Tropical Life Science"
  },
  {
    value: "journal-of-universal-computer-science",
    label: "Journal of Universal Computer Science"
  },
  {
    value: "journal-of-urban-and-environmental-engineering",
    label: "Journal of Urban and Environmental Engineering"
  },
  {
    value: "journal-of-urban-technology",
    label: "Journal of Urban Technology"
  },
  {
    value: "journal-of-value-inquiry",
    label: "The Journal of Value Inquiry"
  },
  {
    value: "journal-of-vegetation-science",
    label: "Journal of Vegetation Science"
  },
  {
    value: "journal-of-vertebrate-biology",
    label: "Journal of Vertebrate Biology"
  },
  {
    value: "journal-of-vertebrate-paleontology",
    label: "Journal of Vertebrate Paleontology"
  },
  {
    value: "journal-of-vestibular-research",
    label: "Journal of Vestibular Research"
  },
  {
    value: "journal-of-veterinary-diagnostic-investigation",
    label: "Journal of Veterinary Diagnostic Investigation"
  },
  {
    value: "journal-of-visualized-experiments",
    label: "Journal of Visualized Experiments"
  },
  {
    value: "journal-of-water-sanitation-and-hygiene-for-development",
    label: "Journal of Water Sanitation and Hygiene for Development"
  },
  {
    value: "journal-of-wildlife-diseases",
    label: "Journal of Wildlife Diseases"
  },
  {
    value: "journal-of-zoo-and-wildlife-medicine",
    label: "Journal of Zoo and Wildlife Medicine"
  },
  {
    value: "journal-of-zoo-biology",
    label: "Journal of Zoo Biology"
  },
  {
    value: "journal-of-zoology",
    label: "Journal of Zoology"
  },
  {
    value: "journal-on-efficiency-and-responsibility-in-education-and-science",
    label: "Journal on Efficiency and Responsibility in Education and Science"
  },
  {
    value: "journalistica",
    label: "Journalistica (Dansk)"
  },
  {
    value: "jurisprudence",
    label: "Jurisprudence (\u010Ce\u0161tina)"
  },
  {
    value: "juristische-schulung",
    label: "Juristische Schulung (Deutsch)"
  },
  {
    value: "juristische-zitierweise-offentliches-recht",
    label: "Juristische Zitierweise - \xD6ffentliches Recht (Deutsch)"
  },
  {
    value: "juristische-zitierweise-schweizer",
    label: "Juristische Zitierweise Schweizer (Ryser B\xFCschi et al.) (Deutsch - Schweiz)"
  },
  {
    value: "juristische-zitierweise",
    label: "Juristische Zitierweise (St\xFCber) (Deutsch)"
  },
  {
    value: "jurnal-ilmu-dan-teknologi-hasil-ternak",
    label: "Jurnal Ilmu dan Teknologi Hasil Ternak"
  },
  {
    value: "jurnal-pangan-dan-agroindustri",
    label: "Jurnal Pangan dan Agroindustri (Bahasa Indonesia)"
  },
  {
    value: "jurnal-sains-farmasi-dan-klinis",
    label: "Jurnal Sains Farmasi & Klinis"
  },
  {
    value: "jyvaskylan-yliopisto-kemian-laitos",
    label: "Jyv\xE4skyl\xE4n yliopisto - Kemian laitos (Suomi)"
  },
  {
    value: "karabuk-university-graduate-school-of-natural-and-applied-sciences",
    label: "Karabuk University - Graduate School of Natural and Applied Sciences"
  },
  {
    value: "karger-journals-author-date",
    label: "Karger journals (author-date)"
  },
  {
    value: "karger-journals",
    label: "Karger journals"
  },
  {
    value: "karlstad-universitet-harvard",
    label: "Karlstad Universitet - Harvard (Svenska)"
  },
  {
    value: "karstenia",
    label: "Karstenia"
  },
  {
    value: "keel-ja-kirjandus",
    label: "Keel ja Kirjandus (Eesti keel)"
  },
  {
    value: "kidney-research-and-clinical-practice",
    label: "Kidney Research and Clinical Practice"
  },
  {
    value: "kindheit-und-entwicklung",
    label: "Kindheit und Entwicklung"
  },
  {
    value: "kit-karlsruher-institut-fur-technologie-germanistik-ndl-neuere-deutsche-literaturwissenschaft",
    label: "KIT Karlsruher Institut f\xFCr Technologie Germanistik NDL Neuere Deutsche Literaturwissenschaft (German)"
  },
  {
    value: "klinische-padiatrie",
    label: "Klinische P\xE4diatrie"
  },
  {
    value: "knee-surgery-and-related-research",
    label: "Knee Surgery & Related Research"
  },
  {
    value: "knee-surgery-sports-traumatology-arthroscopy",
    label: "Knee Surgery, Sports Traumatology, Arthroscopy"
  },
  {
    value: "knowledge-and-management-of-aquatic-ecosystems",
    label: "Knowledge & Management of Aquatic Ecosystems"
  },
  {
    value: "kolner-zeitschrift-fur-soziologie-und-sozialpsychologie",
    label: "K\xF6lner Zeitschrift f\xFCr Soziologie und Sozialpsychologie (Deutsch)"
  },
  {
    value: "kommunikation-und-recht",
    label: "Kommunikation und Recht (Deutsch)"
  },
  {
    value: "kona-powder-and-particle-journal",
    label: "KONA Powder and Particle Journal"
  },
  {
    value: "korean-journal-of-anesthesiology",
    label: "Korean Journal of Anesthesiology"
  },
  {
    value: "korean-journal-of-radiology",
    label: "Korean Journal of Radiology"
  },
  {
    value: "kritische-ausgabe",
    label: "Kritische Ausgabe (Deutsch)"
  },
  {
    value: "ksce-journal-of-civil-engineering",
    label: "KSCE Journal of Civil Engineering"
  },
  {
    value: "kth-royal-institute-of-technology-school-of-computer-science-and-communication-sv",
    label: "KTH Royal Institute of Technology - School of Computer Science and Communication (Svenska)"
  },
  {
    value: "kth-royal-institute-of-technology-school-of-computer-science-and-communication",
    label: "KTH Royal Institute of Technology - School of Computer Science and Communication"
  },
  {
    value: "kunstakademie-munster",
    label: "Kunstakademie M\xFCnster (Deutsch)"
  },
  {
    value: "l-homme",
    label: "L'homme \u2013 Revue fran\xE7aise d'anthropologie"
  },
  {
    value: "la-revue-des-sciences-de-gestion",
    label: "La Revue des Sciences de Gestion (Fran\xE7ais)"
  },
  {
    value: "la-trobe-university-apa",
    label: "La Trobe University - APA 6th edition"
  },
  {
    value: "la-trobe-university-harvard",
    label: "La Trobe University - Harvard"
  },
  {
    value: "laboratory-animal-science-professional",
    label: "Laboratory Animal Science Professional"
  },
  {
    value: "lancaster-university-harvard",
    label: "Lancaster University - Harvard"
  },
  {
    value: "land-degradation-and-development",
    label: "Land Degradation & Development"
  },
  {
    value: "landes-bioscience-journals",
    label: "Landes Bioscience Journals"
  },
  {
    value: "language-in-society",
    label: "Language in Society"
  },
  {
    value: "language",
    label: "Language"
  },
  {
    value: "lannee-sociologique",
    label: "L\u2019Ann\xE9e sociologique (Fran\xE7ais)"
  },
  {
    value: "laser-and-photonics-reviews",
    label: "Laser & Photonics Reviews"
  },
  {
    value: "latin-american-perspectives",
    label: "Latin American Perspectives"
  },
  {
    value: "latin-american-research-review",
    label: "Latin American Research Review"
  },
  {
    value: "lauterbornia",
    label: "Lauterbornia - Internationale Zeitschrift f\xFCr Faunistik und Floristik des S\xFC\xDFwassers (Deutsch)"
  },
  {
    value: "law-and-society-review",
    label: "Law & Society Review"
  },
  {
    value: "law-citation-manual",
    label: "Law Citation Manual (\u4E2D\u6CD5\u5B66\u6CE8\u5F15\u624B\u518C, \u4E2D\u6587)"
  },
  {
    value: "law-technology-and-humans",
    label: "Law, Technology and Humans"
  },
  {
    value: "lcgc",
    label: "LCGC"
  },
  {
    value: "le-mouvement-social",
    label: "Le Mouvement Social (Fran\xE7ais)"
  },
  {
    value: "le-tapuscrit-author-date",
    label: "Le tapuscrit (\xC9cole des hautes \xE9tudes en sciences sociales) (author-date, Fran\xE7ais)"
  },
  {
    value: "le-tapuscrit-note",
    label: "Le tapuscrit (\xC9cole des hautes \xE9tudes en sciences sociales) (note, Fran\xE7ais)"
  },
  {
    value: "leiden-journal-of-international-law",
    label: "Leiden Journal of International Law"
  },
  {
    value: "leidraad-voor-juridische-auteurs",
    label: "Leidraad voor juridische auteurs 2019 (Nederlands)"
  },
  {
    value: "leonardo",
    label: "Leonardo"
  },
  {
    value: "les-cahiers-du-journalisme",
    label: "Les Cahiers du journalisme (Fran\xE7ais)"
  },
  {
    value: "les-journees-de-la-recherche-avicole",
    label: "Les Journ\xE9es de la Recherche Avicole (Fran\xE7ais)"
  },
  {
    value: "les-journees-de-la-recherche-porcine",
    label: "Les Journ\xE9es de la Recherche Porcine (Fran\xE7ais)"
  },
  {
    value: "les-nouvelles-de-l-archeologie",
    label: "Les nouvelles de l'arch\xE9ologie (Fran\xE7ais)"
  },
  {
    value: "lethaia",
    label: "Lethaia"
  },
  {
    value: "letters-in-applied-microbiology",
    label: "Letters in Applied Microbiology"
  },
  {
    value: "lettres-et-sciences-humaines-fr",
    label: "Lettres et Sciences Humaines (biblio et notes, Fran\xE7ais)"
  },
  {
    value: "leviathan",
    label: "Leviathan (Deutsch)"
  },
  {
    value: "lien-social-et-politiques",
    label: "Lien social et Politiques (Fran\xE7ais)"
  },
  {
    value: "limnetica",
    label: "Limnetica"
  },
  {
    value: "limnology-and-oceanography",
    label: "Limnology and Oceanography"
  },
  {
    value: "liver-international",
    label: "Liver International"
  },
  {
    value: "liverpool-john-moores-university-harvard",
    label: "Liverpool John Moores University - Harvard"
  },
  {
    value: "lluelles-no-ibid",
    label: "Guide des r\xE9f\xE9rences pour la r\xE9daction juridique 7e \xE9dition (Notes compl\xE8tes) (Guide Lluelles, no Ibid., Fran\xE7ais - Canada)"
  },
  {
    value: "lluelles",
    label: "Guide des r\xE9f\xE9rences pour la r\xE9daction juridique 7e \xE9dition (Guide Lluelles, Fran\xE7ais - Canada)"
  },
  {
    value: "london-metropolitan-university-harvard",
    label: "London Metropolitan University - Harvard"
  },
  {
    value: "london-review-of-international-law",
    label: "London Review of International Law"
  },
  {
    value: "london-south-bank-university-numeric",
    label: "London South Bank University (numeric)"
  },
  {
    value: "lund-university-school-of-economics-and-management",
    label: "Lund University School of Economics and Management"
  },
  {
    value: "macromolecular-reaction-engineering",
    label: "Macromolecular Reaction Engineering"
  },
  {
    value: "magnetic-resonance-in-medical-sciences",
    label: "Magnetic Resonance in Medical Sciences"
  },
  {
    value: "magnetic-resonance-in-medicine",
    label: "Magnetic Resonance in Medicine"
  },
  {
    value: "magnetic-resonance-materials-in-physics-biology-and-medicine",
    label: "Magnetic Resonance Materials in Physics, Biology and Medicine"
  },
  {
    value: "maison-de-l-orient-et-de-la-mediterranee-en",
    label: "Maison de l'Orient et de la M\xE9diterran\xE9e (English)"
  },
  {
    value: "maison-de-l-orient-et-de-la-mediterranee",
    label: "Maison de l'Orient et de la M\xE9diterran\xE9e (Fran\xE7ais)"
  },
  {
    value: "malaysian-orthopaedic-journal",
    label: "Malaysian Orthopaedic Journal"
  },
  {
    value: "mammal-review",
    label: "Mammal Review"
  },
  {
    value: "mammalia",
    label: "Mammalia"
  },
  {
    value: "mammalogy-notes",
    label: "Mammalogy Notes"
  },
  {
    value: "management-et-avenir",
    label: "Management & Avenir (Fran\xE7ais)"
  },
  {
    value: "management-international",
    label: "Management international"
  },
  {
    value: "management-of-biological-invasions",
    label: "Management of Biological Invasions"
  },
  {
    value: "manchester-university-press-author-date",
    label: "Manchester University Press monographs (author-date)"
  },
  {
    value: "manchester-university-press",
    label: "Manchester University Press monographs (note)"
  },
  {
    value: "marine-biology",
    label: "Marine Biology"
  },
  {
    value: "marine-mammal-science",
    label: "Marine Mammal Science"
  },
  {
    value: "marine-ornithology",
    label: "Marine Ornithology"
  },
  {
    value: "marine-turtle-newsletter",
    label: "Marine Turtle Newsletter"
  },
  {
    value: "marmara-universitesi-turkiyat-arastirmalari-enstitusu",
    label: "Marmara \xDCniversitesi - T\xFCrkiyat Ara\u015Ft\u0131rmalar\u0131 Enstit\xFCs\xFC (T\xFCrk\xE7e)"
  },
  {
    value: "mary-ann-liebert-harvard",
    label: "Mary Ann Liebert - Harvard"
  },
  {
    value: "mary-ann-liebert-vancouver",
    label: "Mary Ann Liebert - Vancouver"
  },
  {
    value: "masarykova-univerzita-pravnicka-fakulta",
    label: "Masarykova univerzita - Pr\xE1vnick\xE1 fakulta"
  },
  {
    value: "mastozoologia-neotropical",
    label: "Mastozoologia Neotropical"
  },
  {
    value: "materials-express",
    label: "Materials Express"
  },
  {
    value: "mathematical-geosciences",
    label: "Mathematical Geosciences"
  },
  {
    value: "mathematics-and-computers-in-simulation",
    label: "Mathematics and Computers in Simulation"
  },
  {
    value: "mcdonald-institute-monographs",
    label: "McDonald Institute Monographs"
  },
  {
    value: "mcgill-en",
    label: "Canadian Guide to Uniform Legal Citation 9th edition (McGill Guide)"
  },
  {
    value: "mcgill-fr",
    label: "Manuel canadien de la r\xE9f\xE9rence juridique 9e \xE9dition (Guide McGill, Fran\xE7ais - Canada)"
  },
  {
    value: "medecine-intensive-reanimation",
    label: "M\xE9decine Intensive R\xE9animation"
  },
  {
    value: "medecine-sciences",
    label: "m\xE9decine/sciences"
  },
  {
    value: "media-culture-and-society",
    label: "Media, Culture & Society"
  },
  {
    value: "mediaeval-studies",
    label: "Mediaeval Studies"
  },
  {
    value: "medical-dosimetry",
    label: "Medical Dosimetry"
  },
  {
    value: "medical-history",
    label: "Medical History"
  },
  {
    value: "medicina-clinica",
    label: "Medicina Cl\xEDnica (Espa\xF1ol)"
  },
  {
    value: "medicina-delle-dipendenze-italian-journal-of-the-addictions",
    label: "Medicina delle Dipendenze - Italian Journal of the Addictions (Italiano)"
  },
  {
    value: "medicinal-research-reviews",
    label: "Medicinal Research Reviews"
  },
  {
    value: "medicine-and-science-in-sports-and-exercise",
    label: "Medicine & Science in Sports & Exercise"
  },
  {
    value: "medicine-publishing",
    label: "Medicine Publishing"
  },
  {
    value: "medicinski-razgledi",
    label: "Medicinski razgledi"
  },
  {
    value: "medicinskiy-akademicheskiy-zhurnal",
    label: "Medicinskiy Akademicheskiy Zhurnal"
  },
  {
    value: "mediterranean-journal-of-chemistry",
    label: "Mediterranean Journal of Chemistry"
  },
  {
    value: "mediterranean-journal-of-infection-microbes-and-antimicrobials",
    label: "Mediterranean Journal of Infection, Microbes and Antimicrobials"
  },
  {
    value: "mediterranean-politics",
    label: "Mediterranean Politics"
  },
  {
    value: "melbourne-school-of-theology",
    label: "Melbourne School of Theology"
  },
  {
    value: "memorias-do-instituto-oswaldo-cruz",
    label: "Mem\xF3rias do Instituto Oswaldo Cruz"
  },
  {
    value: "mercator-institut-fur-sprachforderung-und-deutsch-als-zweitsprache",
    label: "Mercator-Institut f\xFCr Sprachf\xF6rderung und Deutsch als Zweitsprache (Deutsch)"
  },
  {
    value: "mercatus-center",
    label: "Mercatus Center"
  },
  {
    value: "metallurgical-and-materials-transactions-a",
    label: "Metallurgical and Materials Transactions A"
  },
  {
    value: "metallurgical-and-materials-transactions",
    label: "Metallurgical and Materials Transactions"
  },
  {
    value: "meteoritics-and-planetary-science",
    label: "Meteoritics & Planetary Science"
  },
  {
    value: "meteorological-applications",
    label: "Meteorological Applications"
  },
  {
    value: "method-and-theory-in-the-study-of-religion",
    label: "Method & Theory in the Study of Religion"
  },
  {
    value: "methods-of-information-in-medicine",
    label: "Methods of Information in Medicine"
  },
  {
    value: "metropol-verlag",
    label: "Metropol Verlag (Deutsch)"
  },
  {
    value: "metropolia-university-of-applied-sciences-harvard",
    label: "Metropolia Ammattikorkeakoulu - Harvard (Suomi)"
  },
  {
    value: "metropolitiques",
    label: "M\xE9tropolitiques (Fran\xE7ais)"
  },
  {
    value: "microbial-cell",
    label: "Microbial Cell"
  },
  {
    value: "microbiology-society",
    label: "Microbiology Society"
  },
  {
    value: "microcirculation",
    label: "Microcirculation"
  },
  {
    value: "microscopy-and-microanalysis",
    label: "Microscopy and Microanalysis"
  },
  {
    value: "middle-east-critique",
    label: "Middle East Critique"
  },
  {
    value: "midwestern-baptist-theological-seminary",
    label: "Midwestern Baptist Theological Seminary"
  },
  {
    value: "mimbar-hukum",
    label: "Mimbar Hukum"
  },
  {
    value: "mimesis-edizioni",
    label: "Mimesis Edizioni (Italiano)"
  },
  {
    value: "mind-and-language",
    label: "Mind & Language"
  },
  {
    value: "mineralogical-magazine",
    label: "Mineralogical Magazine"
  },
  {
    value: "mis-quarterly",
    label: "MIS Quarterly"
  },
  {
    value: "modern-chinese-literature-and-culture",
    label: "Modern Chinese Literature and Culture"
  },
  {
    value: "modern-humanities-research-association-author-date",
    label: "Modern Humanities Research Association 3rd edition (author-date)"
  },
  {
    value: "modern-humanities-research-association",
    label: "Modern Humanities Research Association 3rd edition (note with bibliography)"
  },
  {
    value: "modern-language-association-6th-edition-note",
    label: "Modern Language Association 6th edition (note)"
  },
  {
    value: "modern-language-association-7th-edition-underline",
    label: "Modern Language Association 7th edition (underline)"
  },
  {
    value: "modern-language-association-7th-edition-with-url",
    label: "Modern Language Association 7th edition (with URL)"
  },
  {
    value: "modern-language-association-7th-edition",
    label: "Modern Language Association 7th edition"
  },
  {
    value: "modern-language-association-8th-edition",
    label: "Modern Language Association 8th edition"
  },
  {
    value: "modern-language-association",
    label: "Modern Language Association 9th edition"
  },
  {
    value: "modern-pathology",
    label: "Modern Pathology"
  },
  {
    value: "modern-phytomorphology",
    label: "Modern Phytomorphology"
  },
  {
    value: "mohr-siebeck-recht",
    label: "Mohr Siebeck - Recht (Deutsch - \xD6sterreich)"
  },
  {
    value: "molecular-and-cellular-proteomics",
    label: "Molecular & Cellular Proteomics"
  },
  {
    value: "molecular-biology-and-evolution",
    label: "Molecular Biology and Evolution"
  },
  {
    value: "molecular-biology-of-the-cell",
    label: "Molecular Biology of the Cell"
  },
  {
    value: "molecular-biology",
    label: "Molecular Biology"
  },
  {
    value: "molecular-metabolism",
    label: "Molecular Metabolism"
  },
  {
    value: "molecular-microbiology",
    label: "Molecular Microbiology"
  },
  {
    value: "molecular-nutrition-and-food-research",
    label: "Molecular Nutrition & Food Research"
  },
  {
    value: "molecular-oncology",
    label: "Molecular Oncology"
  },
  {
    value: "molecular-plant-microbe-interactions",
    label: "Molecular Plant-Microbe Interactions"
  },
  {
    value: "molecular-plant-pathology",
    label: "Molecular Plant Pathology"
  },
  {
    value: "molecular-plant",
    label: "Molecular Plant"
  },
  {
    value: "molecular-psychiatry-letters",
    label: "Molecular Psychiatry (letters to the editor)"
  },
  {
    value: "molecular-psychiatry",
    label: "Molecular Psychiatry"
  },
  {
    value: "monash-university-csiro",
    label: "Monash University - CSIRO"
  },
  {
    value: "monash-university-harvard",
    label: "Monash University - Harvard"
  },
  {
    value: "mondes-en-developpement",
    label: "Mondes en d\xE9veloppement (Fran\xE7ais)"
  },
  {
    value: "monographs-of-the-palaeontographical-society",
    label: "Monographs of the Palaeontographical Society"
  },
  {
    value: "moore-theological-college",
    label: "Moore Theological College"
  },
  {
    value: "moorlands-college",
    label: "Moorlands College"
  },
  {
    value: "mrs-bulletin",
    label: "MRS Bulletin"
  },
  {
    value: "multidisciplinary-digital-publishing-institute",
    label: "Multidisciplinary Digital Publishing Institute"
  },
  {
    value: "multilingual-matters",
    label: "Multilingual Matters"
  },
  {
    value: "multimed",
    label: "Multimed (Espa\xF1ol)"
  },
  {
    value: "multiple-sclerosis-journal",
    label: "Multiple Sclerosis Journal"
  },
  {
    value: "muscle-and-nerve",
    label: "Muscle & Nerve"
  },
  {
    value: "museum-national-dhistoire-naturelle",
    label: "Mus\xE9um national d'Histoire naturelle"
  },
  {
    value: "music-theory-spectrum",
    label: "Music Theory Spectrum"
  },
  {
    value: "mutagenesis",
    label: "Mutagenesis"
  },
  {
    value: "mycobiology",
    label: "Mycobiology"
  },
  {
    value: "mycologia",
    label: "Mycologia"
  },
  {
    value: "myrmecological-news",
    label: "Myrmecological News"
  },
  {
    value: "nano-biomedicine-and-engineering",
    label: "Nano Biomedicine and Engineering"
  },
  {
    value: "natbib-plainnat-author-date",
    label: "natbib - plainnat (author-date)"
  },
  {
    value: "national-archives-of-australia",
    label: "National Archives of Australia"
  },
  {
    value: "national-institute-of-health-research",
    label: "National Institute of Health Research"
  },
  {
    value: "national-institute-of-organisation-dynamics-australia-harvard",
    label: "National Institute of Organisation Dynamics Australia - Harvard"
  },
  {
    value: "national-institute-of-technology-karnataka",
    label: "National Institute of Technology Karnataka"
  },
  {
    value: "national-institute-of-technology-tiruchirappalli",
    label: "National Institute of Technology, Tiruchirappalli"
  },
  {
    value: "national-library-of-medicine-grant-proposals",
    label: "National Library of Medicine (grant proposals with PMCID/PMID)"
  },
  {
    value: "national-marine-fisheries-service-national-environmental-policy-act",
    label: "National Marine Fisheries Service - National Environmental Policy Act"
  },
  {
    value: "national-natural-science-foundation-of-china",
    label: "National Natural Science Foundation of China (\u4E2D\u6587)"
  },
  {
    value: "national-science-foundation-grant-proposals",
    label: "National Science Foundation (grant proposals)"
  },
  {
    value: "national-university-of-singapore-department-of-geography-harvard",
    label: "National University of Singapore - Department of Geography - Harvard"
  },
  {
    value: "nations-and-nationalism",
    label: "Nations and Nationalism"
  },
  {
    value: "natur-und-landschaft",
    label: "Natur und Landschaft (Deutsch)"
  },
  {
    value: "natura-croatica",
    label: "Natura Croatica"
  },
  {
    value: "nature-neuroscience-brief-communications",
    label: "Nature Neuroscience (brief communications)"
  },
  {
    value: "nature-no-et-al",
    label: 'Nature (no "et al.")'
  },
  {
    value: "nature-no-superscript",
    label: "Nature (no superscript)"
  },
  {
    value: "nature-publishing-group-vancouver",
    label: "Nature Publishing Group - Vancouver"
  },
  {
    value: "nature",
    label: "Nature"
  },
  {
    value: "natures-sciences-societes",
    label: "Natures Sciences Soci\xE9t\xE9s"
  },
  {
    value: "nauplius",
    label: "Nauplius"
  },
  {
    value: "navigation",
    label: "Navigation"
  },
  {
    value: "nccr-mediality",
    label: "NCCR Mediality. Medienwandel - Medienwechsel - Medienwissen (Deutsch)"
  },
  {
    value: "necmettin-erbakan-universitesi-fen-ve-muhendislik-bilimleri-dergisi",
    label: "Necmettin Erbakan \xDCniversitesi Fen ve M\xFChendislik Bilimleri Dergisi (T\xFCrk\xE7e)"
  },
  {
    value: "nehet",
    label: "NeHeT (Fran\xE7ais)"
  },
  {
    value: "nejm-catalyst-innovations-in-care-delivery",
    label: "NEJM Catalyst Innovations in Care Delivery"
  },
  {
    value: "nephrology-dialysis-transplantation",
    label: "Nephrology Dialysis Transplantation"
  },
  {
    value: "netherlands-journal-of-geosciences-geologie-en-mijnbouw",
    label: "Netherlands Journal of Geosciences - Geologie en Mijnbouw"
  },
  {
    value: "neue-juristische-wochenschrift",
    label: "Neue Juristische Wochenschrift (Deutsch)"
  },
  {
    value: "neue-kriminalpolitik",
    label: "Neue Kriminalpolitik (Deutsch)"
  },
  {
    value: "neural-plasticity",
    label: "Neural Plasticity"
  },
  {
    value: "neuroendocrinology-letters",
    label: "Neuroendocrinology Letters"
  },
  {
    value: "neuroimaging-clinics-of-north-america",
    label: "Neuroimaging Clinics of North America"
  },
  {
    value: "neurologia-argentina",
    label: "Neurolog\xEDa Argentina (Espa\xF1ol)"
  },
  {
    value: "neurologia",
    label: "Neurolog\xEDa (Espa\xF1ol)"
  },
  {
    value: "neurology-india",
    label: "Neurology India"
  },
  {
    value: "neurology",
    label: "Neurology"
  },
  {
    value: "neuropsychopharmacology",
    label: "Neuropsychopharmacology"
  },
  {
    value: "neurorehabilitation-and-neural-repair",
    label: "Neurorehabilitation and Neural Repair"
  },
  {
    value: "neuroreport",
    label: "NeuroReport"
  },
  {
    value: "neurospine",
    label: "Neurospine"
  },
  {
    value: "neurosurgery-clinics-of-north-america",
    label: "Neurosurgery Clinics of North America"
  },
  {
    value: "new-harts-rules-the-oxford-style-guide",
    label: "New Hart's Rules: The Oxford Style Guide"
  },
  {
    value: "new-phytologist",
    label: "New Phytologist"
  },
  {
    value: "new-solutions",
    label: "New Solutions"
  },
  {
    value: "new-testament-studies",
    label: "New Testament Studies"
  },
  {
    value: "new-zealand-dental-journal",
    label: "New Zealand Dental Journal"
  },
  {
    value: "new-zealand-journal-of-forestry-science",
    label: "New Zealand Journal of Forestry Science"
  },
  {
    value: "new-zealand-journal-of-history",
    label: "New Zealand Journal of History"
  },
  {
    value: "new-zealand-plant-protection",
    label: "New Zealand Plant Protection"
  },
  {
    value: "new-zealand-veterinary-journal",
    label: "New Zealand Veterinary Journal"
  },
  {
    value: "nist-technical-publication-journal-of-research-of-nist",
    label: "NIST Technical Publications - Journal of Research of NIST"
  },
  {
    value: "nordic-pulp-and-paper-research-journal",
    label: "Nordic Pulp & Paper Research Journal"
  },
  {
    value: "norma-portuguesa-405",
    label: "Norma Portuguesa 405 (Portugu\xEAs)"
  },
  {
    value: "norois",
    label: "Norois (Fran\xE7ais)"
  },
  {
    value: "norsk-apa-manual-note",
    label: "Norsk APA-manual - APA 7th edition (note)"
  },
  {
    value: "norsk-apa-manual",
    label: "Norsk APA-manual - APA 7th edition (author-date)"
  },
  {
    value: "norsk-henvisningsstandard-for-rettsvitenskapelige-tekster",
    label: "Norsk henvisningsstandard for rettsvitenskapelige tekster (Norsk - Bokm\xE5l)"
  },
  {
    value: "northeastern-naturalist",
    label: "Northeastern Naturalist"
  },
  {
    value: "nottingham-trent-university-library-harvard",
    label: "Nottingham Trent University Library - Harvard"
  },
  {
    value: "nouvelles-perspectives-en-sciences-sociales",
    label: "Nouvelles perspectives en sciences sociales (Fran\xE7ais - Canada)"
  },
  {
    value: "novasinergia",
    label: "Novasinergia"
  },
  {
    value: "nowa-audiofonologia",
    label: "Nowa Audiofonologia (Polski)"
  },
  {
    value: "nuclear-receptor-signaling",
    label: "Nuclear Receptor Signaling"
  },
  {
    value: "nucleic-acids-research-web-server-issue",
    label: "Nucleic Acids Research - Web Server Issue"
  },
  {
    value: "nucleic-acids-research",
    label: "Nucleic Acids Research"
  },
  {
    value: "nutrition-research-reviews",
    label: "Nutrition Research Reviews"
  },
  {
    value: "obafemi-awolowo-university-faculty-of-technology",
    label: "Obafemi Awolowo University - Faculty of Technology"
  },
  {
    value: "obesity",
    label: "Obesity"
  },
  {
    value: "obstetrics-and-gynecology-science",
    label: "Obstetrics & Gynecology Science"
  },
  {
    value: "occupational-medicine",
    label: "Occupational Medicine"
  },
  {
    value: "ocean-and-coastal-research",
    label: "Ocean and Coastal Research"
  },
  {
    value: "oceanography",
    label: "Oceanography"
  },
  {
    value: "oecologia-australis",
    label: "Oecologia Australis"
  },
  {
    value: "offa",
    label: "Offa - Berichte und Mitteilungen zur Urgeschichte, Fr\xFChgeschichte und Mittelalterarch\xE4ologie"
  },
  {
    value: "oikos",
    label: "Oikos"
  },
  {
    value: "oil-shale",
    label: "Oil Shale"
  },
  {
    value: "oncoimmunology",
    label: "OncoImmunology"
  },
  {
    value: "oncotarget",
    label: "Oncotarget"
  },
  {
    value: "open-gender-journal",
    label: "Open Gender Journal"
  },
  {
    value: "open-window",
    label: "Open Window - Harvard"
  },
  {
    value: "operative-dentistry",
    label: "Operative Dentistry"
  },
  {
    value: "ophthalmic-genetics",
    label: "Ophthalmic Genetics"
  },
  {
    value: "ophthalmology-retina",
    label: "Ophthalmology Retina"
  },
  {
    value: "ophthalmology",
    label: "Ophthalmology"
  },
  {
    value: "optics-express",
    label: "Optics Express"
  },
  {
    value: "optics-letters",
    label: "Optics Letters"
  },
  {
    value: "opto-electronic-advances",
    label: "Opto-Electronic Advances"
  },
  {
    value: "optometry-and-vision-science",
    label: "Optometry & Vision Science"
  },
  {
    value: "opuscula",
    label: "Opuscula"
  },
  {
    value: "oral-diseases",
    label: "Oral Diseases"
  },
  {
    value: "organic-geochemistry",
    label: "Organic Geochemistry"
  },
  {
    value: "organised-sound",
    label: "Organised Sound"
  },
  {
    value: "organization-studies",
    label: "Organization Studies"
  },
  {
    value: "organization",
    label: "Organization"
  },
  {
    value: "organon",
    label: "Organon"
  },
  {
    value: "ornitologia-neotropical",
    label: "Ornitolog\xEDa Neotropical"
  },
  {
    value: "orthopedic-clinics-of-north-america",
    label: "Orthopedic Clinics of North America"
  },
  {
    value: "oryx",
    label: "Oryx"
  },
  {
    value: "oscola-no-ibid",
    label: "OSCOLA (Oxford University Standard for Citation of Legal Authorities) (no Ibid.)"
  },
  {
    value: "oscola",
    label: "OSCOLA (Oxford University Standard for Citation of Legal Authorities)"
  },
  {
    value: "osterreichische-zeitschrift-fur-politikwissenschaft",
    label: "\xD6sterreichische Zeitschrift f\xFCr Politikwissenschaft (Deutsch - \xD6sterreich)"
  },
  {
    value: "otto-von-guricke-universitat-magdeburg-medizinische-fakultat-numeric",
    label: "Otto-von-Guericke-Universit\xE4t Magdeburg - Medizinische Fakult\xE4t (numeric)"
  },
  {
    value: "owbarth-verlag",
    label: "O.W. Barth Verlag (Deutsch)"
  },
  {
    value: "oxford-art-journal",
    label: "Oxford Art Journal"
  },
  {
    value: "oxford-centre-for-mission-studies-harvard",
    label: "Oxford Centre for Mission Studies - Harvard"
  },
  {
    value: "oxford-studies-in-ancient-philosophy",
    label: "Oxford Studies in Ancient Philosophy"
  },
  {
    value: "oxford-studies-on-the-roman-economy",
    label: "Oxford Studies on the Roman Economy"
  },
  {
    value: "oxford-the-university-of-new-south-wales",
    label: "The University of New South Wales - Oxford"
  },
  {
    value: "oxford-university-press-humsoc",
    label: "Oxford University Press HUMSOC"
  },
  {
    value: "oxford-university-press-note",
    label: "Oxford University Press (note)"
  },
  {
    value: "oxford-university-press-scimed-author-date",
    label: "Oxford University Press SciMed (author-date)"
  },
  {
    value: "oxford-university-press-scimed-numeric",
    label: "Oxford University Press SciMed (numeric)"
  },
  {
    value: "oxidation-of-metals",
    label: "Oxidation of Metals"
  },
  {
    value: "pacific-conservation-biology",
    label: "Pacific Conservation Biology"
  },
  {
    value: "pacific-science",
    label: "Pacific Science"
  },
  {
    value: "padagogische-hochschule-bern-institut-vorschulstufe-und-primarstufe",
    label: "P\xE4dagogische Hochschule Bern - Institut Vorschulstufe und Primarstufe"
  },
  {
    value: "padagogische-hochschule-fachhochschule-nordwestschweiz",
    label: "P\xE4dagogische Hochschule Fachhochschule Nordwestschweiz (Deutsch - Schweiz)"
  },
  {
    value: "padagogische-hochschule-heidelberg",
    label: "P\xE4dagogische Hochschule Heidelberg (Deutsch)"
  },
  {
    value: "padagogische-hochschule-vorarlberg",
    label: "P\xE4dagogische Hochschule Vorarlberg (Deutsch)"
  },
  {
    value: "paediatric-and-perinatal-epidemiology",
    label: "Paediatric and Perinatal Epidemiology"
  },
  {
    value: "pain-medicine",
    label: "Pain Medicine"
  },
  {
    value: "pain",
    label: "PAIN"
  },
  {
    value: "pakistan-journal-of-agricultural-sciences",
    label: "Pakistan Journal of Agricultural Sciences"
  },
  {
    value: "pakistani-veterinary-journal",
    label: "Pakistan Veterinary Journal"
  },
  {
    value: "palaeodiversity",
    label: "Palaeodiversity"
  },
  {
    value: "palaeontographica-abteilung-b-palaeobotany-palaeophytology",
    label: "Palaeontographica Abteilung B: Palaeobotany - Palaeophytology"
  },
  {
    value: "palaeontologia-electronica",
    label: "Palaeontologia Electronica"
  },
  {
    value: "palaeontology",
    label: "Palaeontology"
  },
  {
    value: "palaeovertebrata",
    label: "Palaeovertebrata"
  },
  {
    value: "palaios",
    label: "Palaios"
  },
  {
    value: "paleobiology",
    label: "Paleobiology"
  },
  {
    value: "parasite",
    label: "Parasite"
  },
  {
    value: "parasitology",
    label: "Parasitology"
  },
  {
    value: "past-and-present",
    label: "Past & Present"
  },
  {
    value: "pediatric-allergy-and-immunology",
    label: "Pediatric Allergy and Immunology"
  },
  {
    value: "pediatric-anesthesia",
    label: "Pediatric Anesthesia"
  },
  {
    value: "pediatric-blood-and-cancer",
    label: "Pediatric Blood & Cancer"
  },
  {
    value: "pediatric-infectious-disease-journal",
    label: "Pediatric Infectious Disease Journal"
  },
  {
    value: "pediatric-physical-therapy",
    label: "Pediatric Physical Therapy"
  },
  {
    value: "pediatric-practice-and-research",
    label: "Pediatric Practice and Research"
  },
  {
    value: "pediatric-pulmonology",
    label: "Pediatric Pulmonology"
  },
  {
    value: "pediatric-research",
    label: "Pediatric Research"
  },
  {
    value: "pediatric-urology-case-reports",
    label: "Pediatric Urology Case Reports"
  },
  {
    value: "pedosphere",
    label: "Pedosphere"
  },
  {
    value: "peerj",
    label: "PeerJ"
  },
  {
    value: "pensoft-journals",
    label: "Pensoft Journals"
  },
  {
    value: "periodicum-biologorum",
    label: "Periodicum Biologorum"
  },
  {
    value: "periodontology-2000",
    label: "Periodontology 2000"
  },
  {
    value: "permafrost-and-periglacial-processes",
    label: "Permafrost and Periglacial Processes"
  },
  {
    value: "perspectives-on-sexual-and-reproductive-health",
    label: "Perspectives on Sexual and Reproductive Health"
  },
  {
    value: "pesquisa-agropecuaria-brasileira",
    label: "Pesquisa Agropecu\xE1ria Brasileira (Portugu\xEAs - Brasil)"
  },
  {
    value: "pest-management-science",
    label: "Pest Management Science"
  },
  {
    value: "petit-chicago-author-date",
    label: "Petit Chicago (author-date, Fran\xE7ais - Canada)"
  },
  {
    value: "pharmacoepidemiology-and-drug-safety",
    label: "Pharmacoepidemiology and Drug Safety"
  },
  {
    value: "philippika",
    label: "Philippika (Deutsch)"
  },
  {
    value: "philipps-universitat-marburg-note",
    label: "Philipps-Universit\xE4t Marburg - Erziehungswissenschaften (note, Deutsch)"
  },
  {
    value: "philosophia-scientiae",
    label: "Philosophia Scienti\xE6"
  },
  {
    value: "philosophiques",
    label: "Philosophiques (Fran\xE7ais)"
  },
  {
    value: "philosophy-and-public-affairs",
    label: "Philosophy & Public Affairs"
  },
  {
    value: "photochemistry-and-photobiology",
    label: "Photochemistry and Photobiology"
  },
  {
    value: "photosynthetica",
    label: "Photosynthetica"
  },
  {
    value: "phycological-research",
    label: "Phycological Research"
  },
  {
    value: "phyllomedusa",
    label: "Phyllomedusa"
  },
  {
    value: "physiologia-plantarum",
    label: "Physiologia Plantarum"
  },
  {
    value: "physiological-and-biochemical-zoology",
    label: "Physiological and Biochemical Zoology"
  },
  {
    value: "physiotherapy-theory-and-practice",
    label: "Physiotherapy Theory and Practice"
  },
  {
    value: "phytopathologia-mediterranea",
    label: "Phytopathologia Mediterranea"
  },
  {
    value: "phytotaxa",
    label: "Phytotaxa"
  },
  {
    value: "pisa-university-press",
    label: "Pisa University Press"
  },
  {
    value: "planning-practice-and-research",
    label: "Planning Practice & Research"
  },
  {
    value: "plant-and-cell-physiology",
    label: "Plant & Cell Physiology"
  },
  {
    value: "plant-biology",
    label: "Plant Biology"
  },
  {
    value: "plant-biotechnology-journal",
    label: "Plant Biotechnology Journal"
  },
  {
    value: "plant-cell-and-environment",
    label: "Plant, Cell & Environment"
  },
  {
    value: "plant-genetic-resources-characterization-and-utilization",
    label: "Plant Genetic Resources - Characterization and Utilization"
  },
  {
    value: "plant-pathology",
    label: "Plant Pathology"
  },
  {
    value: "plant-physiology",
    label: "Plant Physiology"
  },
  {
    value: "plant-species-biology",
    label: "Plant Species Biology"
  },
  {
    value: "plos",
    label: "Public Library of Science"
  },
  {
    value: "pnas",
    label: "Proceedings of the National Academy of Sciences of the United States of America"
  },
  {
    value: "podzemna-voda",
    label: "Podzemn\xE1 voda (Sloven\u010Dina)"
  },
  {
    value: "polar-research",
    label: "Polar Research"
  },
  {
    value: "polish-legal",
    label: "Polish Legal (Polski)"
  },
  {
    value: "politeknik-negeri-manado-jurnal-p3m",
    label: "Politeknik Negeri Manado - Jurnal Pusat Penelitian dan Pengabdian Kepada Masyarakat (Bahasa Indonesia)"
  },
  {
    value: "political-studies",
    label: "Political Studies"
  },
  {
    value: "politische-vierteljahresschrift",
    label: "Politische Vierteljahresschrift (Deutsch)"
  },
  {
    value: "politix",
    label: "Politix (Fran\xE7ais)"
  },
  {
    value: "polymer-reviews",
    label: "Polymer Reviews"
  },
  {
    value: "pontifical-athenaeum-regina-apostolorum",
    label: "Pontifical Athenaeum Regina Apostolorum"
  },
  {
    value: "pontifical-biblical-institute",
    label: "Pontifical Biblical Institute"
  },
  {
    value: "pontifical-gregorian-university",
    label: "Pontifical Gregorian University (Italiano)"
  },
  {
    value: "population-space-and-place",
    label: "Population, Space and Place"
  },
  {
    value: "population",
    label: "Population (Fran\xE7ais)"
  },
  {
    value: "postepy-higieny-i-medycyny-doswiadczalnej",
    label: "Post\u0119py Higieny i Medycyny Do\u015Bwiadczalnej (Polski)"
  },
  {
    value: "poultry-science",
    label: "Poultry Science"
  },
  {
    value: "pour-reussir-note",
    label: "Pour r\xE9ussir (note, Fran\xE7ais - Canada)"
  },
  {
    value: "pravnik",
    label: "Pr\xE1vn\xEDk (\u010Ce\u0161tina)"
  },
  {
    value: "praxis",
    label: "Praxis (Deutsch - Schweiz)"
  },
  {
    value: "prehistoires-mediterraneennes",
    label: "Pr\xE9histoires m\xE9diterran\xE9ennes"
  },
  {
    value: "prehospital-emergency-care",
    label: "Prehospital Emergency Care"
  },
  {
    value: "preslia",
    label: "Preslia - The Journal of the Czech Botanical Society"
  },
  {
    value: "presses-universitaires-de-paris-nanterre",
    label: "Presses universitaires de Paris Nanterre (note, Fran\xE7ais)"
  },
  {
    value: "presses-universitaires-de-rennes-archeologie-et-culture",
    label: "Presses Universitaires de Rennes - Arch\xE9ologie et Culture (Fran\xE7ais)"
  },
  {
    value: "presses-universitaires-de-rennes",
    label: "Presses Universitaires de Rennes (Fran\xE7ais)"
  },
  {
    value: "presses-universitaires-de-strasbourg-note",
    label: "Presses universitaires de Strasbourg (note, Fran\xE7ais)"
  },
  {
    value: "primary-care-clinics-in-office-practice",
    label: "Primary Care: Clinics in Office Practice"
  },
  {
    value: "proceedings-of-the-joint-international-grassland-and-international-rangeland-congress-2021",
    label: "Proceedings of the Joint International Grassland & International Rangeland Congress 2021"
  },
  {
    value: "proceedings-of-the-royal-society-b",
    label: "Proceedings of the Royal Society B"
  },
  {
    value: "processing-and-application-of-ceramics",
    label: "Processing and Application of Ceramics"
  },
  {
    value: "production-and-operations-management",
    label: "Production and Operations Management"
  },
  {
    value: "proinflow",
    label: "ProInflow (note, \u010Ce\u0161tina)"
  },
  {
    value: "protein-engineering-design-and-selection",
    label: "Protein Engineering Design and Selection"
  },
  {
    value: "protein-science",
    label: "Protein Science"
  },
  {
    value: "proteomics",
    label: "PROTEOMICS"
  },
  {
    value: "psychiatric-clinics-of-north-america",
    label: "Psychiatric Clinics of North America"
  },
  {
    value: "psychiatric-services",
    label: "Psychiatric Services"
  },
  {
    value: "psychiatry-and-clinical-neurosciences",
    label: "Psychiatry and Clinical Neurosciences"
  },
  {
    value: "psychological-medicine",
    label: "Psychological Medicine"
  },
  {
    value: "psychosomatic-medicine",
    label: "Psychosomatic Medicine"
  },
  {
    value: "psychosomatics",
    label: "Psychosomatics"
  },
  {
    value: "public-health-nutrition",
    label: "Public Health Nutrition"
  },
  {
    value: "pure-and-applied-geophysics",
    label: "Pure and Applied Geophysics"
  },
  {
    value: "qeios",
    label: "Qeios"
  },
  {
    value: "quaderni-degli-avogadro-colloquia",
    label: "Quaderni degli Avogadro Colloquia"
  },
  {
    value: "quaderni-materialisti",
    label: "Quaderni Materialisti (Italiano)"
  },
  {
    value: "quaderni",
    label: "Quaderni (Italiano)"
  },
  {
    value: "quaternaire",
    label: "Quaternaire (Fran\xE7ais)"
  },
  {
    value: "quaternary-international",
    label: "Quaternary International"
  },
  {
    value: "queen-margaret-university-harvard",
    label: "Queen Margaret University - Harvard"
  },
  {
    value: "r-and-d-management",
    label: "R&D Management"
  },
  {
    value: "radiation-protection-dosimetry",
    label: "Radiation Protection Dosimetry"
  },
  {
    value: "radiochimica-acta",
    label: "Radiochimica Acta"
  },
  {
    value: "radiographics",
    label: "RadioGraphics"
  },
  {
    value: "radiography",
    label: "Radiography"
  },
  {
    value: "radiologic-clinics-of-north-america",
    label: "Radiologic Clinics of North America"
  },
  {
    value: "radiology",
    label: "Radiology"
  },
  {
    value: "radiopaedia",
    label: "Radiopaedia.org"
  },
  {
    value: "raffles-bulletin-of-zoology",
    label: "Raffles Bulletin of Zoology"
  },
  {
    value: "rassegna-degli-archivi-di-stato",
    label: "Rassegna degli Archivi di Stato (citazioni estese, italiano)"
  },
  {
    value: "recent-patents-on-drug-delivery-and-formulation",
    label: "Recent Patents on Drug Delivery & Formulation"
  },
  {
    value: "recherches-en-sciences-de-gestion",
    label: "Recherches en Sciences de Gestion (Fran\xE7ais)"
  },
  {
    value: "refugee-survey-quarterly",
    label: "Refugee Survey Quarterly"
  },
  {
    value: "register-studies",
    label: "Register Studies"
  },
  {
    value: "religion-in-the-roman-empire",
    label: "Religion in the Roman Empire"
  },
  {
    value: "renewable-agriculture-and-food-systems",
    label: "Renewable Agriculture and Food Systems"
  },
  {
    value: "reports-of-practical-oncology-and-radiotherapy",
    label: "Reports of Practical Oncology and Radiotherapy"
  },
  {
    value: "representation",
    label: "Representation"
  },
  {
    value: "reproduction-fertility-and-development",
    label: "Reproduction, Fertility and Development"
  },
  {
    value: "reproduction",
    label: "Reproduction"
  },
  {
    value: "research-and-education-promotion-association",
    label: "Research and Education Promotion Association"
  },
  {
    value: "research-in-plant-disease",
    label: "Research in Plant Disease"
  },
  {
    value: "research-institute-for-nature-and-forest",
    label: "Research Institute for Nature and Forest (Instituut voor Natuur- en Bosonderzoek)"
  },
  {
    value: "research-on-biomedical-engineering",
    label: "Research on Biomedical Engineering"
  },
  {
    value: "respiratory-care-journal",
    label: "Respiratory Care Journal"
  },
  {
    value: "restoration-ecology",
    label: "Restoration Ecology"
  },
  {
    value: "rever-revista-de-estudos-da-religiao",
    label: "REVER - Revista de Estudos da Religi\xE3o"
  },
  {
    value: "review-of-international-studies",
    label: "Review of International Studies"
  },
  {
    value: "review-of-political-economy",
    label: "Review of Political Economy"
  },
  {
    value: "reviews-of-modern-physics-with-titles",
    label: "Reviews of Modern Physics (with titles)"
  },
  {
    value: "revista-argentina-de-antropologia-biologica",
    label: "Revista Argentina de Antropologia Biologica (Espa\xF1ol)"
  },
  {
    value: "revista-biblica",
    label: "Revista B\xEDblica (Espa\xF1ol)"
  },
  {
    value: "revista-brasileira-de-ciencia-do-solo",
    label: "Revista Brasileira de Ci\xEAncia do Solo"
  },
  {
    value: "revista-chilena-de-derecho-y-tecnologia",
    label: "Revista Chilena de Derecho y Tecnolog\xEDa (Espa\xF1ol - Chile)"
  },
  {
    value: "revista-ciencias-tecnicas-agropecuarias",
    label: "Revista Ciencias T\xE9cnicas Agropecuarias (Espa\xF1ol)"
  },
  {
    value: "revista-cubana-de-meteorologia",
    label: "Revista Cubana de Meteorologia"
  },
  {
    value: "revista-da-sociedade-brasileira-de-medicina-tropical",
    label: "Revista da Sociedade Brasileira de Medicina Tropical"
  },
  {
    value: "revista-de-biologia-marina-y-oceanografia",
    label: "Revista de Biolog\xEDa Marina y Oceanograf\xEDa"
  },
  {
    value: "revista-de-biologia-tropical",
    label: "Revista de Biolog\xEDa Tropical (International Journal of Tropical Biology and Conservation)"
  },
  {
    value: "revista-de-filologia-espanola",
    label: "Revista de Filolog\xEDa Espa\xF1ola (Espa\xF1ol)"
  },
  {
    value: "revista-do-instituto-de-medicina-tropical-de-sao-paulo",
    label: "Revista do Instituto de Medicina Tropical de S\xE3o Paulo"
  },
  {
    value: "revista-espanola-de-nutricion-humana-y-dietetica",
    label: "Revista Espanola de Nutricion Humana y Dietetica (Espa\xF1ol)"
  },
  {
    value: "revista-fave-seccion-ciencias-agrarias",
    label: "Revista FAVE - Secci\xF3n Ciencias Agrarias (Espa\xF1ol)"
  },
  {
    value: "revista-ladinia",
    label: "Revista Ladinia"
  },
  {
    value: "revista-latinoamericana-de-metalurgia-y-materiales",
    label: "Revista Latinoamericana de Metalurgia y Materiales"
  },
  {
    value: "revista-latinoamericana-de-recursos-naturales",
    label: "Revista Latinoamericana de Recursos Naturales"
  },
  {
    value: "revista-materia",
    label: "Revista Mat\xE9ria"
  },
  {
    value: "revista-noesis",
    label: "Revista N\xF3esis"
  },
  {
    value: "revista-peruana-de-medicina-experimental-y-salud-publica",
    label: "Revista Peruana de Medicina Experimental y Salud P\xFAblica (Espa\xF1ol)"
  },
  {
    value: "revista-portuguesa-de-arqueologia",
    label: "Revista Portuguesa de Arqueologia"
  },
  {
    value: "revista-virtual-de-quimica",
    label: "Revista Virtual de Qu\xEDmica (Portugu\xEAs - Brasil)"
  },
  {
    value: "revue-archeologique-de-lest",
    label: "Revue arch\xE9ologique de l\u2019Est (Fran\xE7ais)"
  },
  {
    value: "revue-archeologique-de-narbonnaise",
    label: "Revue arch\xE9ologique de Narbonnaise (French)"
  },
  {
    value: "revue-archeologique-du-centre-de-la-france",
    label: "Revue arch\xE9ologique du Centre de la France (Fran\xE7ais)"
  },
  {
    value: "revue-archeologique",
    label: "Revue Arch\xE9ologique (Fran\xE7ais)"
  },
  {
    value: "revue-d-elevage-et-de-medecine-veterinaire-des-pays-tropicaux",
    label: "Revue d'\xE9levage et de m\xE9decine v\xE9t\xE9rinaire des pays tropicaux (Fran\xE7ais)"
  },
  {
    value: "revue-de-medecine-veterinaire",
    label: "Revue de M\xE9decine V\xE9t\xE9rinaire (Fran\xE7ais)"
  },
  {
    value: "revue-de-qumran",
    label: "Revue de Qumr\xE2n"
  },
  {
    value: "revue-des-etudes-byzantines",
    label: "Revue des \xC9tudes Byzantines"
  },
  {
    value: "revue-des-nouvelles-technologies-de-l-information",
    label: "Revue des Nouvelles Technologies de l'Information (Fran\xE7ais)"
  },
  {
    value: "revue-dhistoire-des-sciences-humaines",
    label: "Revue d'histoire des sciences humaines (Fran\xE7ais)"
  },
  {
    value: "revue-dhistoire-moderne-et-contemporaine",
    label: "Revue d'histoire moderne et contemporaine (Fran\xE7ais)"
  },
  {
    value: "revue-europeenne-des-migrations-internationales",
    label: "Revue Europe\u0301enne des Migrations Internationales"
  },
  {
    value: "revue-forestiere-francaise",
    label: "Revue foresti\xE8re fran\xE7aise (Fran\xE7ais)"
  },
  {
    value: "revue-francaise-d-administration-publique",
    label: "Revue fran\xE7aise d'administration publique (Fran\xE7ais)"
  },
  {
    value: "revue-francaise-de-gestion",
    label: "Revue fran\xE7aise de gestion (Fran\xE7ais)"
  },
  {
    value: "revue-francaise-de-sociologie",
    label: "Revue fran\xE7aise de sociologie (Fran\xE7ais)"
  },
  {
    value: "rhinology",
    label: "Rhinology"
  },
  {
    value: "rhodora",
    label: "Rhodora"
  },
  {
    value: "risk-analysis",
    label: "Risk Analysis"
  },
  {
    value: "ritid",
    label: "Riti\xF0: t\xEDmarit Hugv\xEDsindastofnunar (\xCDslenska)"
  },
  {
    value: "rivista-italiana-di-paleontologia-e-stratigrafia",
    label: "Rivista Italiana di Paleontologia e Stratigrafia"
  },
  {
    value: "rmit-university-harvard",
    label: "RMIT University - Harvard"
  },
  {
    value: "rofo",
    label: "R\xF6Fo: Fortschritte auf dem Gebiet der R\xF6ntgenstrahlen und bildgebenden Verfahren"
  },
  {
    value: "romanian-humanities",
    label: "Romanian Humanities (Rom\xE2n\u0103)"
  },
  {
    value: "rose-school",
    label: "ROSE School"
  },
  {
    value: "rossiiskii-fiziologicheskii-zhurnal-imeni-i-m-sechenova",
    label: "\u0420\u043E\u0441\u0441\u0438\u0439\u0441\u043A\u0438\u0439 \u0444\u0438\u0437\u0438\u043E\u043B\u043E\u0433\u0438\u0447\u0435\u0441\u043A\u0438\u0439 \u0436\u0443\u0440\u043D\u0430\u043B \u0438\u043C. \u0418.\u041C. \u0421\u0435\u0447\u0435\u043D\u043E\u0432\u0430 (\u0420\u0443\u0301\u0441\u0441\u043A\u0438\u0439)"
  },
  {
    value: "royal-college-of-nursing-harvard",
    label: "Royal College of Nursing - Harvard"
  },
  {
    value: "royal-society-of-chemistry-with-titles",
    label: "Royal Society of Chemistry (with titles)"
  },
  {
    value: "royal-society-of-chemistry",
    label: "Royal Society of Chemistry"
  },
  {
    value: "rtf-scan",
    label: "RTF Scan"
  },
  {
    value: "ruhr-universitat-bochum-lehrstuhl-fur-industrial-sales-and-service-engineering",
    label: "Ruhr-Universit\xE4t Bochum - Lehrstuhl f\xFCr Industrial Sales and Service Engineering"
  },
  {
    value: "ruhr-universitat-bochum-medizinische-fakultat-numeric",
    label: "Ruhr-Universit\xE4t Bochum - Medizinische Fakult\xE4t (numerisch, Deutsch)"
  },
  {
    value: "sage-harvard",
    label: "SAGE - Harvard"
  },
  {
    value: "sage-vancouver-brackets",
    label: "SAGE - Vancouver (brackets)"
  },
  {
    value: "sage-vancouver",
    label: "SAGE - Vancouver"
  },
  {
    value: "saglik-bilimleri-universitesi",
    label: "Sa\u011Fl\u0131k Bilimleri \xDCniversitesi"
  },
  {
    value: "saint-paul-university-faculty-of-canon-law",
    label: "Saint Paul University - Faculty of Canon Law"
  },
  {
    value: "san-francisco-estuary-and-watershed-science",
    label: "San Francisco Estuary & Watershed Science"
  },
  {
    value: "sanamed",
    label: "Sanamed"
  },
  {
    value: "scandinavian-journal-of-infectious-diseases",
    label: "Scandinavian Journal of Infectious Diseases"
  },
  {
    value: "scandinavian-journal-of-information-systems",
    label: "Scandinavian Journal of Information Systems"
  },
  {
    value: "scandinavian-journal-of-medicine-and-science-in-sports",
    label: "Scandinavian Journal of Medicine & Science in Sports"
  },
  {
    value: "scandinavian-journal-of-rheumatology",
    label: "Scandinavian Journal of Rheumatology"
  },
  {
    value: "scandinavian-journal-of-work-environment-and-health",
    label: "Scandinavian Journal of Work, Environment & Health"
  },
  {
    value: "scandinavian-political-studies",
    label: "Scandinavian Political Studies"
  },
  {
    value: "science-and-technology-for-the-built-environment",
    label: "Science and Technology for the Built Environment"
  },
  {
    value: "science-china-chemistry",
    label: "Science China Chemistry"
  },
  {
    value: "science-china-earth-sciences",
    label: "SCIENCE CHINA Earth Sciences"
  },
  {
    value: "science-china-life-sciences",
    label: "SCIENCE CHINA Life Sciences"
  },
  {
    value: "science-china-materials",
    label: "SCIENCE CHINA Materials"
  },
  {
    value: "science-translational-medicine",
    label: "Science Translational Medicine"
  },
  {
    value: "science-without-titles",
    label: "Science (without titles)"
  },
  {
    value: "science",
    label: "Science"
  },
  {
    value: "scienceasia",
    label: "ScienceAsia"
  },
  {
    value: "sciences-po-ecole-doctorale-author-date",
    label: "Sciences Po - Ecole doctorale (author-date, Fran\xE7ais)"
  },
  {
    value: "sciences-po-ecole-doctorale-note-french",
    label: "Sciences Po - \xC9cole doctorale (note, Fran\xE7ais)"
  },
  {
    value: "scientia-agriculturae-bohemica",
    label: "Scientia Agriculturae Bohemica"
  },
  {
    value: "scientia-iranica",
    label: "Scientia Iranica"
  },
  {
    value: "scientific-review-engineering-and-environmental-sciences",
    label: "Scientific Review Engineering and Environmental Sciences (Przegl\u0105d Naukowy In\u017Cynieria i Kszta\u0142towanie \u015Arodowiska)"
  },
  {
    value: "scrinium",
    label: "Scrinium"
  },
  {
    value: "sedimentology",
    label: "Sedimentology"
  },
  {
    value: "seed-science-and-technology",
    label: "Seed Science and Technology"
  },
  {
    value: "seed-science-research",
    label: "Seed Science Research"
  },
  {
    value: "seismological-research-letters",
    label: "Seismological Research Letters"
  },
  {
    value: "sekolah-tinggi-meteorologi-klimatologi-dan-geofisika",
    label: "Sekolah Tinggi Meteorologi Klimatologi dan Geofisika (Bahasa Indonesia)"
  },
  {
    value: "seminaire-saint-sulpice-ecole-theologie",
    label: "S\xE9minaire Saint-Sulpice - Ecole Th\xE9ologie (Fran\xE7ais)"
  },
  {
    value: "seminars-in-pediatric-neurology",
    label: "Seminars in Pediatric Neurology"
  },
  {
    value: "serbian-archives-of-medicine",
    label: "Vancouver - Serbian Archives of Medicine"
  },
  {
    value: "serdica-journal-of-computing",
    label: "Serdica Journal of Computing"
  },
  {
    value: "service-medical-de-l-assurance-maladie",
    label: "Service M\xE9dical de l'Assurance Maladie (Fran\xE7ais)"
  },
  {
    value: "sexual-development",
    label: "Sexual Development"
  },
  {
    value: "sexual-health",
    label: "Sexual Health"
  },
  {
    value: "sheffield-hallam-university-history",
    label: "Sheffield Hallam University - History"
  },
  {
    value: "shock",
    label: "Shock"
  },
  {
    value: "sinergie-italian-journal-of-management",
    label: "Sinergie Italian Journal of Management"
  },
  {
    value: "sist02",
    label: "SIST02 (\u65E5\u672C\u8A9E)"
  },
  {
    value: "skene-journal-of-theatre-and-drama-studies",
    label: "Sken\xE8. Journal of Theatre and Drama Studies"
  },
  {
    value: "small",
    label: "Small"
  },
  {
    value: "smithsonian-institution-scholarly-press-author-date",
    label: "Smithsonian Institution Scholarly Press (author-date)"
  },
  {
    value: "smithsonian-institution-scholarly-press-botany",
    label: "Smithsonian Institution Scholarly Press - Botany (author-date)"
  },
  {
    value: "smithsonian-institution-scholarly-press-note",
    label: "Smithsonian Institution Scholarly Press (note)"
  },
  {
    value: "smyrna-tip-dergisi",
    label: "Smyrna T\u0131p Dergisi (T\xFCrk\xE7e)"
  },
  {
    value: "social-anthropology",
    label: "Social Anthropology/Anthropologie Sociale"
  },
  {
    value: "social-cognitive-and-affective-neuroscience",
    label: "Social Cognitive and Affective Neuroscience"
  },
  {
    value: "sociedade-brasileira-de-computacao",
    label: "Sociedade Brasileira de Computa\xE7\xE3o"
  },
  {
    value: "societe-archeologique-de-bordeaux",
    label: "Soci\xE9t\xE9 Arch\xE9ologique de Bordeaux (Fran\xE7ais)"
  },
  {
    value: "societe-francaise-detude-de-la-ceramique-antique-en-gaule",
    label: "Soci\xE9t\xE9 Fran\xE7aise d\u2019\xC9tude de la C\xE9ramique Antique en Gaule (Fran\xE7ais)"
  },
  {
    value: "societe-nationale-des-groupements-techniques-veterinaires",
    label: "Soci\xE9t\xE9 Nationale des Groupements Techniques V\xE9t\xE9rinaires (Fran\xE7ais)"
  },
  {
    value: "societes-contemporaines",
    label: "Soci\xE9t\xE9s Contemporaines"
  },
  {
    value: "society-for-american-archaeology",
    label: "Society for American Archaeology"
  },
  {
    value: "society-for-historical-archaeology",
    label: "Society for Historical Archaeology"
  },
  {
    value: "society-for-laboratory-automation-and-screening",
    label: "Society for Laboratory Automation and Screening"
  },
  {
    value: "society-of-automotive-engineers-technical-papers-numeric",
    label: "Society of Automotive Engineers Technical Papers (numeric)"
  },
  {
    value: "society-of-biblical-literature-1st-edition-fullnote-bibliography",
    label: "Society of Biblical Literature 1st edition (full note)"
  },
  {
    value: "society-of-biblical-literature-author-date",
    label: "Society of Biblical Literature 2nd edition (author-date)"
  },
  {
    value: "society-of-biblical-literature-fullnote-bibliography",
    label: "Society of Biblical Literature 2nd edition (full note)"
  },
  {
    value: "socio-economic-review",
    label: "Socio-Economic Review"
  },
  {
    value: "sociology-of-health-and-illness",
    label: "Sociology of Health & Illness"
  },
  {
    value: "sodertorns-hogskola-harvard-ibid",
    label: "S\xF6dert\xF6rns h\xF6gskola - Harvard (with Ibid.)"
  },
  {
    value: "sodertorns-hogskola-harvard",
    label: "S\xF6dert\xF6rns h\xF6gskola - Harvard"
  },
  {
    value: "sodertorns-hogskola-oxford",
    label: "S\xF6dert\xF6rns h\xF6gskola - Oxford"
  },
  {
    value: "soil-biology-and-biochemistry",
    label: "Soil Biology and Biochemistry"
  },
  {
    value: "soil-science-and-plant-nutrition",
    label: "Soil Science and Plant Nutrition"
  },
  {
    value: "solent-university-harvard",
    label: "Solent University - Harvard"
  },
  {
    value: "solutions",
    label: "Solutions"
  },
  {
    value: "sorbonne-student-law-review",
    label: "Sorbonne Student Law Review - Revue juridique des \xE9tudiants de la Sorbonne"
  },
  {
    value: "south-african-actuarial-journal",
    label: "South African Actuarial Journal"
  },
  {
    value: "south-african-journal-of-animal-science",
    label: "South African Journal of Animal Science"
  },
  {
    value: "south-african-journal-of-enology-and-viticulture",
    label: "South African Journal of Enology and Viticulture"
  },
  {
    value: "south-african-journal-of-geology",
    label: "South African Journal of Geology"
  },
  {
    value: "south-african-medical-journal",
    label: "South African Medical Journal"
  },
  {
    value: "south-african-theological-seminary",
    label: "South African Theological Seminary"
  },
  {
    value: "southeastern-geographer",
    label: "Southeastern Geographer"
  },
  {
    value: "southern-african-journal-of-critical-care",
    label: "Southern African Journal of Critical Care"
  },
  {
    value: "soziale-welt",
    label: "Soziale Welt (Deutsch)"
  },
  {
    value: "sozialpadagogisches-institut-berlin-walter-may",
    label: "Sozialp\xE4dagogisches Institut Berlin - Walter May (Deutsch)"
  },
  {
    value: "sozialwissenschaften-heilmann",
    label: "Sozialwissenschaften (Heilmann) (Deutsch)"
  },
  {
    value: "soziologie",
    label: "Soziologie (Deutsch)"
  },
  {
    value: "soziologiemagazin",
    label: "Soziologiemagazin (Deutsch)"
  },
  {
    value: "spandidos-publications",
    label: "Spandidos Publications"
  },
  {
    value: "spanish-legal",
    label: "Spanish Legal (Espa\xF1ol)"
  },
  {
    value: "spectroscopy-letters",
    label: "Spectroscopy Letters"
  },
  {
    value: "speculum",
    label: "Speculum"
  },
  {
    value: "spie-bios",
    label: "SPIE BiOS"
  },
  {
    value: "spie-journals",
    label: "SPIE journals"
  },
  {
    value: "spie-proceedings",
    label: "SPIE Conference Proceedings"
  },
  {
    value: "spine",
    label: "Spine"
  },
  {
    value: "spip-cite",
    label: "SPIP - Cite plugin"
  },
  {
    value: "sports-health",
    label: "Sports Health"
  },
  {
    value: "springer-basic-author-date-no-et-al-with-issue",
    label: 'Springer - Basic (author-date, no "et al.", with issue numbers)'
  },
  {
    value: "springer-basic-author-date-no-et-al",
    label: 'Springer - Basic (author-date, no "et al.")'
  },
  {
    value: "springer-basic-author-date",
    label: "Springer - Basic (author-date)"
  },
  {
    value: "springer-basic-brackets-no-et-al-alphabetical",
    label: 'Springer - Basic (numeric, brackets, no "et al.", alphabetical)'
  },
  {
    value: "springer-basic-brackets-no-et-al",
    label: 'Springer - Basic (numeric, brackets, no "et al.")'
  },
  {
    value: "springer-basic-brackets",
    label: "Springer - Basic (numeric, brackets)"
  },
  {
    value: "springer-basic-note",
    label: "Springer - Basic (note)"
  },
  {
    value: "springer-fachzeitschriften-medizin-psychologie",
    label: "Springer - Fachzeitschriften Medizin Psychologie (Deutsch)"
  },
  {
    value: "springer-humanities-author-date",
    label: "Springer - Humanities (author-date)"
  },
  {
    value: "springer-humanities-brackets",
    label: "Springer - Humanities (numeric, brackets)"
  },
  {
    value: "springer-imis-series-migrationsgesellschaften",
    label: "Springer - IMIS Series Migrationsgesellschaften"
  },
  {
    value: "springer-lecture-notes-in-computer-science-alphabetical",
    label: "Springer - Lecture Notes in Computer Science (sorted alphabetically)"
  },
  {
    value: "springer-lecture-notes-in-computer-science",
    label: "Springer - Lecture Notes in Computer Science"
  },
  {
    value: "springer-mathphys-author-date",
    label: "Springer - MathPhys (author-date)"
  },
  {
    value: "springer-mathphys-brackets",
    label: "Springer - MathPhys (numeric, brackets)"
  },
  {
    value: "springer-physics-author-date",
    label: "Springer - Physics (author-date)"
  },
  {
    value: "springer-physics-brackets",
    label: "Springer - Physics (numeric, brackets)"
  },
  {
    value: "springer-socpsych-author-date",
    label: "Springer - SocPsych (author-date)"
  },
  {
    value: "springer-socpsych-brackets",
    label: "Springer - SocPsych (numeric, brackets)"
  },
  {
    value: "springer-vancouver-author-date",
    label: "Springer - Vancouver (author-date)"
  },
  {
    value: "springer-vancouver-brackets",
    label: "Springer - Vancouver (brackets)"
  },
  {
    value: "springer-vancouver",
    label: "Springer - Vancouver"
  },
  {
    value: "springer-vs-author-date",
    label: "Springer VS (author-date, Deutsch)"
  },
  {
    value: "springerprotocols",
    label: "SpringerProtocols"
  },
  {
    value: "st-patricks-college",
    label: "St Patrick's College"
  },
  {
    value: "statistika-statistics-and-economy-journal",
    label: "Statistika: Statistics and Economy Journal"
  },
  {
    value: "stavebni-obzor",
    label: "Stavebn\xED obzor (\u010Ce\u0161tina)"
  },
  {
    value: "steel-research-international",
    label: "Steel Research International"
  },
  {
    value: "steinbeis-hochschule-school-of-management-and-innovation",
    label: "Steinbeis-Hochschule - School of Management & Innovation (Deutsch)"
  },
  {
    value: "stellenbosch-law-review",
    label: "Stellenbosch Law Review"
  },
  {
    value: "stem-cells",
    label: "Stem Cells"
  },
  {
    value: "strategic-design-research-journal",
    label: "Strategic Design Research Journal"
  },
  {
    value: "strategic-entrepreneurship-journal",
    label: "Strategic Entrepreneurship Journal"
  },
  {
    value: "strategic-management-journal",
    label: "Strategic Management Journal"
  },
  {
    value: "stroke",
    label: "Stroke"
  },
  {
    value: "structural-control-and-health-monitoring",
    label: "Structural Control and Health Monitoring"
  },
  {
    value: "studi-e-materiali-di-storia-delle-religioni",
    label: "Studi e materiali di storia delle religioni (Italiano)"
  },
  {
    value: "studi-slavistici-rivista-dellassociazione-italiana-degli-slavisti",
    label: "Studi Slavistici Rivista dell\u2019Associazione Italiana degli Slavisti"
  },
  {
    value: "studia-bas",
    label: "Studia BAS (Polski)"
  },
  {
    value: "studies-in-the-history-of-gardens-and-designed-landscapes",
    label: "Studies in the History of Gardens & Designed Landscapes"
  },
  {
    value: "studii-teologice",
    label: "Studii Teologice"
  },
  {
    value: "stuttgart-media-university",
    label: "Hochschule der Medien Stuttgart (Deutsch)"
  },
  {
    value: "style-manual-australian-government-note",
    label: "Style Manual - Australian Government (note)"
  },
  {
    value: "style-manual-australian-government",
    label: "Style Manual - Australian Government (author-date)"
  },
  {
    value: "style-manual-for-authors-editors-and-printers-6th-edition-snooks-co",
    label: "Style manual for authors, editors and printers 6th edition (Snooks & Co.) (author-date)"
  },
  {
    value: "suburban-zeitschrift-fur-kritische-stadtforschung",
    label: "sub\\urban - Zeitschrift f\xFCr kritische Stadtforschung (Deutsch)"
  },
  {
    value: "sunway-college-johor-bahru",
    label: "Sunway College Johor Bahru - Harvard"
  },
  {
    value: "surgical-clinics-of-north-america",
    label: "Surgical Clinics of North America"
  },
  {
    value: "surgical-neurology-international",
    label: "Surgical Neurology International"
  },
  {
    value: "surgical-pathology-clinics",
    label: "Surgical Pathology Clinics"
  },
  {
    value: "svensk-exegetisk-arsbok",
    label: "Svensk exegetisk \xE5rsbok (full note)"
  },
  {
    value: "swedish-legal",
    label: "Swedish Legal (Svenska)"
  },
  {
    value: "swiss-political-science-review",
    label: "Swiss Political Science Review"
  },
  {
    value: "sylwan",
    label: "Sylwan (Polski)"
  },
  {
    value: "synthesis",
    label: "Synthesis"
  },
  {
    value: "system-dynamics-review",
    label: "System Dynamics Review"
  },
  {
    value: "systematic-and-applied-microbiology",
    label: "Systematic and Applied Microbiology"
  },
  {
    value: "systematic-biology",
    label: "Systematic Biology"
  },
  {
    value: "szociologiai-szemle",
    label: "Szociol\xF3giai Szemle (Magyar)"
  },
  {
    value: "tabula",
    label: "T\xE1bula (Espa\xF1ol)"
  },
  {
    value: "tagungsberichte-der-historischen-kommission-fur-ost-und-westpreussische-landesforschung",
    label: "Tagungsberichte der Historischen Kommission f\xFCr ost- und westpreu\xDFische Landesforschung (Deutsch)"
  },
  {
    value: "tatup-zeitschrift-fur-technikfolgenabschatzung-in-theorie-und-praxis",
    label: "TATuP - Zeitschrift f\xFCr Technikfolgenabsch\xE4tzung in Theorie und Praxis"
  },
  {
    value: "taxon",
    label: "Taxon"
  },
  {
    value: "taylor-and-francis-acs",
    label: "Taylor & Francis - American Chemical Society"
  },
  {
    value: "taylor-and-francis-chicago-author-date",
    label: "Taylor & Francis - Chicago Manual of Style (author-date)"
  },
  {
    value: "taylor-and-francis-chicago-f",
    label: "Taylor & Francis - Chicago F"
  },
  {
    value: "taylor-and-francis-council-of-science-editors-author-date",
    label: "Taylor & Francis - Council of Science Editors (author-date)"
  },
  {
    value: "taylor-and-francis-council-of-science-editors-numeric",
    label: "Taylor & Francis - Council of Science Editors (numeric)"
  },
  {
    value: "taylor-and-francis-harvard-x",
    label: "Taylor & Francis - Harvard X"
  },
  {
    value: "taylor-and-francis-national-library-of-medicine",
    label: "Taylor & Francis - National Library of Medicine"
  },
  {
    value: "taylor-and-francis-numeric-q",
    label: "Taylor & Francis - Numeric Q"
  },
  {
    value: "taylor-and-francis-vancouver-national-library-of-medicine",
    label: "Taylor & Francis - Vancouver/National Library of Medicine"
  },
  {
    value: "techniques-et-culture",
    label: "Techniques&Culture (Fran\xE7ais)"
  },
  {
    value: "technische-universitat-dortmund-ag-virtual-machining",
    label: "Technische Universit\xE4t Dortmund - AG Virtual Machining (Deutsch)"
  },
  {
    value: "technische-universitat-dresden-betriebswirtschaftslehre-logistik-author-date",
    label: "Technische Universit\xE4t Dresden - Betriebswirtschaftslehre/Logistik (author-date)"
  },
  {
    value: "technische-universitat-dresden-betriebswirtschaftslehre-marketing",
    label: "Technische Universit\xE4t Dresden - Betriebswirtschaftslehre/Marketing (author-date)"
  },
  {
    value: "technische-universitat-dresden-betriebswirtschaftslehre-rechnungswesen-controlling",
    label: "Technische Universit\xE4t Dresden - Betriebswirtschaftslehre/Rechnungswesen/Controlling (Deutsch)"
  },
  {
    value: "technische-universitat-dresden-erziehungswissenschaften-author-date",
    label: "Technische Universit\xE4t Dresden - Erziehungswissenschaften (author-date)"
  },
  {
    value: "technische-universitat-dresden-finanzwirtschaft-und-finanzdienstleistungen-author-date-with-short-titles",
    label: "Technische Universit\xE4t Dresden - Finanzwirtschaft und Finanzdienstleistungen (author-date, with short titles)"
  },
  {
    value: "technische-universitat-dresden-finanzwirtschaft-und-finanzdienstleistungen-author-date",
    label: "Technische Universit\xE4t Dresden - Finanzwirtschaft und Finanzdienstleistungen (author-date)"
  },
  {
    value: "technische-universitat-dresden-finanzwirtschaft-und-finanzdienstleistungen-note",
    label: "Technische Universit\xE4t Dresden - Finanzwirtschaft und Finanzdienstleistungen (note)"
  },
  {
    value: "technische-universitat-dresden-forstwissenschaft",
    label: "Technische Universit\xE4t Dresden - Forstwissenschaft (author-date, Deutsch)"
  },
  {
    value: "technische-universitat-dresden-historische-musikwissenschaft-note",
    label: "Technische Universit\xE4t Dresden - Historische Musikwissenschaft (note, Deutsch)"
  },
  {
    value: "technische-universitat-dresden-kunstgeschichte-note",
    label: "Technische Universit\xE4t Dresden - Kunstgeschichte (note, Deutsch)"
  },
  {
    value: "technische-universitat-dresden-linguistik",
    label: "Technische Universit\xE4t Dresden - Linguistik (Deutsch)"
  },
  {
    value: "technische-universitat-dresden-medienwissenschaft-und-neuere-deutsche-literatur-note",
    label: "Technische Universit\xE4t Dresden - Medienwissenschaft und Neuere Deutsche Literatur (note, Deutsch)"
  },
  {
    value: "technische-universitat-dresden-medizin",
    label: "Technische Universit\xE4t Dresden - Medizin"
  },
  {
    value: "technische-universitat-dresden-wirtschaftswissenschaften",
    label: "Technische Universit\xE4t Dresden - Wirtschaftswissenschaften (Deutsch)"
  },
  {
    value: "technische-universitat-munchen-controlling",
    label: "Technische Universit\xE4t M\xFCnchen - Controlling (Deutsch)"
  },
  {
    value: "technische-universitat-munchen-unternehmensfuhrung",
    label: "Technische Universit\xE4t M\xFCnchen - Unternehmensf\xFChrung (Deutsch)"
  },
  {
    value: "technische-universitat-wien",
    label: "Technische Universit\xE4t Wien (dissertation) (Deutsch)"
  },
  {
    value: "teologia-catalunya",
    label: "Teologia Catalunya"
  },
  {
    value: "termedia-neuropsychiatria-i-neuropsychologia-neuropsychiatry-and-neuropsychology",
    label: "Termedia Neuropsychiatria i Neuropsychologia/Neuropsychiatry and Neuropsychology"
  },
  {
    value: "terra-nova",
    label: "Terra Nova"
  },
  {
    value: "tetrahedron-letters",
    label: "Tetrahedron Letters"
  },
  {
    value: "textual-cultures",
    label: "Textual Cultures"
  },
  {
    value: "textual-practice",
    label: "Textual Practice"
  },
  {
    value: "tgm-wien-diplom",
    label: "TGM Wien Diplomarbeit (Deutsch)"
  },
  {
    value: "tgm-wien-diplomarbeit-onorm",
    label: "TGM Wien Diplomarbeit \xD6NORM (Deutsch - \xD6sterreich)"
  },
  {
    value: "the-accounting-review",
    label: "The Accounting Review"
  },
  {
    value: "the-american-journal-of-bioethics",
    label: "The American Journal of Bioethics"
  },
  {
    value: "the-american-journal-of-cardiology",
    label: "The American Journal of Cardiology"
  },
  {
    value: "the-american-journal-of-dermatopathology",
    label: "The American Journal of Dermatopathology"
  },
  {
    value: "the-american-journal-of-gastroenterology",
    label: "The American Journal of Gastroenterology"
  },
  {
    value: "the-american-journal-of-geriatric-psychiatry",
    label: "The American Journal of Geriatric Psychiatry"
  },
  {
    value: "the-american-journal-of-human-genetics",
    label: "The American Journal of Human Genetics"
  },
  {
    value: "the-american-journal-of-pathology",
    label: "The American Journal of Pathology"
  },
  {
    value: "the-american-journal-of-psychiatry",
    label: "The American Journal of Psychiatry"
  },
  {
    value: "the-american-journal-of-tropical-medicine-and-hygiene",
    label: "The American Journal of Tropical Medicine and Hygiene"
  },
  {
    value: "the-american-midland-naturalist",
    label: "The American Midland Naturalist"
  },
  {
    value: "the-american-naturalist",
    label: "The American Naturalist"
  },
  {
    value: "the-angle-orthodontist",
    label: "The Angle Orthodontist"
  },
  {
    value: "the-astrophysical-journal",
    label: "The Astrophysical Journal"
  },
  {
    value: "the-auk",
    label: "The Auk"
  },
  {
    value: "the-australian-journal-of-agricultural-and-resource-economics",
    label: "The Australian Journal of Agricultural and Resource Economics"
  },
  {
    value: "the-biological-bulletin",
    label: "The Biological Bulletin"
  },
  {
    value: "the-bone-and-joint-journal",
    label: "The Bone & Joint Journal"
  },
  {
    value: "the-botanical-review",
    label: "The Botanical Review"
  },
  {
    value: "the-bovine-practitioner",
    label: "The Bovine Practitioner"
  },
  {
    value: "the-british-journal-for-the-philosophy-of-science",
    label: "The British Journal for the Philosophy of Science"
  },
  {
    value: "the-british-journal-of-cardiology",
    label: "The British Journal of Cardiology"
  },
  {
    value: "the-british-journal-of-criminology",
    label: "The British Journal of Criminology"
  },
  {
    value: "the-british-journal-of-psychiatry",
    label: "The British Journal of Psychiatry"
  },
  {
    value: "the-british-journal-of-sociology",
    label: "The British Journal of Sociology"
  },
  {
    value: "the-canadian-geographer",
    label: "The Canadian Geographer (Le G\xE9ographe canadien)"
  },
  {
    value: "the-canadian-journal-of-chemical-engineering",
    label: "The Canadian Journal of Chemical Engineering"
  },
  {
    value: "the-canadian-journal-of-psychiatry",
    label: "The Canadian Journal of Psychiatry"
  },
  {
    value: "the-cancer-journal",
    label: "The Cancer Journal"
  },
  {
    value: "the-chemical-society-of-japan",
    label: "The Chemical Society of Japan"
  },
  {
    value: "the-chinese-journal-of-international-politics",
    label: "The Chinese Journal of International Politics"
  },
  {
    value: "the-company-of-biologists",
    label: "The Company of Biologists"
  },
  {
    value: "the-design-journal",
    label: "The Design Journal"
  },
  {
    value: "the-economic-history-review",
    label: "The Economic History Review"
  },
  {
    value: "the-european-research-journal",
    label: "The European Research Journal"
  },
  {
    value: "the-faseb-journal",
    label: "The FASEB Journal"
  },
  {
    value: "the-febs-journal",
    label: "The FEBS Journal"
  },
  {
    value: "the-geological-society-of-america",
    label: "The Geological Society of America"
  },
  {
    value: "the-geological-society-of-london",
    label: "The Geological Society of London"
  },
  {
    value: "the-hastings-center-report",
    label: "The Hastings Center Report"
  },
  {
    value: "the-historical-journal",
    label: "The Historical Journal"
  },
  {
    value: "the-holocene",
    label: "The Holocene"
  },
  {
    value: "the-horticulture-journal",
    label: "The Horticulture Journal"
  },
  {
    value: "the-institute-of-electronics-information-and-communication-engineers",
    label: "The Institute of Electronics, Information and Communication Engineers (\u96FB\u5B50\u60C5\u5831\u901A\u4FE1\u5B66\u4F1A)"
  },
  {
    value: "the-institution-of-engineering-and-technology",
    label: "The Institution of Engineering and Technology"
  },
  {
    value: "the-international-journal-of-developmental-biology",
    label: "The International Journal of Developmental Biology"
  },
  {
    value: "the-international-journal-of-psychoanalysis",
    label: "The International Journal of Psychoanalysis"
  },
  {
    value: "the-international-journal-of-tuberculosis-and-lung-disease",
    label: "The International Journal of Tuberculosis and Lung Disease"
  },
  {
    value: "the-isme-journal",
    label: "The ISME Journal"
  },
  {
    value: "the-journal-of-adhesive-dentistry",
    label: "The Journal of Adhesive Dentistry"
  },
  {
    value: "the-journal-of-agricultural-science",
    label: "The Journal of Agricultural Science"
  },
  {
    value: "the-journal-of-clinical-ethics",
    label: "The Journal of Clinical Ethics"
  },
  {
    value: "the-journal-of-clinical-investigation",
    label: "The Journal of Clinical Investigation"
  },
  {
    value: "the-journal-of-comparative-law",
    label: "The Journal of Comparative Law"
  },
  {
    value: "the-journal-of-comparative-neurology",
    label: "The Journal of Comparative Neurology"
  },
  {
    value: "the-journal-of-egyptian-archaeology",
    label: "The Journal of Egyptian Archaeology"
  },
  {
    value: "the-journal-of-eukaryotic-microbiology",
    label: "The Journal of Eukaryotic Microbiology"
  },
  {
    value: "the-journal-of-foot-and-ankle-surgery",
    label: "The Journal of Foot & Ankle Surgery"
  },
  {
    value: "the-journal-of-hand-surgery-asian-pacific-volume",
    label: "The Journal of Hand Surgery Asian-Pacific Volume"
  },
  {
    value: "the-journal-of-hand-surgery-european-volume",
    label: "The Journal of Hand Surgery (European Volume)"
  },
  {
    value: "the-journal-of-hellenic-studies",
    label: "The Journal of Hellenic Studies"
  },
  {
    value: "the-journal-of-immunology",
    label: "The Journal of Immunology"
  },
  {
    value: "the-journal-of-infection-in-developing-countries",
    label: "The Journal of Infection in Developing Countries"
  },
  {
    value: "the-journal-of-juristic-papyrology",
    label: "The Journal of Juristic Papyrology"
  },
  {
    value: "the-journal-of-laryngology-and-otology",
    label: "The Journal of Laryngology & Otology"
  },
  {
    value: "the-journal-of-modern-history",
    label: "The Journal of Modern History"
  },
  {
    value: "the-journal-of-molecular-diagnostics",
    label: "The Journal of Molecular Diagnostics"
  },
  {
    value: "the-journal-of-nervous-and-mental-disease",
    label: "The Journal of Nervous and Mental Disease"
  },
  {
    value: "the-journal-of-neuropsychiatry-and-clinical-neurosciences",
    label: "The Journal of Neuropsychiatry and Clinical Neurosciences"
  },
  {
    value: "the-journal-of-neuroscience",
    label: "The Journal of Neuroscience"
  },
  {
    value: "the-journal-of-nuclear-medicine",
    label: "The Journal of Nuclear Medicine"
  },
  {
    value: "the-journal-of-nutrition-health-and-aging",
    label: "The Journal of Nutrition, Health & Aging"
  },
  {
    value: "the-journal-of-pain",
    label: "The Journal of Pain"
  },
  {
    value: "the-journal-of-parasitology",
    label: "The Journal of Parasitology"
  },
  {
    value: "the-journal-of-pathology",
    label: "The Journal of Pathology"
  },
  {
    value: "the-journal-of-peasant-studies",
    label: "The Journal of Peasant Studies"
  },
  {
    value: "the-journal-of-physiology",
    label: "The Journal of Physiology"
  },
  {
    value: "the-journal-of-pure-and-applied-chemistry-research",
    label: "The Journal of Pure and Applied Chemistry Research"
  },
  {
    value: "the-journal-of-roman-studies",
    label: "The Journal of Roman Studies"
  },
  {
    value: "the-journal-of-the-acoustical-society-of-america-numeric",
    label: "The Journal of the Acoustical Society of America (numeric)"
  },
  {
    value: "the-journal-of-the-acoustical-society-of-america",
    label: "The Journal of the Acoustical Society of America (author-date)"
  },
  {
    value: "the-journal-of-the-torrey-botanical-society",
    label: "The Journal of the Torrey Botanical Society"
  },
  {
    value: "the-journal-of-transport-history",
    label: "The Journal of Transport History"
  },
  {
    value: "the-journal-of-trauma-and-acute-care-surgery",
    label: "The Journal of Trauma and Acute Care Surgery"
  },
  {
    value: "the-journal-of-urology",
    label: "The Journal of Urology"
  },
  {
    value: "the-journal-of-veterinary-medical-science",
    label: "The Journal of Veterinary Medical Science"
  },
  {
    value: "the-journal-of-wildlife-management",
    label: "The Journal of Wildlife Management"
  },
  {
    value: "the-journals-of-gerontology-series-a",
    label: "The Journals of Gerontology, Series A: Biological Sciences and Medical Sciences"
  },
  {
    value: "the-korean-journal-of-gastroenterology",
    label: "The Korean Journal of Gastroenterology"
  },
  {
    value: "the-korean-journal-of-internal-medicine",
    label: "The Korean Journal of Internal Medicine"
  },
  {
    value: "the-korean-journal-of-mycology",
    label: "The Korean Journal of Mycology"
  },
  {
    value: "the-lancet",
    label: "The Lancet"
  },
  {
    value: "the-lichenologist",
    label: "The Lichenologist"
  },
  {
    value: "the-national-medical-journal-of-india",
    label: "The National Medical Journal of India"
  },
  {
    value: "the-neuroscientist",
    label: "The Neuroscientist"
  },
  {
    value: "the-new-england-journal-of-medicine",
    label: "The New England Journal of Medicine"
  },
  {
    value: "the-oncologist",
    label: "The Oncologist"
  },
  {
    value: "the-open-university-a251",
    label: "The Open University - A251 - Arts Course"
  },
  {
    value: "the-open-university-harvard",
    label: "The Open University - Harvard"
  },
  {
    value: "the-open-university-m801",
    label: "The Open University - M801 - Research Project and Dissertation"
  },
  {
    value: "the-open-university-numeric-superscript",
    label: "The Open University (numeric, superscript)"
  },
  {
    value: "the-open-university-numeric",
    label: "The Open University (numeric)"
  },
  {
    value: "the-open-university-s390",
    label: "The Open University - S390"
  },
  {
    value: "the-optical-society",
    label: "The Optical Society"
  },
  {
    value: "the-pan-african-medical-journal",
    label: "The Pan African Medical Journal"
  },
  {
    value: "the-plant-cell",
    label: "The Plant Cell"
  },
  {
    value: "the-plant-genome",
    label: "The Plant Genome"
  },
  {
    value: "the-plant-journal",
    label: "The Plant Journal"
  },
  {
    value: "the-quarterly-journal-of-economics",
    label: "The Quarterly Journal of Economics"
  },
  {
    value: "the-review-of-financial-studies",
    label: "The Review of Financial Studies"
  },
  {
    value: "the-rockefeller-university-press",
    label: "The Rockefeller University Press"
  },
  {
    value: "the-saudi-journal-for-dental-research",
    label: "The Saudi Journal for Dental Research"
  },
  {
    value: "the-scandinavian-journal-of-clinical-and-laboratory-investigation",
    label: "The Scandinavian Journal of Clinical & Laboratory Investigation"
  },
  {
    value: "the-university-of-tokyo-law-review",
    label: "\u6771\u4EAC\u5927\u5B66\u6CD5\u79D1\u5927\u5B66\u9662\u30ED\u30FC\u30EC\u30D3\u30E5\u30FC (The University of Tokyo Law Review) (\u65E5\u672C\u8A9E)"
  },
  {
    value: "the-university-of-western-australia-harvard",
    label: "The University of Western Australia - Harvard"
  },
  {
    value: "the-university-of-winchester-harvard",
    label: "The University of Winchester - Harvard"
  },
  {
    value: "the-world-journal-of-biological-psychiatry",
    label: "The World Journal of Biological Psychiatry"
  },
  {
    value: "theologie-und-philosophie",
    label: "Theologie und Philosophie (Deutsch)"
  },
  {
    value: "theory-culture-and-society",
    label: "Theory, Culture & Society"
  },
  {
    value: "theranostics",
    label: "Theranostics"
  },
  {
    value: "thieme-german",
    label: "Thieme-German (Deutsch)"
  },
  {
    value: "thomson-reuters-legal-tax-and-accounting-australia",
    label: "Thomson Reuters - Legal, Tax & Accounting Australia"
  },
  {
    value: "thrombosis-and-haemostasis",
    label: "Thrombosis and Haemostasis"
  },
  {
    value: "tijdschrift-voor-economische-en-sociale-geografie",
    label: "Tijdschrift voor economische en sociale geografie"
  },
  {
    value: "tijdschrift-voor-geneeskunde",
    label: "Tijdschrift voor Geneeskunde en Gezondheidszorg (Nederlands)"
  },
  {
    value: "topoi-orient-occident-auteur-date",
    label: "Topoi Orient-Occident (auteur-date, Fran\xE7ais)"
  },
  {
    value: "topoi-orient-occident-classique",
    label: "Topoi Orient-Occident (classique, Fran\xE7ais)"
  },
  {
    value: "toxicological-sciences",
    label: "Toxicological Sciences"
  },
  {
    value: "trabajos-de-prehistoria",
    label: "Trabajos de Prehistoria (Espa\xF1ol)"
  },
  {
    value: "traces",
    label: "Trac\xE9s: Revue de Sciences Humaines (Fran\xE7ais)"
  },
  {
    value: "traffic-injury-prevention",
    label: "Traffic Injury Prevention"
  },
  {
    value: "traffic",
    label: "Traffic"
  },
  {
    value: "transactions-of-the-american-philological-association",
    label: "Transactions of the American Philological Association"
  },
  {
    value: "transactions-of-the-materials-research-society-of-japan",
    label: "Transactions of the Materials Research Society of Japan"
  },
  {
    value: "transboundary-and-emerging-diseases",
    label: "Transboundary and Emerging Diseases"
  },
  {
    value: "transnational-environmental-law",
    label: "Transnational Environmental Law"
  },
  {
    value: "transplantation",
    label: "Transplantation"
  },
  {
    value: "transport",
    label: "Transport"
  },
  {
    value: "transportation-research-record",
    label: "Transportation Research Record: Journal of the Transportation Research Board"
  },
  {
    value: "transposition",
    label: "Transposition. Musique et sciences sociales"
  },
  {
    value: "transversalites",
    label: "Transversalit\xE9s (Fran\xE7ais)"
  },
  {
    value: "tree-physiology",
    label: "Tree Physiology"
  },
  {
    value: "trends-in-glycoscience-and-glycotechnology",
    label: "Trends in Glycoscience and Glycotechnology"
  },
  {
    value: "trends-journals",
    label: "Trends journals"
  },
  {
    value: "triangle",
    label: "Triangle (Fran\xE7ais)"
  },
  {
    value: "trinity-college-dublin-zoology-botany-environmental-sciences-harvard",
    label: "Trinity College Dublin - Zoology Botany Environmental Sciences - Harvard"
  },
  {
    value: "tropical-animal-health-and-production",
    label: "Tropical Animal Health and Production"
  },
  {
    value: "tsaqafah",
    label: "Tsaqafah"
  },
  {
    value: "turabian-author-date",
    label: "Turabian 9th edition (author-date)"
  },
  {
    value: "turabian-fullnote-bibliography-no-ibid",
    label: "Turabian 8th edition (full note, no ibid)"
  },
  {
    value: "turabian-fullnote-bibliography",
    label: "Turabian 8th edition (full note)"
  },
  {
    value: "turkiye-bilimsel-ve-teknolojik-arastirma-kurumu",
    label: "T\xDCB\u0130TAK (T\xFCrkiye Bilimsel ve Teknolojik Ara\u015Ft\u0131rma Kurumu) (T\xFCrk\xE7e)"
  },
  {
    value: "twentieth-century-music",
    label: "Twentieth-Century Music"
  },
  {
    value: "tyndale-bulletin",
    label: "Tyndale Bulletin"
  },
  {
    value: "u-schylku-starozytnosci",
    label: "U Schy\u0142ku Staro\u017Cytno\u015Bci (Polski)"
  },
  {
    value: "ucl-institute-of-education-harvard",
    label: "UCL Institute of Education - Harvard"
  },
  {
    value: "ucl-university-college-apa",
    label: "UCL University College - APA (Dansk)"
  },
  {
    value: "ucl-university-college-harvard",
    label: "UCL University College - Harvard (Dansk)"
  },
  {
    value: "ucl-university-college-vancouver",
    label: "UCL University College - Vancouver (English)"
  },
  {
    value: "uclouvain-centre-charles-de-visscher-pour-le-droit-international-et-europeen",
    label: "UCLouvain - Centre Charles De Visscher pour le droit international et europ\xE9en (French)"
  },
  {
    value: "ugeskrift-for-laeger",
    label: "Ugeskrift for L\xE6ger (Dansk)"
  },
  {
    value: "ultrasound-in-medicine-and-biology",
    label: "Ultrasound in Medicine and Biology"
  },
  {
    value: "ulua-revista-de-historia-sociedad-y-cultura",
    label: "Ul\xFAa. Revista de Historia, Sociedad y Cultura"
  },
  {
    value: "uludag-universitesi-sosyal-bilimler-enstitusu-author-date",
    label: "Uluda\u011F \xDCniversitesi - Sosyal Bilimler Enstit\xFCs\xFC (author-date, T\xFCrk\xE7e)"
  },
  {
    value: "uludag-universitesi-sosyal-bilimler-enstitusu-full-note-with-ibid",
    label: "Uluda\u011F \xDCniversitesi - Sosyal Bilimler Enstit\xFCs\xFC (full note, with Ibid., T\xFCrk\xE7e)"
  },
  {
    value: "uludag-universitesi-sosyal-bilimler-enstitusu-full-note",
    label: "Uluda\u011F \xDCniversitesi - Sosyal Bilimler Enstit\xFCs\xFC (full note, T\xFCrk\xE7e)"
  },
  {
    value: "uludag-universitesi-sosyal-bilimler-enstitusu-ilahiyat-fakultesi-full-note-with-ibid",
    label: "Uluda\u011F \xDCniversitesi - Sosyal Bilimler Enstit\xFCs\xFC - \u0130lahiyat Fak\xFCltesi (full note, with Ibid., T\xFCrk\xE7e)"
  },
  {
    value: "uludag-universitesi-sosyal-bilimler-enstitusu-ilahiyat-fakultesi-full-note",
    label: "Uluda\u011F \xDCniversitesi - Sosyal Bilimler Enstit\xFCs\xFC - \u0130lahiyat Fak\xFCltesi (full note, T\xFCrk\xE7e)"
  },
  {
    value: "unesco-international-institute-for-educational-planning",
    label: "UNESCO International Institute for Educational Planning"
  },
  {
    value: "unified-style-sheet-for-linguistics-de-gruyter-literature",
    label: "Unified Stylesheet for Linguistics (de Gruyter Literature)"
  },
  {
    value: "unified-style-sheet-for-linguistics",
    label: "Unified style sheet for linguistics"
  },
  {
    value: "united-nations-conference-on-trade-and-development",
    label: "United Nations Conference on Trade and Development"
  },
  {
    value: "united-nations-development-programme-icca-legal-review",
    label: "United Nations Development Programme ICCA Legal Review"
  },
  {
    value: "united-nations-framework-convention-on-climate-change",
    label: "United Nations Framework Convention on Climate Change"
  },
  {
    value: "united-states-international-trade-commission",
    label: "United States International Trade Commission"
  },
  {
    value: "universidad-autonoma-cidudad-juarez-estilo-latino-humanistico",
    label: "Universidad Aut\xF3noma de Ciudad Ju\xE1rez - Estilo Latino Human\xEDstico"
  },
  {
    value: "universidad-de-leon-harvard",
    label: "Universidad de Le\xF3n (Espa\xF1a) - Harvard"
  },
  {
    value: "universidad-evangelica-del-paraguay",
    label: "Universidad Evang\xE9lica del Paraguay (Espa\xF1ol)"
  },
  {
    value: "universidade-de-sao-paulo-escola-de-comunicacoes-e-artes-abnt",
    label: "Universidade de S\xE3o Paulo - Escola de Comunica\xE7\xF5es e Artes - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-de-sao-paulo-instituto-de-matematica-e-estatistica",
    label: "Universidade de S\xE3o Paulo - Instituto de Matem\xE1tica e Estat\xEDstica"
  },
  {
    value: "universidade-do-estado-do-rio-de-janeiro-abnt",
    label: "Universidade do Estado do Rio de Janeiro - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-do-porto-faculdade-de-engenharia-chicago-pt",
    label: "Universidade do Porto - Faculdade de Engenharia - Chicago Manual of Style 17th (author-date) (Portugu\xEAs - Portugal)"
  },
  {
    value: "universidade-do-porto-faculdade-de-engenharia-chicago",
    label: "Universidade do Porto - Faculdade de Engenharia - Chicago Manual of Style 17th (author-date)"
  },
  {
    value: "universidade-do-porto-faculdade-de-psicologia-e-de-ciencias-da-educacao",
    label: "Universidade do Porto - Faculdade de Psicologia e de Ci\xEAncias da Educa\xE7\xE3o - APA"
  },
  {
    value: "universidade-estadual-de-alagoas-abnt",
    label: "Universidade Estadual de Alagoas - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-estadual-do-oeste-do-parana-programa-institucional-de-bolsas-de-iniciacao-cientifica",
    label: "Universidade Estadual do Oeste do Paran\xE1 - Programa Institucional de Bolsas de Inicia\xE7\xE3o Cient\xEDfica (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-estadual-paulista-campus-de-dracena-abnt",
    label: "Universidade Estadual Paulista - Campus de Dracena - ABNT (autoria abreviada) (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-estadual-paulista-faculdade-de-engenharia-de-guaratingueta-abnt",
    label: "Universidade Estadual Paulista - Faculdade de Engenharia de Guaratingueta - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-federal-de-juiz-de-fora",
    label: "Universidade Federal de Juiz de Fora (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-federal-de-pernambuco-abnt",
    label: "Universidade Federal de Pernambuco - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-federal-de-sergipe-departamento-de-engenharia-de-producao-abnt",
    label: "Universidade Federal de Sergipe - Departamento de Engenharia de Produ\xE7\xE3o - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-federal-do-espirito-santo-abnt-initials",
    label: "Universidade Federal do Esp\xEDrito Santo - ABNT (autoria abreviada) (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-federal-do-espirito-santo-abnt",
    label: "Universidade Federal do Esp\xEDrito Santo - ABNT (autoria completa) (Portugu\xEAs - Brasil)"
  },
  {
    value: "universidade-federal-do-rio-de-janeiro-instituto-alberto-luiz-coimbra-de-pos-graduacao-e-pesquisa-de-engenharia-abnt",
    label: "Universidade Federal do Rio de Janeiro - Instituto Alberto Luiz Coimbra de P\xF3s-Gradua\xE7\xE3o e Pesquisa de Engenharia - ABNT (Portugu\xEAs - Brasil)"
  },
  {
    value: "universita-cattolica-del-sacro-cuore",
    label: "Universit\xE0 Cattolica del Sacro Cuore (note, Italiano)"
  },
  {
    value: "universita-di-bologna-lettere",
    label: "University of Bologna - Liberal Arts College (Universit\xE0 di Bologna - Facolt\xE0 di Lettere e Filosofia) (Italiano)"
  },
  {
    value: "universita-pontificia-salesiana-it",
    label: "Universit\xE0 Pontificia Salesiana (Italiano)"
  },
  {
    value: "universita-pontificia-salesiana",
    label: "Universit\xE0 Pontificia Salesiana"
  },
  {
    value: "universitas-gadjah-mada-departemen-sejarah",
    label: "Universitas Gadjah Mada - Departemen Sejarah (Bahasa Indonesia)"
  },
  {
    value: "universitas-negeri-semarang-fakultas-matematika-dan-ilmu-pengetahuan-alam",
    label: "Universitas Negeri Semarang - Fakultas Matematika dan Ilmu Pengetahuan Alam (Bahasa Indonesia)"
  },
  {
    value: "universitas-negeri-yogyakarta-program-pascasarjana",
    label: "Universitas Negeri Yogyakarta - Program Pascasarjana (Bahasa Indonesia)"
  },
  {
    value: "universitat-basel-deutsche-sprachwissenschaft",
    label: "Universit\xE4t Basel - Deutsche Sprachwissenschaft"
  },
  {
    value: "universitat-basel-iberoromanistik",
    label: "Universit\xE4t Basel - Iberoromanistik (Espa\xF1ol)"
  },
  {
    value: "universitat-bern-institut-fur-musikwissenschaft-note",
    label: "Universit\xE4t Bern - Institut f\xFCr Musikwissenschaft (note, Deutsch)"
  },
  {
    value: "universitat-bern-institut-fur-sozialanthropologie",
    label: "Universit\xE4t Bern - Institut f\xFCr Sozialanthropologie (Deutsch - Schweiz)"
  },
  {
    value: "universitat-bremen-institut-fur-politikwissenschaft",
    label: "Universit\xE4t Bremen - Institut f\xFCr Politikwissenschaft (Deutsch)"
  },
  {
    value: "universitat-bremen-lehrstuhl-fur-innovatives-markenmanagement",
    label: "Universit\xE4t Bremen - Lehrstuhl f\xFCr innovatives Markenmanagement (Deutsch)"
  },
  {
    value: "universitat-freiburg-geschichte",
    label: "Albert-Ludwigs-Universit\xE4t Freiburg - Geschichte (Deutsch)"
  },
  {
    value: "universitat-heidelberg-historisches-seminar",
    label: "Universit\xE4t Heidelberg - Historisches Seminar (Deutsch)"
  },
  {
    value: "universitat-heidelberg-medizinische-fakultat-mannheim-numeric",
    label: "Universit\xE4t Heidelberg - Medizinische Fakult\xE4t Mannheim (numerisch, Deutsch)"
  },
  {
    value: "universitat-mainz-geographisches-institut",
    label: "Universit\xE4t Mainz - Geographisches Institut (Deutsch)"
  },
  {
    value: "universitat-mannheim-germanistische-linguistik",
    label: "Universit\xE4t Mannheim - Germanistische Linguistik (Deutsch)"
  },
  {
    value: "universitat-stuttgart-planung-und-partizipation",
    label: "Universit\xE4t Stuttgart - Planung und Partizipation (Deutsch)"
  },
  {
    value: "universitat-wien-institut-fur-geschichte",
    label: "Universit\xE4t Wien - Institut f\xFCr Geschichte"
  },
  {
    value: "universitat-zu-koln-seminar-fur-abwl-und-finanzierungslehre",
    label: "Universit\xE4t zu K\xF6ln - Seminar f\xFCr ABWL und Finanzierungslehre (Deutsch)"
  },
  {
    value: "universitatsmedizin-gottingen",
    label: "Universit\xE4tsmedizin G\xF6ttingen (Deutsch)"
  },
  {
    value: "universite-catholique-de-louvain-histoire",
    label: "Universit\xE9 Catholique de Louvain - Histoire (Fran\xE7ais)"
  },
  {
    value: "universite-cheikh-anta-diop-faculte-de-medecine-de-pharmacie-et-dodontologie",
    label: "Universit\xE9 Cheikh Anta Diop - Facult\xE9 de M\xE9decine de Pharmacie et d'Odontologie (Fran\xE7ais)"
  },
  {
    value: "universite-de-bordeaux-ecole-doctorale-de-droit",
    label: "Universit\xE9 de Bordeaux - \xC9cole doctorale de droit (Fran\xE7ais)"
  },
  {
    value: "universite-de-geneve-departement-de-langue-et-de-litterature-francaises-modernes",
    label: "Universit\xE9 de Gen\xE8ve - D\xE9partement de langue et de litt\xE9rature fran\xE7aises modernes (Fran\xE7ais)"
  },
  {
    value: "universite-de-lausanne-histoire",
    label: "Universit\xE9 de Lausanne - Histoire (Fran\xE7ais)"
  },
  {
    value: "universite-de-liege-droit-par-categorie",
    label: "Universit\xE9 de Li\xE8ge - Droit (classement par cat\xE9gorie, Fran\xE7ais)"
  },
  {
    value: "universite-de-liege-droit",
    label: "Universit\xE9 de Li\xE8ge - Droit (Fran\xE7ais)"
  },
  {
    value: "universite-de-liege-histoire",
    label: "Universit\xE9 de Li\xE8ge - Histoire (Fran\xE7ais)"
  },
  {
    value: "universite-de-montreal-apa",
    label: "Universit\xE9 de Montr\xE9al - APA (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-de-montreal-faculte-de-musique",
    label: "Universit\xE9 de Montr\xE9al - Facult\xE9 de musique (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-de-picardie-jules-verne-ufr-de-medecine",
    label: "Universit\xE9 de Picardie Jules Verne (Amiens) - Th\xE8se de UFR de M\xE9decine"
  },
  {
    value: "universite-de-sherbrooke-departement-de-geomatique",
    label: "Universit\xE9 de Sherbrooke - D\xE9partement de g\xE9omatique (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-de-sherbrooke-faculte-d-education",
    label: "Universit\xE9 de Sherbrooke - Facult\xE9 d'\xE9ducation (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-de-sherbrooke-histoire",
    label: "Universit\xE9 de Sherbrooke - Histoire (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-du-quebec-a-montreal-departement-dhistoire",
    label: "Universit\xE9 du Qu\xE9bec \xE0 Montr\xE9al - D\xE9partement d\u2019histoire (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-du-quebec-a-montreal-etudes-litteraires-et-semiologie",
    label: "Universit\xE9 du Qu\xE9bec \xE0 Montr\xE9al - \xC9tudes litt\xE9raires et s\xE9miologie (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-du-quebec-a-montreal",
    label: "Universit\xE9 du Qu\xE9bec \xE0 Montr\xE9al - APA (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-laval-departement-des-sciences-historiques",
    label: "Universit\xE9 Laval - D\xE9partement des sciences historiques (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-laval-departement-dinformation-et-de-communication",
    label: "Universit\xE9 Laval - D\xE9partement d'information et de communication (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-laval-faculte-de-theologie-et-de-sciences-religieuses",
    label: "Universit\xE9 Laval - Facult\xE9 de th\xE9ologie et de sciences religieuses (Fran\xE7ais - Canada)"
  },
  {
    value: "universite-libre-de-bruxelles-histoire",
    label: "Universit\xE9 libre de Bruxelles - Histoire (Fran\xE7ais)"
  },
  {
    value: "universite-nangui-abrogoua-sciences-de-la-nature-apa",
    label: "Universit\xE9 Nangui Abrogoua - Sciences de la Nature - APA (Fran\xE7ais)"
  },
  {
    value: "universiteit-utrecht-onderzoeksgids-geschiedenis",
    label: "Universiteit Utrecht - Onderzoeksgids Geschiedenis (Nederlands)"
  },
  {
    value: "universitetet-i-oslo-rettsvitenskap",
    label: "Universitetet i Oslo - Rettsvitenskap (Norsk - Bokm\xE5l)"
  },
  {
    value: "universiti-kebangsaan-malaysia",
    label: "Universiti Kebangsaan Malaysia (Malay)"
  },
  {
    value: "university-college-dublin-school-of-history-and-archives",
    label: "University College Dublin - School of History & Archives"
  },
  {
    value: "university-college-lillebaelt-apa",
    label: "University College Lilleb\xE6lt - APA (Dansk)"
  },
  {
    value: "university-for-the-creative-arts-figures",
    label: "University for the Creative Arts (figures and illustrations)"
  },
  {
    value: "university-of-aberdeen-school-of-education-harvard",
    label: "University of Aberdeen - School of Education - Harvard"
  },
  {
    value: "university-of-aleppo-faculty-of-medicine",
    label: "University of Aleppo - Faculty of Medicine"
  },
  {
    value: "university-of-auckland-history",
    label: "University of Auckland - History"
  },
  {
    value: "university-of-bradford-harvard",
    label: "University of Bradford - Harvard"
  },
  {
    value: "university-of-cambridge-faculty-of-history",
    label: "University of Cambridge - Faculty of History"
  },
  {
    value: "university-of-gothenburg-apa-7th-edition-swedish-legislations",
    label: "University of Gothenburg - APA 7th edition (Swedish legislations)"
  },
  {
    value: "university-of-gothenburg-apa-swedish-legislations",
    label: "University of Gothenburg - APA 6th edition (Swedish legislations)"
  },
  {
    value: "university-of-helsinki-faculty-of-theology",
    label: "Helsingin yliopisto - Teologinen tiedekunta (Suomi)"
  },
  {
    value: "university-of-lincoln-harvard",
    label: "University of Lincoln - Harvard"
  },
  {
    value: "university-of-new-england-australia-note",
    label: "University of New England, Australia (note)"
  },
  {
    value: "university-of-roehampton-harvard",
    label: "University of Roehampton - Harvard"
  },
  {
    value: "university-of-south-africa-harvard",
    label: "University of South Africa - Harvard"
  },
  {
    value: "university-of-south-australia-2017-harvard",
    label: "University of South Australia 2017 - Harvard"
  },
  {
    value: "university-of-south-australia-harvard-2011",
    label: "University of South Australia 2011 - Harvard"
  },
  {
    value: "university-of-south-australia-harvard-2013",
    label: "University of South Australia 2013 - Harvard"
  },
  {
    value: "university-of-south-wales-harvard",
    label: "University of South Wales - Harvard"
  },
  {
    value: "university-of-tasmania-simplified-author-date",
    label: "University of Tasmania - Simplified Author-date"
  },
  {
    value: "university-of-york-apa",
    label: "University of York - APA 6th edition"
  },
  {
    value: "university-of-york-chicago",
    label: "University of York - Chicago Manual of Style 16th edition"
  },
  {
    value: "university-of-york-harvard-archaeology",
    label: "University of York - Harvard - Archaeology"
  },
  {
    value: "university-of-york-harvard-environment",
    label: "University of York - Harvard - Environment"
  },
  {
    value: "university-of-york-harvard",
    label: "University of York - Harvard"
  },
  {
    value: "university-of-york-ieee",
    label: "University of York - IEEE"
  },
  {
    value: "university-of-york-mhra",
    label: "University of York - Modern Humanities Research Association 3rd edition"
  },
  {
    value: "university-of-york-mla",
    label: "University of York - Modern Language Association 8th edition"
  },
  {
    value: "university-of-york-oscola",
    label: "University of York - OSCOLA"
  },
  {
    value: "university-of-york-vancouver",
    label: "University of York - Vancouver"
  },
  {
    value: "university-of-zabol-fa",
    label: "University of Zabol (\u0641\u0627\u0631\u0633\u06CC)"
  },
  {
    value: "university-of-zabol",
    label: "University of Zabol (English)"
  },
  {
    value: "univerza-na-primorskem-fakulteta-za-vede-o-zdravju-apa",
    label: "Univerza na Primorskem - Fakulteta za vede o zdravju - APA (Sloven\u0161\u010Dina)"
  },
  {
    value: "uniwersytet-im-adama-mickiewicza-w-poznaniu-wydzial-anglistyki",
    label: "Uniwersytet im. Adama Mickiewicza w Poznaniu - Wydzia\u0142 Anglistyki (English)"
  },
  {
    value: "uniwersytet-kardynala-stefana-wyszynskiego-w-warszawie-autor-rok",
    label: "Uniwersytet Kardyna\u0142a Stefana Wyszy\u0144skiego w Warszawie (autor-rok, Polski)"
  },
  {
    value: "uniwersytet-kardynala-stefana-wyszynskiego-w-warszawie-przypis",
    label: "Uniwersytet Kardyna\u0142a Stefana Wyszy\u0144skiego w Warszawie (przypis, Polski)"
  },
  {
    value: "uppsala-universitet-historia",
    label: "Uppsala universitet - Historia"
  },
  {
    value: "uppsala-universitet-institutionen-for-biologisk-grundutbildning",
    label: "Uppsala universitet, Institutionen f\xF6r biologisk grundutbildning"
  },
  {
    value: "urad-rs-za-makroekonomske-analize-in-razvoj",
    label: "Urad RS za makroekonomske analize in razvoj (Sloven\u0161\u010Dina)"
  },
  {
    value: "urban-geography",
    label: "Urban Geography"
  },
  {
    value: "urban-habitats",
    label: "Urban Habitats"
  },
  {
    value: "urban-studies",
    label: "Urban Studies"
  },
  {
    value: "urbani-izziv-en",
    label: "Urbani izziv (Urban Challenge) (English)"
  },
  {
    value: "urbani-izziv",
    label: "Urbani izziv (Urban Challenge) (Sloven\u0161\u010Dina)"
  },
  {
    value: "urological-science",
    label: "Urological Science"
  },
  {
    value: "us-geological-survey",
    label: "U.S. Geological Survey"
  },
  {
    value: "usda-forest-service-pacific-northwest-research-station",
    label: "USDA Forest Service - Pacific Northwest Research Station"
  },
  {
    value: "user-modeling-and-user-adapted-interaction",
    label: "User Modeling and User-Adapted Interaction"
  },
  {
    value: "uspekhi-gerontologii",
    label: "\u0423\u0441\u043F\u0435\u0445\u0438 \u0433\u0435\u0440\u043E\u043D\u0442\u043E\u043B\u043E\u0433\u0438\u0438 (\u0420\u0443\u0301\u0441\u0441\u043A\u0438\u0439)"
  },
  {
    value: "utah-geological-survey",
    label: "Utah Geological Survey"
  },
  {
    value: "vancouver-author-date",
    label: "Vancouver (author-date)"
  },
  {
    value: "vancouver-brackets-no-et-al",
    label: 'Vancouver (brackets, no "et al.")'
  },
  {
    value: "vancouver-brackets-only-year-no-issue",
    label: "Vancouver (brackets, only year in date, no issue numbers)"
  },
  {
    value: "vancouver-brackets",
    label: "Vancouver (brackets)"
  },
  {
    value: "vancouver-fr-ca",
    label: "Vancouver (Fran\xE7ais - Canada)"
  },
  {
    value: "vancouver-imperial-college-london",
    label: "Imperial College London - Vancouver"
  },
  {
    value: "vancouver-superscript-brackets-only-year",
    label: "Vancouver (superscript, brackets, only year in date)"
  },
  {
    value: "vancouver-superscript-only-year",
    label: "Vancouver (superscript, only year in date, no issue numbers)"
  },
  {
    value: "vancouver-superscript",
    label: "Vancouver (superscript)"
  },
  {
    value: "vancouver",
    label: "Vancouver"
  },
  {
    value: "veterinaria-italiana",
    label: "Veterinaria Italiana"
  },
  {
    value: "veterinary-medicine-austria",
    label: "Veterinary Medicine Austria (Wiener Tier\xE4rztliche Monatsschrift)"
  },
  {
    value: "veterinary-microbiology",
    label: "Veterinary Microbiology"
  },
  {
    value: "veterinary-pathology",
    label: "Veterinary Pathology"
  },
  {
    value: "veterinary-radiology-and-ultrasound",
    label: "Veterinary Radiology & Ultrasound"
  },
  {
    value: "veterinary-record",
    label: "Veterinary Record"
  },
  {
    value: "victoria-university-harvard",
    label: "Victoria University - Harvard"
  },
  {
    value: "vienna-legal",
    label: "Vienna Legal"
  },
  {
    value: "vietnam-ministry-of-education-and-training-en",
    label: "Vietnam Ministry of Education and Training (English)"
  },
  {
    value: "vietnam-ministry-of-education-and-training-vi",
    label: "Vietnam Ministry of Education and Training (Ti\u1EBFng Vi\u1EC7t)"
  },
  {
    value: "vigiliae-christianae",
    label: "Vigiliae Christianae"
  },
  {
    value: "vilnius-gediminas-technical-university",
    label: "Vilnius Gediminas Technical University (Lietuvi\u0173 kalba)"
  },
  {
    value: "vingtieme-siecle",
    label: "Vingti\xE8me Si\xE8cle. Revue d'histoire (Fran\xE7ais)"
  },
  {
    value: "vita-latina-auteurs-anciens",
    label: "Vita Latina (auteurs anciens, Fran\xE7ais)"
  },
  {
    value: "vita-latina",
    label: "Vita Latina (Fran\xE7ais)"
  },
  {
    value: "vodohospodarske-technicko-ekonomicke-informace-en",
    label: "Vodohospod\xE1\u0159sk\xE9 technicko-ekonomick\xE9 informace (English)"
  },
  {
    value: "vodohospodarske-technicko-ekonomicke-informace",
    label: "Vodohospod\xE1\u0159sk\xE9 technicko-ekonomick\xE9 informace (\u010Ce\u0161tina)"
  },
  {
    value: "wader-study",
    label: "Wader Study"
  },
  {
    value: "water-alternatives",
    label: "Water Alternatives"
  },
  {
    value: "water-environment-research",
    label: "Water Environment Research"
  },
  {
    value: "water-sa",
    label: "Water SA"
  },
  {
    value: "water-science-and-technology",
    label: "Water Science & Technology"
  },
  {
    value: "waterbirds",
    label: "Waterbirds"
  },
  {
    value: "weed-research",
    label: "Weed Research"
  },
  {
    value: "weed-science-society-of-america",
    label: "Weed Science Society of America"
  },
  {
    value: "west-european-politics",
    label: "West European Politics"
  },
  {
    value: "western-journal-of-emergency-medicine",
    label: "Western Journal of Emergency Medicine"
  },
  {
    value: "westfalische-wilhelms-universitat-munster-medizinische-fakultat",
    label: "Westf\xE4lische Wilhelms-Universit\xE4t M\xFCnster - Medizinische Fakult\xE4t (Deutsch)"
  },
  {
    value: "wetlands",
    label: "Wetlands"
  },
  {
    value: "wheaton-college-phd-in-biblical-and-theological-studies",
    label: "Wheaton College - Ph.D. in Biblical and Theological Studies"
  },
  {
    value: "who-europe-harvard",
    label: "WHO Regional Office for Europe - Harvard"
  },
  {
    value: "who-europe-numeric",
    label: "WHO Regional Office for Europe (numeric)"
  },
  {
    value: "wiesbaden-business-school",
    label: "Wiesbaden Business School"
  },
  {
    value: "wikipedia-templates",
    label: "Wikipedia Templates"
  },
  {
    value: "wiley-vch-books",
    label: "Wiley-VCH books"
  },
  {
    value: "wireless-communications-and-mobile-computing",
    label: "Wireless Communications and Mobile Computing"
  },
  {
    value: "wirtschaftsuniversitat-wien-abteilung-fur-bildungswissenschaft",
    label: "Wirtschaftsuniversit\xE4t Wien - Abteilung f\xFCr Bildungswissenschaft (Deutsch - \xD6sterreich)"
  },
  {
    value: "wirtschaftsuniversitat-wien-author-date",
    label: "Wirtschaftsuniversit\xE4t Wien (author-date)"
  },
  {
    value: "wirtschaftsuniversitat-wien-handel-und-marketing",
    label: "Wirtschaftsuniversit\xE4t Wien - Handel und Marketing (Deutsch - \xD6sterreich)"
  },
  {
    value: "wirtschaftsuniversitat-wien-health-care-management",
    label: "Wirtschaftsuniversit\xE4t Wien - Health Care Management"
  },
  {
    value: "wirtschaftsuniversitat-wien-institut-fur-bwl-des-aussenhandels",
    label: "Wirtschaftsuniversit\xE4t Wien - Institut f\xFCr BWL des Au\xDFenhandels (Deutsch - \xD6sterreich)"
  },
  {
    value: "wirtschaftsuniversitat-wien-institut-fur-transportwirtschaft-und-logistik",
    label: "Wirtschaftsuniversit\xE4t Wien - Institut f\xFCr Transportwirtschaft und Logistik (Deutsch - \xD6sterreich)"
  },
  {
    value: "wirtschaftsuniversitat-wien-unternehmensrechnung-und-controlling",
    label: "Wirtschaftsuniversit\xE4t Wien - Unternehmensrechnung und Controlling"
  },
  {
    value: "wirtschaftsuniversitat-wien-wirtschaftspadagogik",
    label: "Wirtschaftsuniversit\xE4t Wien - Wirtschaftsp\xE4dagogik (Deutsch - \xD6sterreich)"
  },
  {
    value: "wissenschaftlicher-industrielogistik-dialog",
    label: "Wissenschaftlicher Industrielogistik-Dialog (Deutsch - \xD6sterreich)"
  },
  {
    value: "wolters-kluwerbrede-schrijfwijzer-author-date",
    label: "Wolters Kluwerbrede Schrijfwijzer (author-date, Nederlands)"
  },
  {
    value: "world-applied-sciences-journal",
    label: "World Applied Sciences Journal"
  },
  {
    value: "world-congress-on-engineering-asset-management",
    label: "World Congress on Engineering Asset Management 2010"
  },
  {
    value: "world-mycotoxin-journal",
    label: "World Mycotoxin Journal"
  },
  {
    value: "world-organisation-for-animal-health-scientific-and-technical-review",
    label: "World Organisation for Animal Health - Scientific and Technical Review"
  },
  {
    value: "world-politcs",
    label: "World Politics"
  },
  {
    value: "worlds-poultry-science-journal",
    label: "World's Poultry Science Journal"
  },
  {
    value: "worlds-veterinary-journal",
    label: "World's Veterinary Journal"
  },
  {
    value: "xenotransplantation",
    label: "Xenotransplantation"
  },
  {
    value: "yeast",
    label: "Yeast"
  },
  {
    value: "yozgat-bozok-universitesi-fen-bilimleri-enstitusu",
    label: "Yozgat Bozok \xDCniversitesi - Fen Bilimleri Enstit\xFCs\xFC (T\xFCrk\xE7e)"
  },
  {
    value: "zastosowania-komputerow-w-elektrotechnice",
    label: "Zastosowania Komputer\xF3w w Elektrotechnice"
  },
  {
    value: "zdfm-zeitschrift-fur-diversitatsforschung-und-management",
    label: "ZDfm \u2013 Zeitschrift f\xFCr Diversit\xE4tsforschung und -management (Deutsch - \xD6sterreich)"
  },
  {
    value: "zdravniski-vestnik",
    label: "Zdravni\u0161ki Vestnik (Slovenian Medical Journal)"
  },
  {
    value: "zeitgeschichte",
    label: "Zeitgeschichte (Deutsch)"
  },
  {
    value: "zeithistorische-forschungen",
    label: "Zeithistorische Forschungen/Studies in Contemporary History"
  },
  {
    value: "zeitschrift-fur-allgemeinmedizin",
    label: "Zeitschrift f\xFCr Allgemeinmedizin"
  },
  {
    value: "zeitschrift-fur-antikes-christentum",
    label: "Zeitschrift f\xFCr Antikes Christentum (Journal of Ancient Christianity) (English)"
  },
  {
    value: "zeitschrift-fur-deutsche-philologie",
    label: "Zeitschrift f\xFCr deutsche Philologie (Deutsch)"
  },
  {
    value: "zeitschrift-fur-die-geschichte-des-oberrheins",
    label: "Zeitschrift f\xFCr die Geschichte des Oberrheins (Deutsch)"
  },
  {
    value: "zeitschrift-fur-digitale-geisteswissenschaften",
    label: "Zeitschrift f\xFCr digitale Geisteswissenschaften (Deutsch)"
  },
  {
    value: "zeitschrift-fur-fantastikforschung",
    label: "Zeitschrift f\xFCr Fantastikforschung (Deutsch)"
  },
  {
    value: "zeitschrift-fur-geschichtsdidaktik",
    label: "Zeitschrift f\xFCr Geschichtsdidaktik (Deutsch)"
  },
  {
    value: "zeitschrift-fur-internationale-beziehungen",
    label: "Zeitschrift f\xFCr Internationale Beziehungen (Deutsch)"
  },
  {
    value: "zeitschrift-fur-kunstgeschichte",
    label: "Zeitschrift f\xFCr Kunstgeschichte"
  },
  {
    value: "zeitschrift-fur-medien-und-kulturforschung",
    label: "Zeitschrift f\xFCr Medien- und Kulturforschung (Deutsch)"
  },
  {
    value: "zeitschrift-fur-medienwissenschaft",
    label: "Zeitschrift f\xFCr Medienwissenschaft (Deutsch)"
  },
  {
    value: "zeitschrift-fur-ostmitteleuropa-forschung",
    label: "Zeitschrift f\xFCr Ostmitteleuropa-Forschung (Deutsch)"
  },
  {
    value: "zeitschrift-fur-padagogik",
    label: "Zeitschrift f\xFCr P\xE4dagogik (Deutsch)"
  },
  {
    value: "zeitschrift-fur-papyrologie-und-epigraphik",
    label: "Zeitschrift f\xFCr Papyrologie und Epigraphik"
  },
  {
    value: "zeitschrift-fur-parlamentsfragen",
    label: "Zeitschrift f\xFCr Parlamentsfragen (Deutsch)"
  },
  {
    value: "zeitschrift-fur-politik",
    label: "Zeitschrift f\xFCr Politik (German)"
  },
  {
    value: "zeitschrift-fur-qualitative-forschung",
    label: "Zeitschrift f\xFCr Qualitative Forschung (Deutsch)"
  },
  {
    value: "zeitschrift-fur-religionswissenschaft-author-date",
    label: "Zeitschrift f\xFCr Religionswissenschaft (author-date)"
  },
  {
    value: "zeitschrift-fur-religionswissenschaft-note",
    label: "Zeitschrift f\xFCr Religionswissenschaft (note)"
  },
  {
    value: "zeitschrift-fur-soziologie",
    label: "Zeitschrift f\xFCr Soziologie (Deutsch)"
  },
  {
    value: "zeitschrift-fur-theologie-und-kirche",
    label: "Zeitschrift f\xFCr Theologie und Kirche (Deutsch)"
  },
  {
    value: "zeitschrift-fur-theologie-und-philosophie",
    label: "Zeitschrift f\xFCr Theologie und Philosophie"
  },
  {
    value: "zeitschrift-fur-zahnarztliche-implantologie",
    label: "Zeitschrift f\xFCr Zahn\xE4rztliche Implantologie (Deutsch)"
  },
  {
    value: "zeszyty-prawnicze-bas",
    label: "Zeszyty Prawnicze BAS (Polski)"
  },
  {
    value: "zilsel",
    label: "Zilsel (Fran\xE7ais)"
  },
  {
    value: "zitierguide-leitfaden-zum-fachgerechten-zitieren-in-rechtswissenschaftlichen-arbeiten",
    label: "ZitierGuide: Leitfaden zum fachgerechten Zitieren in rechtswissenschaftlichen Arbeiten (Roger M\xFCller) (Deutsch - Schweiz)"
  },
  {
    value: "zoological-journal-of-the-linnean-society",
    label: "Zoological Journal of the Linnean Society"
  },
  {
    value: "zootaxa",
    label: "Zootaxa"
  },
  {
    value: "zwitscher-maschine",
    label: "Zwitscher-Maschine"
  },
  {
    value: "jm-azr-erstzitat-kurz-mit-verzeichnissen",
    label: "JM AZR (Erstzitat kurz mit Verzeichnissen)"
  },
  {
    value: "jm-azr",
    label: "JM AZR"
  },
  {
    value: "jm-chicago-fullnote-bibliography-nagoya",
    label: "JM Chicago Manual of Style 16th edition (full note) [Nagoya]"
  },
  {
    value: "jm-chicago-fullnote-bibliography-polyglot",
    label: "JM Chicago Manual of Style 16th edition (full note, polyglot)"
  },
  {
    value: "jm-chicago-fullnote-bibliography",
    label: "JM Chicago Manual of Style 16th edition (full note)"
  },
  {
    value: "jm-chinese-gb7714-2005-numeric",
    label: "JM Chinese Std GB/T 7714-2005 (numeric, Chinese)"
  },
  {
    value: "jm-diritto-pubblico-comparato-ed-europeo",
    label: "JM Diritto pubblico comparato ed europeo"
  },
  {
    value: "harvard-australian-national-university",
    label: "JM Harvard - Australian National University"
  },
  {
    value: "jm-ibfd-with-page-label",
    label: "JM IBFD Standard Citations and References (with page label)"
  },
  {
    value: "jm-ibfd",
    label: "JM IBFD Standard Citations and References"
  },
  {
    value: "jm-indigobook-law-review",
    label: "JM Indigo Book Law Review"
  },
  {
    value: "jm-indigobook",
    label: "JM Indigo Book"
  },
  {
    value: "japan-sociological-society",
    label: "\u65E5\u672C\u793E\u4F1A\u5B66\u4F1A (author-date, Japanese)"
  },
  {
    value: "jm-leg-cit-literaturverzeichnis",
    label: "JM leg cit mit Literaturverzeichnis"
  },
  {
    value: "jm-leg-cit-ohne-verzeichnisse",
    label: "JM leg cit ohne Verzeichnisse"
  },
  {
    value: "jm-leg-cit-rechtsquellenverzeichnis-literaturverzeichnis",
    label: "JM leg cit mit Rechtsquellenverzeichnis und Literaturverzeichnis"
  },
  {
    value: "jm-mgcill-v9",
    label: "JM - Canadian Guide to Uniform Legal Citation (9th edition) / Manuel canadien de la r\xE9f\xE9rence juridique (9\u1D49 \xE9dition)"
  },
  {
    value: "jm-new-zealand-law",
    label: "JM New Zealand Law Style"
  },
  {
    value: "jm-oscola",
    label: "JM OSCOLA - Oxford Standard for Citation of Legal Authorities"
  },
  {
    value: "jm-taylor-and-francis-chicago-author-date",
    label: "JM Taylor & Francis - Chicago Manual of Style (author-date)"
  },
  {
    value: "jm-turabian-fullnote-bibliography-eu-multi",
    label: "JM Turabian 8th edition (full note, EU multilingual)"
  },
  {
    value: "jm-turabian-fullnote-bibliography-nl-multi",
    label: "JM Turabian 8th edition (full note, Dutch multilingual)"
  },
  {
    value: "jm-vis-moot-1",
    label: "JM Vis Moot variant 1"
  },
  {
    value: "jm-wirtschaftsuniversitat-wien-steuerrecht",
    label: "JM Wirtschaftsuniversit\xE4t Wien \u2013 Steuerrecht"
  },
  {
    value: "juris-eu.int",
    label: "Verwijzingen en Afkortingen (Belgium)"
  }
];
var cslList = new Fuse(cslListRaw, {
  keys: ["label"],
  minMatchCharLength: 3
});

// src/settings/select.helpers.tsx
var customSelectStyles = {
  control: (provided, state) => {
    return {
      ...provided,
      borderColor: state.isFocused ? "var(--interactive-accent)" : "var(--background-modifier-border)",
      boxShadow: state.isFocused ? "0 0 0 1px var(--interactive-accent)" : "none",
      ":hover": {
        borderColor: state.isFocused ? "var(--interactive-accent)" : "var(--background-modifier-border)"
      }
    };
  }
};
function searchCSL(inputValue) {
  return cslList.search(inputValue).map((res) => res.item);
}
var loadCSLOptionsDB = 0;
function loadCSLOptions(inputValue, callback) {
  if (inputValue === "") {
    callback([]);
  } else {
    clearTimeout(loadCSLOptionsDB);
    loadCSLOptionsDB = activeWindow.setTimeout(() => {
      callback([
        { value: inputValue, label: inputValue },
        ...searchCSL(inputValue)
      ]);
    }, 150);
  }
}
function NoOptionMessage() {
  return /* @__PURE__ */ Cn.createElement("span", null, "Type to search CSL styles");
}
function NoFileOptionMessage() {
  return /* @__PURE__ */ Cn.createElement("span", null, "Type to search");
}
function buildFileSearch() {
  const files = app.vault.getMarkdownFiles();
  return new Fuse(files, {
    keys: ["basename"],
    minMatchCharLength: 2
  });
}
var fileSearchDB = 0;
var buildLoadFileOptions = (search2) => (inputValue, callback) => {
  if (inputValue === "") {
    callback([]);
  } else {
    clearTimeout(fileSearchDB);
    fileSearchDB = activeWindow.setTimeout(() => {
      callback(
        search2.search(inputValue).map((res) => {
          return {
            value: res.item.path,
            label: res.item.path
          };
        })
      );
    }, 150);
  }
};

// src/settings/CiteFormatSettings.tsx
function CiteFormatSettings({
  format: format3,
  index: index2,
  updateFormat,
  removeFormat
}) {
  const defaultStyle = Cn.useMemo(() => {
    if (!format3.cslStyle)
      return void 0;
    const match2 = cslListRaw.find((item) => item.value === format3.cslStyle);
    if (match2)
      return match2;
    return { label: format3.cslStyle, value: format3.cslStyle };
  }, [format3.cslStyle]);
  const onChangeName = Cn.useCallback(
    (e3) => {
      updateFormat(index2, {
        ...format3,
        name: e3.target.value
      });
    },
    [updateFormat, index2, format3]
  );
  const onChangeFormat = Cn.useCallback(
    (e3) => {
      const value = e3.target.value;
      const newFormat = {
        ...format3,
        format: value
      };
      if (value === "latex") {
        newFormat.command = "cite";
      } else if (value === "biblatex") {
        newFormat.command = "autocite";
      } else if (newFormat.command) {
        delete newFormat.command;
      }
      if (newFormat.format !== "template" && newFormat.template) {
        delete newFormat.template;
      }
      if (newFormat.format !== "pandoc" && newFormat.brackets) {
        delete newFormat.brackets;
      }
      updateFormat(index2, newFormat);
    },
    [updateFormat, index2, format3]
  );
  const onChangeTemplate = Cn.useCallback(
    (e3) => {
      updateFormat(index2, {
        ...format3,
        template: e3.target.value
      });
    },
    [updateFormat, index2, format3]
  );
  const onChangeCSLStyle = Cn.useCallback(
    (e3) => {
      updateFormat(index2, {
        ...format3,
        cslStyle: e3 == null ? void 0 : e3.value
      });
    },
    [updateFormat, index2, format3]
  );
  const onChangeCommand = Cn.useCallback(
    (e3) => {
      updateFormat(index2, {
        ...format3,
        command: e3.target.value
      });
    },
    [updateFormat, index2, format3]
  );
  const onChangeBrackets = Cn.useCallback(() => {
    updateFormat(index2, {
      ...format3,
      brackets: !format3.brackets
    });
  }, [updateFormat, index2, format3]);
  const onRemove = Cn.useCallback(() => {
    removeFormat(index2);
  }, [removeFormat, index2]);
  return /* @__PURE__ */ Cn.createElement("div", { className: "zt-format" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Name"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement("input", { onChange: onChangeName, type: "text", value: format3.name }), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__delete" }, /* @__PURE__ */ Cn.createElement("button", { className: "zt-format__delete-btn", onClick: onRemove }, /* @__PURE__ */ Cn.createElement(Icon, { name: "trash" }))))), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Output Format"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    "select",
    {
      className: "dropdown",
      defaultValue: format3.format,
      onChange: onChangeFormat
    },
    /* @__PURE__ */ Cn.createElement("option", { value: "latex" }, "LaTeX"),
    /* @__PURE__ */ Cn.createElement("option", { value: "biblatex" }, "BibLaTeX"),
    /* @__PURE__ */ Cn.createElement("option", { value: "pandoc" }, "Pandoc"),
    /* @__PURE__ */ Cn.createElement("option", { value: "formatted-citation" }, "Formatted Citation"),
    /* @__PURE__ */ Cn.createElement("option", { value: "formatted-bibliography" }, "Formatted Bibliography"),
    /* @__PURE__ */ Cn.createElement("option", { value: "template" }, "Template")
  ))), format3.format === "template" && /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Template"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    "textarea",
    {
      rows: 4,
      onChange: onChangeTemplate,
      value: format3.template
    }
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "Citation templates have access to a subset of the Zotero item's data. The item's first attachement is available under the", " ", /* @__PURE__ */ Cn.createElement("pre", null, "attachment"), " key. Annotations are not provided. Open the data explorer from the command pallet to see available template data. Templates are written using", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      href: "https://mozilla.github.io/nunjucks/templating.html#variables",
      target: "_blank",
      rel: "noreferrer"
    },
    "Nunjucks"
  ), ".", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      href: "https://github.com/mgmeyers/obsidian-zotero-integration/blob/main/docs/Templating.md",
      target: "_blank",
      rel: "noreferrer"
    },
    "See the templating documentation here"
  ), ".")), ["formatted-citation", "formatted-bibliography", "template"].contains(
    format3.format
  ) && /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, format3.format === "template" ? "Bibliography Style" : "Citation Style"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    AsyncSelect$1,
    {
      noOptionsMessage: NoOptionMessage,
      placeholder: "Search...",
      cacheOptions: true,
      defaultValue: defaultStyle,
      className: "zt-multiselect",
      loadOptions: loadCSLOptions,
      isClearable: true,
      onChange: onChangeCSLStyle,
      styles: customSelectStyles
    }
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "Note, the chosen style must be installed in Zotero. See", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      target: "_blank",
      href: "https://www.zotero.org/support/styles",
      rel: "noreferrer"
    },
    "Zotero: Citation Styles"
  ))), ["latex", "biblatex"].contains(format3.format) && /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Citation Command"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    "input",
    {
      type: "text",
      value: format3.command,
      onChange: onChangeCommand
    }
  ))), format3.format === "pandoc" && /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Include Brackets"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    "div",
    {
      onClick: onChangeBrackets,
      className: `checkbox-container${format3.brackets ? " is-enabled" : ""}`
    }
  ))));
}

// src/settings/ExportFormatSettings.tsx
function ExportFormatSettings({
  format: format3,
  index: index2,
  updateFormat,
  removeFormat
}) {
  const loadFileOptions = Cn.useMemo(() => {
    const fileSearch = buildFileSearch();
    return buildLoadFileOptions(fileSearch);
  }, []);
  const defaultTemplate = Cn.useMemo(() => {
    if (!format3.templatePath)
      return void 0;
    const file = app.vault.getMarkdownFiles().find((item) => item.path === format3.templatePath);
    return file ? { value: file.path, label: file.path } : void 0;
  }, [format3.templatePath]);
  const defaultStyle = Cn.useMemo(() => {
    if (!format3.cslStyle)
      return void 0;
    const match2 = cslListRaw.find((item) => item.value === format3.cslStyle);
    if (match2)
      return match2;
    return { label: format3.cslStyle, value: format3.cslStyle };
  }, [format3.cslStyle]);
  const onChangeStr = Cn.useCallback(
    (e3) => {
      const key = e3.target.dataset.key;
      updateFormat(index2, {
        ...format3,
        [key]: e3.target.value
      });
    },
    [updateFormat, index2, format3]
  );
  const onChangeCSLStyle = Cn.useCallback(
    (e3) => {
      updateFormat(index2, {
        ...format3,
        cslStyle: e3 == null ? void 0 : e3.value
      });
    },
    [updateFormat, index2, format3]
  );
  const onChangeTemplatePath = Cn.useCallback(
    (e3) => {
      updateFormat(index2, {
        ...format3,
        templatePath: e3 == null ? void 0 : e3.value
      });
    },
    [updateFormat, index2, format3]
  );
  const onRemove = Cn.useCallback(() => {
    removeFormat(index2);
  }, [removeFormat, index2]);
  return /* @__PURE__ */ Cn.createElement("div", { className: "zt-format" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Name"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    "input",
    {
      onChange: onChangeStr,
      type: "text",
      "data-key": "name",
      value: format3.name
    }
  ), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__delete" }, /* @__PURE__ */ Cn.createElement("button", { className: "zt-format__delete-btn", onClick: onRemove }, /* @__PURE__ */ Cn.createElement(Icon, { name: "trash" }))))), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Output Path"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    "input",
    {
      onChange: onChangeStr,
      type: "text",
      "data-key": "outputPathTemplate",
      value: format3.outputPathTemplate
    }
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "The file path of the exported markdown. Supports templating, eg", " ", /* @__PURE__ */ Cn.createElement("pre", null, "My Folder/", "{{citekey}}", ".md"), ". Templates have access to data from the Zotero item and its first attachment.")), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Image Output Path"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    "input",
    {
      onChange: onChangeStr,
      type: "text",
      "data-key": "imageOutputPathTemplate",
      value: format3.imageOutputPathTemplate
    }
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "The folder in which images should be saved. Supports templating, eg", " ", /* @__PURE__ */ Cn.createElement("pre", null, "Assets/", "{{citekey}}", "/"), ". Templates have access to data from the Zotero item and its first attachment.")), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Image Base Name"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    "input",
    {
      onChange: onChangeStr,
      type: "text",
      "data-key": "imageBaseNameTemplate",
      value: format3.imageBaseNameTemplate
    }
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "The base file name of exported images. Eg. ", /* @__PURE__ */ Cn.createElement("pre", null, "image"), " will result in ", /* @__PURE__ */ Cn.createElement("pre", null, "image-1-x123-y456.jpg"), " where ", /* @__PURE__ */ Cn.createElement("pre", null, "1"), " is the page number and ", /* @__PURE__ */ Cn.createElement("pre", null, "x123"), " and ", /* @__PURE__ */ Cn.createElement("pre", null, "y456"), " are the x and y coordinates of rectangle annotation on the page. Supports templating. Templates have access to data from the Zotero item and its first attachment.")), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Template File"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    AsyncSelect$1,
    {
      noOptionsMessage: NoFileOptionMessage,
      placeholder: "Search...",
      cacheOptions: true,
      defaultValue: defaultTemplate,
      className: "zt-multiselect",
      loadOptions: loadFileOptions,
      isClearable: true,
      onChange: onChangeTemplatePath,
      styles: customSelectStyles
    }
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "Open the data explorer from the command pallet to see available template data. Templates are written using", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      href: "https://mozilla.github.io/nunjucks/templating.html#variables",
      target: "_blank",
      rel: "noreferrer"
    },
    "Nunjucks"
  ), ".", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      href: "https://github.com/mgmeyers/obsidian-zotero-integration/blob/main/docs/Templating.md",
      target: "_blank",
      rel: "noreferrer"
    },
    "See the templating documentation here"
  ), ".")), format3.headerTemplatePath && /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form is-deprecated" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Header Template File (deprecated)"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement("input", { type: "text", disabled: true, value: format3.headerTemplatePath }), /* @__PURE__ */ Cn.createElement(
    "button",
    {
      className: "mod-warning",
      onClick: () => {
        updateFormat(index2, {
          ...format3,
          headerTemplatePath: void 0
        });
      }
    },
    "Remove Template"
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "Deprecated: Separate template files are no longer needed.", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      href: "https://github.com/mgmeyers/obsidian-zotero-integration/blob/main/docs/Templating.md",
      target: "_blank",
      rel: "noreferrer"
    },
    "See the templating documentation here"
  ), ".")), format3.annotationTemplatePath && /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form is-deprecated" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Annotation Template File (deprecated)"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement("input", { type: "text", disabled: true, value: format3.annotationTemplatePath }), /* @__PURE__ */ Cn.createElement(
    "button",
    {
      className: "mod-warning",
      onClick: () => {
        updateFormat(index2, {
          ...format3,
          annotationTemplatePath: void 0
        });
      }
    },
    "Remove Template"
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "Deprecated: Separate template files are no longer needed.", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      href: "https://github.com/mgmeyers/obsidian-zotero-integration/blob/main/docs/Templating.md",
      target: "_blank",
      rel: "noreferrer"
    },
    "See the templating documentation here"
  ), ".")), format3.footerTemplatePath && /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form is-deprecated" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Footer Template File (deprecated)"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement("input", { type: "text", disabled: true, value: format3.footerTemplatePath }), /* @__PURE__ */ Cn.createElement(
    "button",
    {
      className: "mod-warning",
      onClick: () => {
        updateFormat(index2, {
          ...format3,
          footerTemplatePath: void 0
        });
      }
    },
    "Remove Template"
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "Deprecated: Separate template files are no longer needed.", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      href: "https://github.com/mgmeyers/obsidian-zotero-integration/blob/main/docs/Templating.md",
      target: "_blank",
      rel: "noreferrer"
    },
    "See the templating documentation here"
  ), ".")), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__form" }, /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__label" }, "Bilbiography Style"), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-wrapper" }, /* @__PURE__ */ Cn.createElement(
    AsyncSelect$1,
    {
      noOptionsMessage: NoOptionMessage,
      placeholder: "Search...",
      cacheOptions: true,
      defaultValue: defaultStyle,
      className: "zt-multiselect",
      loadOptions: loadCSLOptions,
      isClearable: true,
      onChange: onChangeCSLStyle,
      styles: customSelectStyles
    }
  )), /* @__PURE__ */ Cn.createElement("div", { className: "zt-format__input-note" }, "Note, the chosen style must be installed in Zotero. See", " ", /* @__PURE__ */ Cn.createElement(
    "a",
    {
      target: "_blank",
      href: "https://www.zotero.org/support/styles",
      rel: "noreferrer"
    },
    "Zotero: Citation Styles"
  ))));
}

// src/settings/settings.tsx
function SettingsComponent({
  settings,
  addCiteFormat,
  updateCiteFormat,
  removeCiteFormat,
  addExportFormat,
  updateExportFormat,
  removeExportFormat,
  updateSetting
}) {
  var _a2;
  const [citeFormatState, setCiteFormatState] = Cn.useState(
    settings.citeFormats
  );
  const [exportFormatState, setExportFormatState] = Cn.useState(
    settings.exportFormats
  );
  const [openNoteAfterImportState, setOpenNoteAfterImport] = Cn.useState(
    !!settings.openNoteAfterImport
  );
  const [shouldShowCitekeyTooltips, setShouldShowCitekeyTooltips] = Cn.useState(!!settings.shouldShowCitekeyTooltips);
  const [citekeyReferenceHideLinks, setCitekeyReferenceHideLinks] = Cn.useState(!!settings.citekeyReferenceHideLinks);
  const defaultPandocStyle = Cn.useMemo(() => {
    if (!settings.citekeyReferenceCslStyle)
      return void 0;
    const match2 = cslListRaw.find(
      (item) => item.value === settings.citekeyReferenceCslStyle
    );
    if (match2)
      return match2;
    return {
      label: settings.citekeyReferenceCslStyle,
      value: settings.citekeyReferenceCslStyle
    };
  }, [settings.citekeyReferenceCslStyle]);
  const onChangeCSLStyle = Cn.useCallback(
    (e3) => {
      updateSetting("citekeyReferenceCslStyle", e3 == null ? void 0 : e3.value);
    },
    [updateSetting]
  );
  const [ocrState, setOCRState] = Cn.useState(settings.pdfExportImageOCR);
  const [citeSuggestState, setCiteSuggestState] = Cn.useState(
    !!settings.shouldShowCiteSuggest
  );
  const [concat, setConcat] = Cn.useState(!!settings.shouldConcat);
  const updateCite = Cn.useCallback(
    (0, import_obsidian19.debounce)(
      (index2, format3) => {
        setCiteFormatState(updateCiteFormat(index2, format3));
      },
      200,
      true
    ),
    [updateCiteFormat]
  );
  const addCite = Cn.useCallback(() => {
    setCiteFormatState(
      addCiteFormat({
        name: `Format #${citeFormatState.length + 1}`,
        format: "formatted-citation"
      })
    );
  }, [addCiteFormat, citeFormatState]);
  const removeCite = Cn.useCallback(
    (index2) => {
      setCiteFormatState(removeCiteFormat(index2));
    },
    [removeCiteFormat]
  );
  const updateExport = Cn.useCallback(
    (0, import_obsidian19.debounce)(
      (index2, format3) => {
        setExportFormatState(updateExportFormat(index2, format3));
      },
      200,
      true
    ),
    [updateExportFormat]
  );
  const addExport = Cn.useCallback(() => {
    setExportFormatState(
      addExportFormat({
        name: `Import #${exportFormatState.length + 1}`,
        outputPathTemplate: "{{citekey}}.md",
        imageOutputPathTemplate: "{{citekey}}/",
        imageBaseNameTemplate: "image"
      })
    );
  }, [addExportFormat, citeFormatState]);
  const removeExport = Cn.useCallback(
    (index2) => {
      setExportFormatState(removeExportFormat(index2));
    },
    [removeExportFormat]
  );
  const tessPathRef = Cn.useRef(null);
  const tessDataPathRef = Cn.useRef(null);
  const [useCustomPort, setUseCustomPort] = Cn.useState(
    settings.database === "Custom"
  );
  return /* @__PURE__ */ Cn.createElement("div", null, /* @__PURE__ */ Cn.createElement(SettingItem, { name: "General Settings", isHeading: true }), /* @__PURE__ */ Cn.createElement(AssetDownloader, { settings, updateSetting }), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Database",
      description: "Supports Zotero and Juris-M. Alternatively a custom port number can be specified."
    },
    /* @__PURE__ */ Cn.createElement(
      "select",
      {
        className: "dropdown",
        defaultValue: settings.database,
        onChange: (e3) => {
          const value = e3.target.value;
          updateSetting("database", value);
          if (value === "Custom") {
            setUseCustomPort(true);
          } else {
            setUseCustomPort(false);
          }
        }
      },
      /* @__PURE__ */ Cn.createElement("option", { value: "Zotero" }, "Zotero"),
      /* @__PURE__ */ Cn.createElement("option", { value: "Juris-M" }, "Juris-M"),
      /* @__PURE__ */ Cn.createElement("option", { value: "Custom" }, "Custom")
    )
  ), useCustomPort ? /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Port number",
      description: "If a custom port number has been set in Zotero, enter it here."
    },
    /* @__PURE__ */ Cn.createElement(
      "input",
      {
        onChange: (e3) => updateSetting("port", e3.target.value),
        type: "number",
        placeholder: "Example: 23119",
        defaultValue: settings.port
      }
    )
  ) : null, /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Note Import Location",
      description: "Notes imported from Zotero will be added to this folder in your vault"
    },
    /* @__PURE__ */ Cn.createElement(
      "input",
      {
        onChange: (e3) => updateSetting(
          "noteImportFolder",
          e3.target.value
        ),
        type: "text",
        spellCheck: false,
        placeholder: "Example: folder 1/folder 2",
        defaultValue: settings.noteImportFolder
      }
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Open the created or updated note(s) after import",
      description: "The created or updated markdown files resulting from the import will be automatically opened."
    },
    /* @__PURE__ */ Cn.createElement(
      "div",
      {
        onClick: () => {
          setOpenNoteAfterImport((state) => {
            updateSetting("openNoteAfterImport", !state);
            return !state;
          });
        },
        className: `checkbox-container${openNoteAfterImportState ? " is-enabled" : ""}`
      }
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Which notes to open after import",
      description: "Open either the first note imported, the last note imported, or all notes in new tabs."
    },
    /* @__PURE__ */ Cn.createElement(
      "select",
      {
        className: "dropdown",
        defaultValue: settings.whichNotesToOpenAfterImport,
        disabled: !settings.openNoteAfterImport,
        onChange: (e3) => updateSetting(
          "whichNotesToOpenAfterImport",
          e3.target.value
        )
      },
      /* @__PURE__ */ Cn.createElement("option", { value: "first-imported-note" }, "First imported note"),
      /* @__PURE__ */ Cn.createElement("option", { value: "last-imported-note" }, "Last imported note"),
      /* @__PURE__ */ Cn.createElement("option", { value: "all-imported-notes" }, "All imported notes")
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Enable Cite Key Autocomplete",
      description: "Typing the @ symbol will display an autocomplete dialog for citation keys"
    },
    /* @__PURE__ */ Cn.createElement(
      "div",
      {
        onClick: () => {
          setCiteSuggestState((state) => {
            updateSetting("shouldShowCiteSuggest", !state);
            return !state;
          });
        },
        className: `checkbox-container${citeSuggestState ? " is-enabled" : ""}`
      }
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Cite Key Autocomplete Insertion Template",
      description: `Use ${import_obsidian19.Platform.isMacOS ? "\u2325 + \u21B5" : "Alt + \u21B5"} when the autocomplete dialog is displayed to insert the citation key using this template.`
    },
    /* @__PURE__ */ Cn.createElement(
      "input",
      {
        onChange: (e3) => updateSetting(
          "citeSuggestTemplate",
          e3.target.value
        ),
        type: "text",
        spellCheck: false,
        placeholder: "Example: [[{{citekey}}]]",
        defaultValue: settings.citeSuggestTemplate
      }
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Enable Annotation Concatenation",
      description: "Annotations extracted from PDFs that begin with '+' will be appended to the previous annotation. Note: Annotation ordering is not always consistent and you may not always acheive the desire concatenation result"
    },
    /* @__PURE__ */ Cn.createElement(
      "div",
      {
        onClick: () => {
          setConcat((state) => {
            updateSetting("shouldConcat", !state);
            return !state;
          });
        },
        className: `checkbox-container${concat ? " is-enabled" : ""}`
      }
    )
  ), /* @__PURE__ */ Cn.createElement(SettingItem, { name: "Citation Formats", isHeading: true }), /* @__PURE__ */ Cn.createElement(SettingItem, null, /* @__PURE__ */ Cn.createElement("button", { onClick: addCite, className: "mod-cta" }, "Add Citation Format")), citeFormatState.map((f4, i4) => {
    return /* @__PURE__ */ Cn.createElement(
      CiteFormatSettings,
      {
        key: i4,
        format: f4,
        index: i4,
        updateFormat: updateCite,
        removeFormat: removeCite
      }
    );
  }), /* @__PURE__ */ Cn.createElement(SettingItem, { name: "Import Formats", isHeading: true }), /* @__PURE__ */ Cn.createElement(SettingItem, null, /* @__PURE__ */ Cn.createElement("button", { onClick: addExport, className: "mod-cta" }, "Add Import Format")), exportFormatState.map((f4, i4) => {
    return /* @__PURE__ */ Cn.createElement(
      ExportFormatSettings,
      {
        key: exportFormatState.length - i4,
        format: f4,
        index: i4,
        updateFormat: updateExport,
        removeFormat: removeExport
      }
    );
  }), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Import Image Settings",
      description: "Rectangle annotations will be extracted from PDFs as images.",
      isHeading: true
    }
  ), /* @__PURE__ */ Cn.createElement(SettingItem, { name: "Image Format" }, /* @__PURE__ */ Cn.createElement(
    "select",
    {
      className: "dropdown",
      defaultValue: settings.pdfExportImageFormat,
      onChange: (e3) => updateSetting(
        "pdfExportImageFormat",
        e3.target.value
      )
    },
    /* @__PURE__ */ Cn.createElement("option", { value: "jpg" }, "jpg"),
    /* @__PURE__ */ Cn.createElement("option", { value: "png" }, "png")
  )), /* @__PURE__ */ Cn.createElement(SettingItem, { name: "Image Quality (jpg only)" }, /* @__PURE__ */ Cn.createElement(
    "input",
    {
      min: "0",
      max: "100",
      onChange: (e3) => updateSetting(
        "pdfExportImageQuality",
        Number(e3.target.value)
      ),
      type: "number",
      defaultValue: settings.pdfExportImageQuality.toString()
    }
  )), /* @__PURE__ */ Cn.createElement(SettingItem, { name: "Image DPI" }, /* @__PURE__ */ Cn.createElement(
    "input",
    {
      min: "0",
      onChange: (e3) => updateSetting(
        "pdfExportImageDPI",
        Number(e3.target.value)
      ),
      type: "number",
      defaultValue: settings.pdfExportImageDPI.toString()
    }
  )), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Image OCR",
      description: /* @__PURE__ */ Cn.createElement("div", null, "Attempt to extract text from images created by rectangle annotations. This requires that", " ", /* @__PURE__ */ Cn.createElement(
        "a",
        {
          href: "https://tesseract-ocr.github.io/tessdoc/",
          target: "_blank",
          rel: "noreferrer"
        },
        "tesseract"
      ), " ", "be installed on your system. Tesseract can be installed from", /* @__PURE__ */ Cn.createElement("a", { href: "https://brew.sh/", target: "_blank", rel: "noreferrer" }, "homebrew on mac"), ", various linux package managers, and from", " ", /* @__PURE__ */ Cn.createElement(
        "a",
        {
          href: "https://github.com/UB-Mannheim/tesseract/wiki",
          target: "_blank",
          rel: "noreferrer"
        },
        "here on windows"
      ), ".")
    },
    /* @__PURE__ */ Cn.createElement(
      "div",
      {
        onClick: () => setOCRState((s5) => {
          updateSetting("pdfExportImageOCR", !s5);
          return !s5;
        }),
        className: `checkbox-container${ocrState ? " is-enabled" : ""}`
      }
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Tesseract path",
      description: /* @__PURE__ */ Cn.createElement("div", null, "Required: An absolute path to the tesseract executable. This can be found on mac and linux with the terminal command", " ", /* @__PURE__ */ Cn.createElement("pre", null, "which tesseract"))
    },
    /* @__PURE__ */ Cn.createElement(
      "input",
      {
        ref: tessPathRef,
        onChange: (e3) => updateSetting(
          "pdfExportImageTesseractPath",
          e3.target.value
        ),
        type: "text",
        defaultValue: settings.pdfExportImageTesseractPath
      }
    ),
    /* @__PURE__ */ Cn.createElement(
      "div",
      {
        className: "clickable-icon setting-editor-extra-setting-button",
        "aria-label": "Attempt to find tesseract automatically",
        onClick: async () => {
          try {
            const pathToTesseract = await (0, import_which.default)("tesseract");
            if (pathToTesseract) {
              tessPathRef.current.value = pathToTesseract;
              updateSetting("pdfExportImageTesseractPath", pathToTesseract);
            } else {
              new import_obsidian19.Notice(
                "Unable to find tesseract on your system. If it is installed, please manually enter a path."
              );
            }
          } catch (e3) {
            new import_obsidian19.Notice(
              "Unable to find tesseract on your system. If it is installed, please manually enter a path."
            );
            console.error(e3);
          }
        }
      },
      /* @__PURE__ */ Cn.createElement(Icon, { name: "magnifying-glass" })
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Image OCR Language",
      description: /* @__PURE__ */ Cn.createElement("div", null, "Optional: defaults to english. Multiple languages can be specified like so: ", /* @__PURE__ */ Cn.createElement("pre", null, "eng+deu"), ". Each language must be installed on your system.", " ", /* @__PURE__ */ Cn.createElement(
        "a",
        {
          href: "https://github.com/tesseract-ocr/tessdata",
          target: "_blank",
          rel: "noreferrer"
        },
        "Languages can be downloaded here"
      ), ". (See", " ", /* @__PURE__ */ Cn.createElement(
        "a",
        {
          href: "https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html",
          target: "_blank",
          rel: "noreferrer"
        },
        "here for a description of the language codes"
      ), ")")
    },
    /* @__PURE__ */ Cn.createElement(
      "input",
      {
        onChange: (e3) => updateSetting(
          "pdfExportImageOCRLang",
          e3.target.value
        ),
        type: "text",
        defaultValue: settings.pdfExportImageOCRLang
      }
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Tesseract data directory",
      description: "Optional: supply an absolute path to the directory where tesseract's language files reside. This folder should include *.traineddata files for your selected languages."
    },
    /* @__PURE__ */ Cn.createElement(
      "input",
      {
        ref: tessDataPathRef,
        onChange: (e3) => updateSetting(
          "pdfExportImageTessDataDir",
          e3.target.value
        ),
        type: "text",
        defaultValue: settings.pdfExportImageTessDataDir
      }
    ),
    /* @__PURE__ */ Cn.createElement(
      "div",
      {
        className: "clickable-icon setting-editor-extra-setting-button",
        "aria-label": "Select the tesseract data directory",
        onClick: () => {
          const path8 = require("electron").remote.dialog.showOpenDialogSync({
            properties: ["openDirectory"]
          });
          if (path8 && path8.length) {
            tessDataPathRef.current.value = path8[0];
            updateSetting("pdfExportImageTessDataDir", path8[0]);
          }
        }
      },
      /* @__PURE__ */ Cn.createElement(Icon, { name: "lucide-folder-open" })
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Pandoc reference settings",
      description: "Display tooltips and a reference list for pandoc citations. Note: the pandoc reference list plugin must be disabled.",
      isHeading: true
    }
  ), /* @__PURE__ */ Cn.createElement(SettingItem, { name: "Pandoc reference output style" }, /* @__PURE__ */ Cn.createElement(
    AsyncSelect$1,
    {
      noOptionsMessage: NoOptionMessage,
      placeholder: "Search...",
      cacheOptions: true,
      defaultValue: defaultPandocStyle,
      className: "zt-multiselect",
      loadOptions: loadCSLOptions,
      isClearable: true,
      onChange: onChangeCSLStyle,
      styles: customSelectStyles
    }
  )), /* @__PURE__ */ Cn.createElement(SettingItem, { name: "Display citation tooltips" }, /* @__PURE__ */ Cn.createElement(
    "div",
    {
      onClick: () => {
        setShouldShowCitekeyTooltips((state) => {
          updateSetting("shouldShowCitekeyTooltips", !state);
          return !state;
        });
      },
      className: `checkbox-container${shouldShowCitekeyTooltips ? " is-enabled" : ""}`
    }
  )), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Tooltip delay",
      description: "Set the amount of time (in milliseconds) to wait before displaying tooltips."
    },
    /* @__PURE__ */ Cn.createElement(
      "input",
      {
        onChange: (e3) => updateSetting(
          "citekeyTooltipDelay",
          Number(e3.target.value)
        ),
        type: "number",
        defaultValue: ((_a2 = settings.citekeyTooltipDelay) != null ? _a2 : 500).toString()
      }
    )
  ), /* @__PURE__ */ Cn.createElement(
    SettingItem,
    {
      name: "Hide links in references",
      description: "Replace links with icons to save space."
    },
    /* @__PURE__ */ Cn.createElement(
      "div",
      {
        onClick: () => {
          setCitekeyReferenceHideLinks((state) => {
            updateSetting("citekeyReferenceHideLinks", !state);
            return !state;
          });
        },
        className: `checkbox-container${citekeyReferenceHideLinks ? " is-enabled" : ""}`
      }
    )
  ));
}
var ZoteroConnectorSettingsTab = class extends import_obsidian19.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.addCiteFormat = (format3) => {
      this.plugin.addFormatCommand(format3);
      this.plugin.settings.citeFormats.unshift(format3);
      this.debouncedSave();
      return this.plugin.settings.citeFormats.slice();
    };
    this.updateCiteFormat = (index2, format3) => {
      this.plugin.removeFormatCommand(this.plugin.settings.citeFormats[index2]);
      this.plugin.addFormatCommand(format3);
      this.plugin.settings.citeFormats[index2] = format3;
      this.debouncedSave();
      return this.plugin.settings.citeFormats.slice();
    };
    this.removeCiteFormat = (index2) => {
      this.plugin.removeFormatCommand(this.plugin.settings.citeFormats[index2]);
      this.plugin.settings.citeFormats.splice(index2, 1);
      this.debouncedSave();
      return this.plugin.settings.citeFormats.slice();
    };
    this.addExportFormat = (format3) => {
      this.plugin.addExportCommand(format3);
      this.plugin.settings.exportFormats.unshift(format3);
      this.debouncedSave();
      return this.plugin.settings.exportFormats.slice();
    };
    this.updateExportFormat = (index2, format3) => {
      this.plugin.removeExportCommand(this.plugin.settings.exportFormats[index2]);
      this.plugin.addExportCommand(format3);
      this.plugin.settings.exportFormats[index2] = format3;
      this.debouncedSave();
      return this.plugin.settings.exportFormats.slice();
    };
    this.removeExportFormat = (index2) => {
      this.plugin.removeExportCommand(this.plugin.settings.exportFormats[index2]);
      this.plugin.settings.exportFormats.splice(index2, 1);
      this.debouncedSave();
      return this.plugin.settings.exportFormats.slice();
    };
    this.updateSetting = (key, value) => {
      this.plugin.settings[key] = value;
      this.debouncedSave();
      if (key === "shouldShowCitekeyTooltips") {
        document.body.toggleClass("pwc-tooltips", !!value);
      }
    };
    this.plugin = plugin;
  }
  display() {
    Cn.render(
      /* @__PURE__ */ Cn.createElement(
        SettingsComponent,
        {
          settings: this.plugin.settings,
          addCiteFormat: this.addCiteFormat,
          updateCiteFormat: this.updateCiteFormat,
          removeCiteFormat: this.removeCiteFormat,
          addExportFormat: this.addExportFormat,
          updateExportFormat: this.updateExportFormat,
          removeExportFormat: this.removeExportFormat,
          updateSetting: this.updateSetting
        }
      ),
      this.containerEl
    );
  }
  debouncedSave() {
    clearTimeout(this.dbTimer);
    this.dbTimer = activeWindow.setTimeout(() => {
      this.plugin.saveSettings();
    }, 150);
  }
  hide() {
    super.hide();
    Cn.unmountComponentAtNode(this.containerEl);
  }
};

// src/main.ts
var commandPrefix = "obsidian-zotero-desktop-connector:";
var citationCommandIDPrefix = "zdc-";
var exportCommandIDPrefix = "zdc-exp-";
var DEFAULT_SETTINGS = {
  database: "Zotero",
  noteImportFolder: "",
  pdfExportImageDPI: 120,
  pdfExportImageFormat: "jpg",
  pdfExportImageQuality: 90,
  citeFormats: [],
  exportFormats: [],
  citeSuggestTemplate: "[[{{citekey}}]]",
  openNoteAfterImport: false,
  whichNotesToOpenAfterImport: "first-imported-note"
};
async function fixPath() {
  if (process.platform === "win32") {
    return;
  }
  try {
    const path8 = await shellPath();
    process.env.PATH = path8 || [
      "./node_modules/.bin",
      "/.nodebrew/current/bin",
      "/usr/local/bin",
      process.env.PATH
    ].join(":");
  } catch (e3) {
    console.error(e3);
  }
}
var ZoteroConnector = class extends import_obsidian20.Plugin {
  get view() {
    const leaves = app.workspace.getLeavesOfType(viewType2);
    if (!(leaves == null ? void 0 : leaves.length)) {
      return null;
    }
    return leaves[0].view;
  }
  async onload() {
    await this.loadSettings();
    this.emitter = new import_obsidian20.Events();
    this.updatePDFUtility();
    this.addSettingTab(new ZoteroConnectorSettingsTab(this.app, this));
    this.registerView(viewType, (leaf) => new DataExplorerView(this, leaf));
    this.registerView(viewType2, (leaf) => new ReferenceListView(this, leaf));
    this.settings.citeFormats.forEach((f4) => {
      this.addFormatCommand(f4);
    });
    this.settings.exportFormats.forEach((f4) => {
      this.addExportCommand(f4);
    });
    this.addCommand({
      id: "zdc-insert-notes",
      name: "Insert notes into current document",
      editorCallback: (editor) => {
        var _a2;
        const database = {
          database: this.settings.database,
          port: this.settings.port
        };
        noteExportPrompt(
          database,
          (_a2 = this.app.workspace.getActiveFile()) == null ? void 0 : _a2.parent.path
        ).then((notes) => {
          if (notes) {
            insertNotesIntoCurrentDoc(editor, notes);
          }
        });
      }
    });
    this.addCommand({
      id: "zdc-import-notes",
      name: "Import notes",
      callback: () => {
        const database = {
          database: this.settings.database,
          port: this.settings.port
        };
        noteExportPrompt(database, this.settings.noteImportFolder).then((notes) => {
          if (notes) {
            return filesFromNotes(this.settings.noteImportFolder, notes);
          }
          return [];
        }).then((notes) => this.openNotes(notes));
      }
    });
    this.addCommand({
      id: "show-zotero-debug-view",
      name: "Data explorer",
      callback: () => {
        this.activateDataExplorer();
      }
    });
    this.addCommand({
      id: "show-reference-list-view",
      name: "Show pandoc references",
      checkCallback: (checking) => {
        if (checking) {
          return this.view === null;
        }
        this.activateReferenceList();
      }
    });
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian20.TFile) {
          this.emitter.trigger("fileUpdated", file);
        }
      })
    );
    this.addCommand({
      id: "update-cite-keys",
      name: "Refresh cite key list",
      callback: async () => {
        const modal = new LoadingModal(app, "Fetching data from Zotero...");
        modal.open();
        await getAllCiteKeys(
          { database: this.settings.database, port: this.settings.port },
          true
        );
        modal.close();
      }
    });
    this.registerEditorSuggest(new CiteSuggest(this.app, this));
    this.registerMarkdownPostProcessor(processCiteKeys(this));
    this.registerEditorExtension([
      viewManagerField.init(() => {
        var _a2;
        return ((_a2 = this.view) == null ? void 0 : _a2.viewManager) || null;
      }),
      citeKeyCacheField,
      citeKeyPlugin
    ]);
    this.tooltipManager = new TooltipManager(this);
    document.body.toggleClass(
      "pwc-tooltips",
      !!this.settings.shouldShowCitekeyTooltips
    );
    app.workspace.trigger("parse-style-settings");
    fixPath();
    if (this.settings.shouldShowCiteSuggest) {
      getAllCiteKeys({
        database: this.settings.database,
        port: this.settings.port
      });
    }
  }
  onunload() {
    this.settings.citeFormats.forEach((f4) => {
      this.removeFormatCommand(f4);
    });
    this.settings.exportFormats.forEach((f4) => {
      this.removeExportCommand(f4);
    });
    this.app.workspace.detachLeavesOfType(viewType);
  }
  addFormatCommand(format3) {
    this.addCommand({
      id: `${citationCommandIDPrefix}${format3.name}`,
      name: format3.name,
      editorCallback: (editor) => {
        const database = {
          database: this.settings.database,
          port: this.settings.port
        };
        if (format3.format === "template" && format3.template.trim()) {
          renderCiteTemplate({
            database,
            format: format3
          }).then((res) => {
            if (typeof res === "string") {
              editor.replaceSelection(res);
            }
          });
        } else {
          getCAYW(format3, database).then((res) => {
            if (typeof res === "string") {
              editor.replaceSelection(res);
            }
          });
        }
      }
    });
  }
  removeFormatCommand(format3) {
    this.app.commands.removeCommand(
      `${commandPrefix}${citationCommandIDPrefix}${format3.name}`
    );
  }
  addExportCommand(format3) {
    this.addCommand({
      id: `${exportCommandIDPrefix}${format3.name}`,
      name: format3.name,
      callback: async () => {
        const database = {
          database: this.settings.database,
          port: this.settings.port
        };
        this.openNotes(
          await exportToMarkdown({
            settings: this.settings,
            database,
            exportFormat: format3
          })
        );
      }
    });
  }
  removeExportCommand(format3) {
    this.app.commands.removeCommand(
      `${commandPrefix}${exportCommandIDPrefix}${format3.name}`
    );
  }
  async openNotes(createdOrUpdatedMarkdownFilesPaths) {
    const pathOfNotesToOpen = [];
    if (this.settings.openNoteAfterImport) {
      switch (this.settings.whichNotesToOpenAfterImport) {
        case "first-imported-note": {
          pathOfNotesToOpen.push(createdOrUpdatedMarkdownFilesPaths[0]);
          break;
        }
        case "last-imported-note": {
          pathOfNotesToOpen.push(
            createdOrUpdatedMarkdownFilesPaths[createdOrUpdatedMarkdownFilesPaths.length - 1]
          );
          break;
        }
        case "all-imported-notes": {
          pathOfNotesToOpen.push(...createdOrUpdatedMarkdownFilesPaths);
          break;
        }
      }
    }
    await new Promise((resolve2) => setTimeout(resolve2, 1e3));
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    for (const path8 of pathOfNotesToOpen) {
      const note = this.app.vault.getAbstractFileByPath(path8);
      const open = leaves.find(
        (leaf) => leaf.view.file === note
      );
      if (open) {
        app.workspace.revealLeaf(open);
      } else if (note instanceof import_obsidian20.TFile) {
        await this.app.workspace.getLeaf(true).openFile(note);
      }
    }
  }
  async loadSettings() {
    const loadedSettings = await this.loadData();
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...loadedSettings
    };
  }
  async saveSettings() {
    this.emitter.trigger("settingsUpdated");
    await this.saveData(this.settings);
  }
  deactivateDataExplorer() {
    this.app.workspace.detachLeavesOfType(viewType);
  }
  async activateDataExplorer() {
    this.deactivateDataExplorer();
    const leaf = this.app.workspace.createLeafBySplit(
      this.app.workspace.activeLeaf,
      "vertical"
    );
    await leaf.setViewState({
      type: viewType
    });
  }
  activateReferenceList() {
    if (this.view) {
      return;
    }
    this.app.workspace.getRightLeaf(false).setViewState({
      type: viewType2
    });
  }
  deactivateReferenceList() {
    this.app.workspace.detachLeavesOfType(viewType2);
  }
  async updatePDFUtility() {
    if (!this.settings.exeOverridePath && this.settings.exeVersion && this.settings.exeVersion !== currentVersion) {
      const modal = new LoadingModal(
        app,
        "Updating Obsidian Zotero Integration PDF Utility..."
      );
      modal.open();
      try {
        const success = await downloadAndExtract();
        if (success) {
          this.settings.exeVersion = currentVersion;
          this.saveSettings();
        }
      } catch (e3) {
      }
      modal.close();
    }
  }
};
/*! Bundled license information:

nunjucks/browser/nunjucks.js:
  (*! Browser bundle of nunjucks 3.2.4  *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

content-disposition/index.js:
  (*!
   * content-disposition
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

is-natural-number/index.js:
  (*!
   * is-natural-number.js | MIT (c) Shinnosuke Watanabe
   * https://github.com/shinnn/is-natural-number.js
  *)

strip-dirs/index.js:
  (*!
   * strip-dirs | MIT (c) Shinnosuke Watanabe
   * https://github.com/shinnn/node-strip-dirs
  *)

has-symbol-support-x/index.js:
  (**
   * @file Tests if ES6 Symbol is supported.
   * @version 1.4.2
   * @author Xotic750 <Xotic750@gmail.com>
   * @copyright  Xotic750
   * @license {@link <https://opensource.org/licenses/MIT> MIT}
   * @module has-symbol-support-x
   *)

has-to-string-tag-x/index.js:
  (**
   * @file Tests if ES6 @@toStringTag is supported.
   * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-@@tostringtag|26.3.1 @@toStringTag}
   * @version 1.4.1
   * @author Xotic750 <Xotic750@gmail.com>
   * @copyright  Xotic750
   * @license {@link <https://opensource.org/licenses/MIT> MIT}
   * @module has-to-string-tag-x
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
