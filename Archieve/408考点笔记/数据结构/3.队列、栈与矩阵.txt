栈
0.栈的数学性质:
n个元素以某种序列进栈,满足FILO时候随意出栈,可以得到的出栈序列种类:catalan();
1.栈的定义 stack
从一端进出,先进后出 FILO特性
int stack[MaxSize];
int top = -1;
存储结构
1.链式栈(不重要)
应用头插法插入删除的链表
typedef struct LNode //节点定义,带头结点链表
{
int data;
LNode *next;
}LNode;
Node *top;
新建节点:
LNode *p;
p = (LNode *)malloc(sizeof(LNode));
p->next = NULL;
类型
操作:
1.判空:head->next == NULL;
head == top;
2.元素进栈:见头插法
...

2.元素出栈:链表的删除
....

2.顺序栈
用线性表实现插入删除的栈
typedef struct stack{
int data[MAX];
int top;
}stack;

stack st;
st.top = -1;

简单定义:
int stack[MAX];
int top = -1;
操作:
1.判断为空:top == -1;
1.1上溢下溢状态:
没法再进栈,没法再出栈
初始化操作:top = -1;
2.进栈:
stack[++top] = x;
3.出栈:
x = stack[top--];

P61
栈的算法(选择题常考):重点手工模拟,熟记再去追求代码
括号匹配:

表达式计算(上机原题,之前再去考虑代码的事情):
前缀式和后缀式,计算顺序是唯一的,摆脱了括号的烦恼.
中缀式:1+1+2
前缀式(LISP):++1 1 2 (例3-2) 逆波兰表示法
后缀式: 1 1 2++ 计算可以用栈来解决

中缀式转化为后缀式:
1.按照运算符优先级对所有运算符和他的运算数加括号
2.把运算符移动到括号之后
3.去掉括号

真题2018 第一题 注意出栈顺序和计算






函数调用自身,那么他就是递归定义的,简称递归.
1.递归式
2.递归边界

分治法的时间复杂度分析
1.确定子问题规模
2.确定递归返回边界
O(nlogn)

f(n) = n * f(n - 1) //数学递推式

int func(int i)//阶乘
{
	if(i == 1||i == 0)  return 1;
	return i * func(i - 1)
}


数制转换:进制转换
除基取余法,用栈实现倒着输出余数


递归调用:
所有的递归算法都可以用循环迭代和栈配合改成迭代算法


尾递归会被优化为循环.
(编译原理)
int func(...)
{

return func()
}



给定进出栈序列(表达式),求栈的最大深度.

给定进栈序列,求出栈序列

解决方法就是模拟.

1,2,3 n .... 7,8,9
n出栈了,说明n前面元素已经全部入过栈,n后面元素可能部分未入栈

队列 queue
1.队列定义
从一端进,从另一端出去 FIFO特性
实现

1.顺序队列:
typedef struct queue{
int data[MaxSize];
int front;
int rear;
}queue;
queue qu;
假溢出问题:头指针和尾指针的操作不当,混淆了队满和队空的判断条件,front == rear == MAX - 1;

一般使用循环队列去解决这个问题:
1.循环使用存储空间,对下标进行取余;
2.设置一个空白的存储空间,类似头节点;
操作:
1.判空(队空):
qu.front == qu.rear;
2.判断是否为满:
(qu.rear +1 )%maxSize == qu.front;
计算队中元素个数:
(qu.rear - qu.front + maxSize) % maxSize;

3.进队出队(切记判断过程):先移动指针,再存取元素.
进队:
qu.rear = (qu.rear +1 )%maxSize;
qu.data[qu.rear] = x;

出队:
qu.front = (qu.front + 1)%maxSize;
x = qu.data[qu.front];

4.初始化
front = rear = 0;



指针创建没用到的时候记得指空;
指针用完不用了,记得free;
==>防止内存泄露.



2.链式队列:
定义节点:
typedef struct QNode //节点定义
{
int data;
QNode *next;
}QNode;


定义类型:  尾节点next指针指空!


typedef struct Queue{
QNode * front;
QNode * rear;
}Queue;
空链队://有初始节点(头节点):front == rear == 初始节点/NULL

判空条件:
默认没有初始节点  front == rear == NULL;
队满状态:默认永远不满(动态分配内存)


出队操作之后记得判空,记得指空front == rear == NULL;
p67

队列的应用
1.解决逐行或逐层的问题，如层序遍历二叉树。
2.解决主机与外部设备之间速度不匹配的问题，如缓冲区。(OS)
3.解决由多用户引起的资源竞争问题，如进程的就绪队列。(OS)


特殊栈\队 P68
1.双端队列和特殊队列
一端进出,另一端出
两端皆可进出
2.共享栈


ADT:抽象数据类型(P71建模方法)




串（KMP在P97）、矩阵(用一维数组存储)
考点：
1.下标计算
存储方式：
行优先:
列优先:
到组成原理存储体 用到。
int A[3][4] ={{1....},{...}}
[[39, 45, 27, 93],
 [75, 53, 28, 56],
 [  2, 59, 36, 24]]

a[0][0] a[0][1]


a[0][0] a[1][0]

下标计算：a[m][n]中a[i][j] 是第
行优先：in+j+1个元素
列优先：jm+i+1个元素

到OS的bit位示图图会用到。

特殊矩阵：主要还是下标计算和存储空间的计算
窍门是画图计算，技巧是计算出重点元素的地址
对称阵
三角阵
对角阵 5-2,3
注意看题目定义，计算技巧如上

稀疏矩阵：绝大多数元素都是零
1.三元组
是一个3*N的二维数组
第零行存储 非零元素个数 行数 列数（整体信息）
后续行中存储非零元素的 值 行 列


2.伪地址表示法
就是HASH散列,计算非零元素伪地址，用伪地址操作
散列函数为f(...)=n(i-1)+j

P118

广义表:

list 嵌套的线性表

a = [1,2,3,[4,5,6,[5,5]]]
长度:最表层元素个数 4
深度:括号嵌套最大层数 3


广义表可以无线深

优先选择题,优先真题


习题
真题



70
