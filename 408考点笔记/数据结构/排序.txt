Nv[1] = 0
p[j] ≠ p[k] 则,Nv[j] = k,不相同就照抄
p[j] = p[k] 则,Nv[j] = Nv[k]
纯死记硬背

KMP算法的概念和性质,next数组求法
abaaba



排序:

关键字:学号和成绩
用来排序的依据是主关键字,其余是次关键字

纵向:手工模拟,原理,代码
横向:算法的共有性质

稳定性:相同关键字相对顺序不变
归位性:一趟排序把元素送到最终位置

内部排序
插入排序
    直接插入
    折半插入
    希尔排序
交换排序
   快速排序*
   冒泡排序
选择排序
    简单选择
    堆排序*
基数排序
  最高位/最低位优先
归并排序

外部排序
    外部归并
*


(大顶堆,父亲大,根元素最大)
构造堆:层次有序建堆,从右向左,从下向上调整元素
调整元素(非叶节点):
1.对象和左右孩子比较,较大的孩子与对象交换
2.对象一直向下调整(继续调整对象)

删除:把元素删除,用最右下元素补位,(其实是元素和数组末尾元素交换位置), 然后调整整棵树
插入:把元素插入到最右下位置,满足完全二叉树定义,向上调整元素(或者说是调整整棵树)
排序:不断删除堆顶元素

n:关键字数
Rd

m叉豪夫曼树补零 在左侧补(N-1)%(m-1)个零
N:已有节点个数
m:m叉树



直插冒泡最好n
快希归堆nlogn*
快栈归n基rd*
快希选堆不稳定*
交换选择送到家
比较无关选折半
趟数有关交换类
插冒选链别全顺



int sqsearch(int a[],int n,int k)
{
	int i = n;
	a[0] = k;//设置哨兵(常用技巧)
	while(a[i] != k) i--;
	return i;//查找失败遇到哨兵,没找到返回零
}





mid = (high - low)/2 +low;//防止溢出
mid = (low+ high )/2



对于折半查找,查找的比较次数就是从根节点到此节点所经历节点数

分块查找:

多重索引分块顺序查找




ASL1分母:表中元素数

ASL2分母:映射到的地址个数(p)