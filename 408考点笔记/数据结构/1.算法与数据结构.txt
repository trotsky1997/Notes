C语言伪代码
	除变量的引用型 &k 外,其他还是用C
typedef struct node{
int a;
int b;
}node;



样例输入 : hyhyt
样例输出 : error

node *p;
p = (node *)malloc(sizeof(node));

p = new node;
node key[Maxsize];//Maxsize是一个已经定义的常量,足够大

p->a;
p->b;
数据结构,(懂就行)
数据
数据项,
数据元素


存储方法(OS,数据结构):
顺序栈:顺序表实现的栈.
int a[MAX];
int top = -1;

a[++top] =t;
t = a[top--];


数据的逻辑结构:
1.线性结构:
一对一 关系

2.非线性结构
网状(图)\树状,一对多关系

数据存储方式(物理结构):
1.顺序存储
一个挨一个,内存地址连续
2.链式存储,不一定非要用指针
前驱->后继->,环环相扣,但是内存地址不一定连续

实现指向功能

静态二叉树
int tree[Max][3];
tree [0]:
tree [0][0] tree[0][1] tree [0][2]
     值|左子节点|右子节点

3.索引存储(OS)
用一个专门的索引表去存储数据元素的地址
<关键字:地址(指针)>
dict :{key:value}
4.散列存储
用hash函数,比如用名字来算出内存地址
map[2]



数据访问方式:

1.直接访问,随机访问:散列或者顺序
用一定的方式直接算出下标(内存地址).
int a[10];
int* p;
p = &a[6];


*(&a + sizeof(int) * i)
等价于
a[i]

2.间接访问:链式或者索引
有查表的过程或者遍历访问

算法复杂度分析(11-13)

1.描述思想 1-2
用伪代码和自然语言进行描述
2.代码实现
int func(...){
...//重要的是注释
//生成一个数组
}
3.分析复杂度 2-3
O(n)
O(nlogn)
O(n^2)
时间复杂度
空间复杂度要和代码一致



**时间复杂度 O(logn)
T(n)=O(f(n))
n:问题的规模
f(n):频度,基本操作的执行次数,函数


int haha(int a[],int n)//数组a全部-1
{

for(int i = 0; i < n; i++) a[i]--;
}

f(n) = y(n)

O 对一个多项式y
1.找出最高次项
2.去掉最高次项的系数
y = 10000*n^1000 + n^2 +n^5

O(n^1000)
O(f(n))


乘法规则
循环嵌套的计算

O(n^2)

for(...){//执行3*n次
	for(...)//执行3*n次
	{
 		func1();
		func2();
	}
}


加法规则
循环并列的计算


int fun3(){
fun1(...);//O(n^3)
fun2(...);//O(n^2)
}


O(fun3) =  O(fun1) + O(fun2) =  O(n^3 + n^2)  = O(n^3)



1.找基本操作
2.确定问题规模

int func(int a[])
{
 print(a[1]);
}

*时间复杂度比阶
O(1)(通用)<<O(log n)<<O(n)(一遍扫描)<<O(nlogn)(分治法\递归)<<O(n^2.. )(嵌套遍历循环)<<O(2^n)<<O(n^n)<<O(n!)


无限猴子排序

**空间复杂度
func(a);要了2n个存储空间
O(2n) = O(n)

int func(int *a)//a的大小是n
{

int c,d,e;//要了常数个
.....
 return *a;//O(1),也叫原地工作

}


int func(int a[],int n)
{
int sum = 0;

 for(...)
{
	sum += a[i];
}
return sum;
}


计数排序 空间复杂度O(1)
时间复杂度O(n)

a = [3,6,9,8,7]
n是a的元素数量

int b[MAX];//MAX是已经定义的一个常量,足够大
b = memset(b,0,sizeof(int)*MAX);//b初始化全部为零
for(int i = 0;i < length(a) -1;i++)

{
	b[a[i]] = 1;//b[3] = 1;

}

b
0  1 2 3 4 5 6 7 8 9 ...
0  0 0 1 0 0 1 1 1 1...
重新对b遍历,0不输出,是1的输出下标

3 6 7 8 9...


算法设计题目三段式 13~15 写了就有分
1.描述思想
2.代码实现
3.分析复杂度


内存地址题目 15~18
进行了....操作,以....语句为基本操作,该操作进行了...次,所以本算法时间复杂度为..,额外使用了...空间,和n有关(无关),空间复杂度为...




十年考了七年线性表,两年树的搜索遍历
默写会背
算法复杂度分析选择题

17 13~14



-------------------------------


typedef struct Node
{
 	int data;
 	struct Node *next;
}Node;

以变长数组为例申请并初始化内存空间.
int* p;
p = (int* )malloc(n * sizeof(int));
p就是n大小的数组.


申请一个新链表节点

Node *p;
p = (Node *)malloc(sizeof(Node));







